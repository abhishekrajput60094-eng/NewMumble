{
  "file_contents": {
    "apps/xmtp.chat/src/icons/MetamaskWallet.tsx": {
      "content": "export const MetamaskWallet = () => {\n  return (\n    <svg\n      width=\"28\"\n      height=\"28\"\n      viewBox=\"0 0 28 28\"\n      fill=\"none\"\n      xmlns=\"http://www.w3.org/2000/svg\">\n      <rect width=\"28\" height=\"28\" fill=\"white\" />\n      <path\n        d=\"M24.0891 3.1199L15.3446 9.61456L16.9617 5.7828L24.0891 3.1199Z\"\n        fill=\"#E2761B\"\n        stroke=\"#E2761B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M3.90207 3.1199L12.5763 9.67608L11.0383 5.7828L3.90207 3.1199Z\"\n        fill=\"#E4761B\"\n        stroke=\"#E4761B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M20.9429 18.1745L18.6139 21.7426L23.597 23.1136L25.0295 18.2536L20.9429 18.1745Z\"\n        fill=\"#E4761B\"\n        stroke=\"#E4761B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M2.97929 18.2536L4.40301 23.1136L9.38607 21.7426L7.05713 18.1745L2.97929 18.2536Z\"\n        fill=\"#E4761B\"\n        stroke=\"#E4761B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M9.10483 12.1456L7.71626 14.2461L12.6642 14.4658L12.4884 9.14877L9.10483 12.1456Z\"\n        fill=\"#E4761B\"\n        stroke=\"#E4761B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M18.8864 12.1456L15.4589 9.08725L15.3446 14.4658L20.2837 14.2461L18.8864 12.1456Z\"\n        fill=\"#E4761B\"\n        stroke=\"#E4761B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M9.38606 21.7426L12.3566 20.2925L9.79033 18.2888L9.38606 21.7426Z\"\n        fill=\"#E4761B\"\n        stroke=\"#E4761B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M15.6347 20.2925L18.6139 21.7426L18.2009 18.2888L15.6347 20.2925Z\"\n        fill=\"#E4761B\"\n        stroke=\"#E4761B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M18.6139 21.7426L15.6347 20.2925L15.8719 22.2348L15.8456 23.0521L18.6139 21.7426Z\"\n        fill=\"#D7C1B3\"\n        stroke=\"#D7C1B3\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M9.38606 21.7426L12.1544 23.0521L12.1368 22.2348L12.3566 20.2925L9.38606 21.7426Z\"\n        fill=\"#D7C1B3\"\n        stroke=\"#D7C1B3\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M12.1984 17.0056L9.72002 16.2762L11.4689 15.4765L12.1984 17.0056Z\"\n        fill=\"#233447\"\n        stroke=\"#233447\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M15.7928 17.0056L16.5223 15.4765L18.28 16.2762L15.7928 17.0056Z\"\n        fill=\"#233447\"\n        stroke=\"#233447\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M9.38606 21.7426L9.80791 18.1745L7.05712 18.2536L9.38606 21.7426Z\"\n        fill=\"#CD6116\"\n        stroke=\"#CD6116\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M18.1921 18.1745L18.6139 21.7426L20.9429 18.2536L18.1921 18.1745Z\"\n        fill=\"#CD6116\"\n        stroke=\"#CD6116\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M20.2837 14.2461L15.3446 14.4658L15.8016 17.0057L16.5311 15.4765L18.2888 16.2762L20.2837 14.2461Z\"\n        fill=\"#CD6116\"\n        stroke=\"#CD6116\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M9.72002 16.2762L11.4777 15.4765L12.1984 17.0057L12.6642 14.4658L7.71626 14.2461L9.72002 16.2762Z\"\n        fill=\"#CD6116\"\n        stroke=\"#CD6116\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M7.71626 14.2461L9.79033 18.2888L9.72002 16.2762L7.71626 14.2461Z\"\n        fill=\"#E4751F\"\n        stroke=\"#E4751F\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M18.2888 16.2762L18.2009 18.2888L20.2837 14.2461L18.2888 16.2762Z\"\n        fill=\"#E4751F\"\n        stroke=\"#E4751F\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M12.6642 14.4658L12.1984 17.0057L12.7784 20.0025L12.9102 16.0565L12.6642 14.4658Z\"\n        fill=\"#E4751F\"\n        stroke=\"#E4751F\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M15.3446 14.4658L15.1073 16.0477L15.2128 20.0025L15.8016 17.0057L15.3446 14.4658Z\"\n        fill=\"#E4751F\"\n        stroke=\"#E4751F\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M15.8016 17.0056L15.2128 20.0025L15.6347 20.2925L18.2009 18.2888L18.2888 16.2762L15.8016 17.0056Z\"\n        fill=\"#F6851B\"\n        stroke=\"#F6851B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M9.72002 16.2762L9.79033 18.2888L12.3566 20.2925L12.7784 20.0025L12.1984 17.0056L9.72002 16.2762Z\"\n        fill=\"#F6851B\"\n        stroke=\"#F6851B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M15.8456 23.0521L15.8719 22.2348L15.6522 22.0414H12.339L12.1368 22.2348L12.1544 23.0521L9.38606 21.7426L10.3528 22.5336L12.3126 23.8958H15.6786L17.6472 22.5336L18.6139 21.7426L15.8456 23.0521Z\"\n        fill=\"#C0AD9E\"\n        stroke=\"#C0AD9E\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M15.6347 20.2925L15.2128 20.0025H12.7784L12.3566 20.2925L12.1368 22.2348L12.339 22.0414H15.6522L15.8719 22.2348L15.6347 20.2925Z\"\n        fill=\"#161616\"\n        stroke=\"#161616\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M24.4583 10.0364L25.2053 6.45072L24.0891 3.1199L15.6347 9.39485L18.8864 12.1456L23.4827 13.4903L24.5022 12.3038L24.0628 11.9874L24.7658 11.3459L24.221 10.924L24.924 10.3879L24.4583 10.0364Z\"\n        fill=\"#763D16\"\n        stroke=\"#763D16\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M2.79472 6.45072L3.54174 10.0364L3.06717 10.3879L3.77024 10.924L3.23415 11.3459L3.93722 11.9874L3.4978 12.3038L4.50847 13.4903L9.10483 12.1456L12.3566 9.39485L3.90207 3.1199L2.79472 6.45072Z\"\n        fill=\"#763D16\"\n        stroke=\"#763D16\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M23.4827 13.4903L18.8864 12.1456L20.2837 14.2461L18.2009 18.2888L20.9429 18.2536H25.0295L23.4827 13.4903Z\"\n        fill=\"#F6851B\"\n        stroke=\"#F6851B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M9.10484 12.1456L4.50848 13.4903L2.97929 18.2536H7.05713L9.79033 18.2888L7.71626 14.2461L9.10484 12.1456Z\"\n        fill=\"#F6851B\"\n        stroke=\"#F6851B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path\n        d=\"M15.3446 14.4658L15.6347 9.39485L16.9705 5.7828H11.0383L12.3566 9.39485L12.6642 14.4658L12.7696 16.0653L12.7784 20.0025H15.2128L15.2304 16.0653L15.3446 14.4658Z\"\n        fill=\"#F6851B\"\n        stroke=\"#F6851B\"\n        strokeWidth=\"0.0878845\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n    </svg>\n  );\n};\n",
      "size_bytes": 8070
    },
    "content-types/content-type-group-updated/src/index.ts": {
      "content": "export * from \"./GroupUpdated\";\n",
      "size_bytes": 32
    },
    "apps/xmtp.chat-api-service/src/api/v1/resolve.router.ts": {
      "content": "import type { Platform, Profile } from \"@prisma/client\";\nimport { addDays, isAfter } from \"date-fns\";\nimport { Router, type Request, type Response } from \"express\";\nimport {\n  Platform as Web3BioPlatform,\n  type ProfileResponse,\n} from \"web3bio-profile-kit/types\";\nimport { z } from \"zod\";\nimport { prisma } from \"../../helpers/prisma.js\";\nimport {\n  batchFetchNames,\n  fetchProfilesFromName,\n} from \"../../helpers/web3.bio.js\";\n\nconst hasIdentity = (identity: string, profiles: Profile[]) => {\n  const [platform, address] = identity.split(\",\");\n  return profiles.some((p) => p.platform === platform && p.address === address);\n};\n\nexport const resolvePlatform = (platform: Web3BioPlatform): Platform => {\n  switch (platform) {\n    case Web3BioPlatform.ens:\n      return \"ens\";\n    case Web3BioPlatform.basenames:\n      return \"basenames\";\n    default:\n      return \"unknown\";\n  }\n};\n\ntype ProfileResponseWithAddress = ProfileResponse & {\n  address: string;\n};\n\nexport const resolveAddressSchema = z.object({\n  addresses: z.string().length(42).startsWith(\"0x\").array().min(1),\n});\n\nexport async function resolveProfiles(req: Request, res: Response) {\n  try {\n    const { addresses } = resolveAddressSchema.parse(req.body);\n    const identities = addresses.reduce<string[]>((result, address) => {\n      return [...result, `ens,${address}`, `basenames,${address}`];\n    }, []);\n\n    const cachedProfiles = await prisma.profile.findMany({\n      where: {\n        address: {\n          in: addresses,\n        },\n      },\n    });\n\n    // identities not found in the database\n    const missingIdentities = identities.filter(\n      (identity) => !hasIdentity(identity, cachedProfiles),\n    );\n\n    // profiles that have been updated within the last 7 days\n    const validProfiles = cachedProfiles.filter(\n      (profile) => !isAfter(new Date(), addDays(profile.updatedAt, 7)),\n    );\n\n    // profiles that have not been updated in the last 7 days\n    const expired = cachedProfiles.filter((profile) =>\n      isAfter(new Date(), addDays(profile.updatedAt, 7)),\n    );\n    const expiredProfileIdentities = expired.map(\n      (p) => `${p.platform},${p.address}`,\n    );\n\n    const addressesToResolve = [\n      ...missingIdentities,\n      ...expiredProfileIdentities,\n    ];\n\n    const fetchedProfiles = await batchFetchNames(addressesToResolve);\n\n    // insert new profiles into the database\n    const newProfiles = fetchedProfiles.filter(\n      (p) =>\n        p.address && missingIdentities.includes(`${p.platform},${p.address}`),\n    ) as ProfileResponseWithAddress[];\n    if (newProfiles.length > 0) {\n      const createdProfiles = await prisma.profile.createManyAndReturn({\n        data: newProfiles.map((p) => ({\n          address: p.address,\n          avatar: p.avatar,\n          description: p.description,\n          displayName: p.displayName,\n          identity: p.identity,\n          platform: resolvePlatform(p.platform),\n        })),\n      });\n      validProfiles.push(...createdProfiles);\n    }\n\n    // update expired profiles in the database\n    const expiredProfiles = fetchedProfiles.filter(\n      (p) =>\n        p.address &&\n        expiredProfileIdentities.includes(`${p.platform},${p.address}`),\n    );\n\n    if (expiredProfiles.length > 0) {\n      for (const p of expiredProfiles) {\n        const expiredProfile = expired.find(\n          (e) => e.address === p.address && e.platform === p.platform,\n        );\n        if (!expiredProfile || !p.address) {\n          continue;\n        }\n        const updatedProfile = await prisma.profile.update({\n          where: { id: expiredProfile.id },\n          data: {\n            address: p.address,\n            avatar: p.avatar,\n            description: p.description,\n            displayName: p.displayName,\n            platform: resolvePlatform(p.platform),\n          },\n        });\n        validProfiles.push(updatedProfile);\n      }\n    }\n\n    // return the profiles\n    res.json({\n      profiles: validProfiles.map((p) => ({\n        address: p.address,\n        avatar: p.avatar,\n        description: p.description,\n        displayName: p.displayName,\n        identity: p.identity,\n        platform: p.platform,\n      })),\n    });\n  } catch (error: unknown) {\n    if (error instanceof z.ZodError) {\n      console.error(z.prettifyError(error));\n      res.status(400).json({\n        error: \"Invalid request body\",\n        details: z.treeifyError(error),\n      });\n      return;\n    }\n    console.error(error);\n    res.status(500).json({ error: \"Failed to resolve addresses\" });\n  }\n}\n\nexport const resolveNameSchema = z.string().endsWith(\".eth\");\n\nexport async function resolveName(req: Request, res: Response) {\n  try {\n    const { name } = req.params;\n    const validName = resolveNameSchema.parse(name);\n    const profiles = await fetchProfilesFromName(validName);\n    if (!profiles || profiles.length === 0) {\n      res.status(404).json({ error: \"No profiles found\" });\n      return;\n    }\n    res.json({ address: profiles[0].address });\n  } catch (error: unknown) {\n    if (error instanceof z.ZodError) {\n      console.log(\"zod error\", z.prettifyError(error));\n      res.status(400).json({\n        error: \"Invalid request parameter\",\n        details: z.treeifyError(error),\n      });\n      return;\n    }\n    console.error(error);\n    res.status(500).json({ error: \"Failed to resolve name\" });\n  }\n}\n\nconst resolveRouter = Router();\nresolveRouter.get(\"/name/:name\", resolveName);\nresolveRouter.post(\"/profiles\", resolveProfiles);\n\nexport default resolveRouter;\n",
      "size_bytes": 5514
    },
    "apps/xmtp.chat/src/helpers/queries.ts": {
      "content": "import { QueryClient } from \"@tanstack/react-query\";\n\nexport const queryClient = new QueryClient();\n",
      "size_bytes": 100
    },
    "apps/xmtp.chat/src/components/App/UseEphemeral.tsx": {
      "content": "import { Button, Group, Switch, Text, Tooltip } from \"@mantine/core\";\nimport { useCallback } from \"react\";\nimport { useConnectWallet } from \"@/hooks/useConnectWallet\";\nimport { useSettings } from \"@/hooks/useSettings\";\n\nexport const UseEphemeral: React.FC = () => {\n  const { isConnected } = useConnectWallet();\n  const {\n    ephemeralAccountEnabled,\n    setEphemeralAccountEnabled,\n    setEphemeralAccountKey,\n  } = useSettings();\n\n  const handleEphemeralAccountChange = (\n    event: React.ChangeEvent<HTMLInputElement>,\n  ) => {\n    setEphemeralAccountEnabled(event.currentTarget.checked);\n  };\n\n  const handleResetEphemeralAccount = useCallback(() => {\n    setEphemeralAccountEnabled(false);\n    setEphemeralAccountKey(null);\n  }, []);\n\n  return (\n    <Group gap=\"sm\" align=\"center\" wrap=\"nowrap\">\n      <Text fw=\"bold\" size=\"sm\" style={{ display: \"none\" }}>\n        Use ephemeral wallet\n      </Text>\n      <Tooltip\n        label=\"Enable this option to use a temporary wallet for signing messages\"\n        refProp=\"rootRef\">\n        <Switch\n          size=\"md\"\n          disabled={isConnected}\n          checked={ephemeralAccountEnabled}\n          onChange={handleEphemeralAccountChange}\n          withThumbIndicator={false}\n        />\n      </Tooltip>\n      <Button\n        size=\"xs\"\n        onClick={handleResetEphemeralAccount}\n        color=\"red.7\"\n        variant=\"outline\">\n        Reset\n      </Button>\n    </Group>\n  );\n};\n",
      "size_bytes": 1435
    },
    "apps/xmtp.chat/src/components/App/ConnectedAddress.tsx": {
      "content": "import { Box, Button, Flex, Group, Text, Tooltip } from \"@mantine/core\";\nimport { useClipboard } from \"@mantine/hooks\";\nimport { useCallback } from \"react\";\nimport { CopyButton } from \"@/components/CopyButton\";\nimport { shortAddress } from \"@/helpers/strings\";\nimport classes from \"./ConnectedAddress.module.css\";\n\nconst GlowingCircle = () => {\n  return (\n    <Box\n      w={6}\n      h={6}\n      bg=\"green.6\"\n      style={{\n        borderRadius: \"50%\",\n        boxShadow: \"0px 0px 2px 2px var(--mantine-color-green-9)\",\n      }}\n    />\n  );\n};\n\nexport type AddressTooltipLabelProps = {\n  address: string;\n};\n\nexport const AddressTooltipLabel: React.FC<AddressTooltipLabelProps> = ({\n  address,\n}) => {\n  return (\n    <Flex direction=\"column\">\n      <Text size=\"sm\">{address}</Text>\n      <Text size=\"xs\" c=\"dimmed\" ta=\"center\">\n        click to copy\n      </Text>\n    </Flex>\n  );\n};\n\nexport type ConnectedAddressProps = {\n  address: string;\n  size?: \"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\";\n  onClick?: () => void;\n};\n\nexport const ConnectedAddress: React.FC<ConnectedAddressProps> = ({ address, size = \"lg\", onClick }) => {\n  const clipboard = useClipboard({ timeout: 1000 });\n\n  const handleCopy = useCallback(\n    (\n      event:\n        | React.MouseEvent<HTMLDivElement>\n        | React.KeyboardEvent<HTMLDivElement>,\n    ) => {\n      event.stopPropagation();\n      clipboard.copy(address);\n    },\n    [clipboard, address],\n  );\n\n  const handleKeyboardCopy = useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (event.key === \"Enter\" || event.key === \" \") {\n        handleCopy(event);\n      }\n    },\n    [handleCopy],\n  );\n\n  return (\n    <Group align=\"center\" gap=\"xs\" className={classes.wrapper}>\n      <GlowingCircle />\n      <Tooltip\n        label={\n          clipboard.copied ? (\n            <Text size=\"xs\">Copied!</Text>\n          ) : (\n            <AddressTooltipLabel address={address} />\n          )\n        }\n        withArrow\n        events={{ hover: true, focus: true, touch: true }}>\n        <Text\n          size={size}\n          fw={700}\n          onKeyDown={handleKeyboardCopy}\n          onClick={handleCopy}\n          tabIndex={0}\n          aria-label=\"Connected account\"\n          className={classes.address}>\n          {shortAddress(address)}\n        </Text>\n      </Tooltip>\n      <CopyButton value={address} />\n      <Button size=\"xs\" variant=\"default\" onClick={onClick}>\n        Disconnect\n      </Button>\n    </Group>\n  );\n};\n",
      "size_bytes": 2470
    },
    "apps/xmtp.chat/src/components/Conversations/ConversationCard.module.css": {
      "content": ".root {\n  cursor: pointer;\n  background: rgba(255, 255, 255, 0.04);\n  border: 1px solid rgba(148, 163, 184, 0.08);\n  transition:\n    transform 0.16s ease,\n    border-color 0.16s ease,\n    background 0.16s ease,\n    box-shadow 0.16s ease;\n  backdrop-filter: blur(10px);\n}\n\n.root:hover {\n  transform: translateY(-2px);\n  background: linear-gradient(\n    135deg,\n    rgba(10, 255, 241, 0.14),\n    rgba(151, 114, 251, 0.14)\n  );\n  border-color: rgba(10, 255, 241, 0.16);\n  box-shadow: 0 18px 32px rgba(4, 10, 26, 0.35);\n}\n\n.root:focus {\n  outline: none;\n  border-color: rgba(10, 255, 241, 0.28);\n  box-shadow: 0 18px 32px rgba(4, 10, 26, 0.45);\n}\n\n.selected {\n  background: linear-gradient(\n    135deg,\n    rgba(10, 255, 241, 0.18),\n    rgba(151, 114, 251, 0.18)\n  );\n  border-color: rgba(10, 255, 241, 0.3);\n  box-shadow: 0 22px 40px rgba(4, 10, 26, 0.45);\n}\n\n.title {\n  color: rgba(238, 242, 255, 0.96);\n  letter-spacing: 0.01em;\n}\n\n.time {\n  font-variant-numeric: tabular-nums;\n  opacity: 0.7;\n}\n\n.preview {\n  color: rgba(203, 213, 225, 0.75);\n}\n\n.meta {\n  font-size: 0.75rem;\n  letter-spacing: 0.08em;\n  text-transform: uppercase;\n  color: rgba(148, 163, 184, 0.65);\n}\n",
      "size_bytes": 1169
    },
    "sdks/node-sdk/CHANGELOG.md": {
      "content": "# @xmtp/node-sdk\n\n## 4.2.4\n\n### Patch Changes\n\n- 9003bb9: Enable hex strings as database encryption keys\n\n## 4.2.3\n\n### Patch Changes\n\n- 61c19c9:\n  - Fixed an issue where duplicate welcome errors were fired erroneously\n  - Fixed a bug where building a client did a network request when not needed\n\n## 4.2.2\n\n### Patch Changes\n\n- b7a860e: Refactored `lastMessage()` method of `Conversation` to always query the database\n\n## 4.2.1\n\n### Patch Changes\n\n- 0abcb05: Fixed initial group membership validation\n\n## 4.2.0\n\n- Improved performance of syncing new groups\n- Added support for Lens chain Smart Contract Wallet verifier\n- Fixed OpenMLS issue for persistence during message processing\n- Fixed lifetime validation gaps\n\n## 4.1.2\n\n### Patch Changes\n\n- bb4163f: - Added `onError` callback when stream reconnection fails\n  - Updated `uuid` dependency to v13\n\n## 4.1.1\n\n### Patch Changes\n\n- 5b0160e: Updated `dbPath` client option to allow callback function\n\n## 4.1.0\n\nThis release introduces improved fork detection. If you've been building on a previous release, this one should be a **drop-in replacement**. Update as soon as possible to take advantage of this enhancement.\n\n### Improved fork detection\n\nThe `isCommitLogForked` field provides definitive fork detection without false positives. To minimize the negative effects of spam, fork detection is active only for groups that a user has actively consented to.\n\nImportant: The `maybeForked` field has been deprecated. You can now use `isCommitLogForked` instead to get definitive fork detection without false positives.\n\nTo learn more, see [Forked group debugging tool](https://docs.xmtp.org/inboxes/debug-your-app#forked-group-debugging-tool).\n\n## 4.0.3\n\n### Patch Changes\n\n- ed36644: Reverted performance improvement for large inboxes that caused message streaming issues\n\n## 4.0.2\n\n### Patch Changes\n\n- ffec6e0:\n  - Improved performance for large inboxes\n  - Improved key package errors\n  - Added `appVersion` client option\n  - Added `debugEventsEnabled` client option\n  - Fixed DM stitching bug\n  - Added expiration to messages for disappearing messages\n\n## 4.0.1\n\n### Patch Changes\n\n- 3170da0: Improved syncAll performance when syncing large numbers of conversations\n\n## 4.0.0\n\nThis release introduces several enhancements to improve stream reliability. It contains breaking changes.\n\n### Stream reliability improvements\n\nWhen streams fail, an attempt to reconnect will be made automatically. By default, a stream will be retried 6 times with a 10 second delay between each retry. Maximum retries and retry delay can be configured with the `retryAttempts` and `retryDelay` options, respectively. To disable this feature, set the `retryOnFail` option to `false`.\n\nDuring the retry process, the `onRetry` and `onRestart` callbacks can be used to monitor progress.\n\n### BREAKING CHANGES\n\n#### All streaming methods are now async and accept a single options argument\n\nThe new argument defines streaming options:\n\n```ts\ntype StreamOptions<T = unknown, V = T> = {\n  /**\n   * Called when the stream ends\n   */\n  onEnd?: () => void;\n  /**\n   * Called when a stream error occurs\n   */\n  onError?: (error: Error) => void;\n  /**\n   * Called when the stream fails\n   */\n  onFail?: () => void;\n  /**\n   * Called when the stream is restarted\n   */\n  onRestart?: () => void;\n  /**\n   * Called when the stream is retried\n   */\n  onRetry?: (attempts: number, maxAttempts: number) => void;\n  /**\n   * Called when a value is emitted from the stream\n   */\n  onValue?: (value: V) => void;\n  /**\n   * The number of times to retry the stream\n   * (default: 6)\n   */\n  retryAttempts?: number;\n  /**\n   * The delay between retries (in milliseconds)\n   * (default: 10000)\n   */\n  retryDelay?: number;\n  /**\n   * Whether to retry the stream if it fails\n   * (default: true)\n   */\n  retryOnFail?: boolean;\n};\n```\n\nIn addition to these options, some streaming methods have more options. See their respective types for more details.\n\nUpdate your calls to each streaming method as follows:\n\n```ts\n// OLD\nconst conversationStream = client.conversations.stream(callback, onFail);\nconst groupStream = client.conversations.streamGroups(callback, onFail);\nconst dmStream = client.conversations.streamDms(callback, onFail);\nconst allMessagesStream = await client.conversations.streamAllMessages(\n  callback,\n  conversationType,\n  consentStates,\n  onFail,\n);\nconst allGroupMessagesStream = await client.conversations.streamAllGroupMessages(\n  callback,\n  consentStates,\n  onFail,\n);\nconst allDmMessagesStream = await client.conversations.streamAllDmMessages(\n  callback,\n  consentStates,\n  onFail,\n);\n\nconst consentStream = client.preferences.streamConsent(callback, onFail);\nconst preferencesStream = client.preferences.streamPreferences(callback, onFail);\n\nconst messagesStream = conversation.stream(callback, onFail);\n\n// NEW\nconst conversationStream = await client.conversations.stream({\n  onError,\n  onValue,\n  onFail\n});\nconst groupStream = await client.conversations.streamGroups({\n  onError,\n  onValue,\n  onFail\n});\nconst dmStream = await client.conversations.streamDms({\n  onError,\n  onValue,\n  onFail\n});\nconst allMessageStream = await client.conversations.streamAllMessages({\n  consentStates,\n  conversationType\n  onError,\n  onValue,\n  onFail\n});\nconst allGroupMessagesStream = await client.conversations.streamAllGroupMessages({\n  consentStates,\n  onError,\n  onValue,\n  onFail,\n});\nconst allDmMessagesStream = await client.conversations.streamAllDmMessages({\n  consentStates,\n  onError,\n  onValue,\n  onFail,\n});\n\nconst consentStream = await client.preferences.streamConsent({\n  onError,\n  onValue,\n  onFail,\n});\nconst preferencesStream = await client.preferences.streamPreferences({\n  onError,\n  onValue,\n  onFail,\n});\n\nconst messagesStream = await conversation.stream({\n  onError,\n  onValue,\n  onFail\n});\n```\n\n#### Streams no longer end on error\n\nWhen a stream error occurs, it's passed to the `onError` callback only. The stream will remain active.\n\n#### Stream types have changed\n\nWhen using the `for await..of` loop, the value will never be `undefined`.\n\n```ts\nconst stream = await client.conversations.streamAllMessages();\n\nfor await (const message of stream) {\n  // message will always be an instance of DecodedMessage\n}\n```\n\n## 3.2.2\n\n### Patch Changes\n\n- 78c6710:\n  - Resolved issue with too many key package API requests\n  - Fixed issue causing users with old installations to sometimes not be added to groups\n  - Fixed a performance bottleneck that affected listing conversations while syncing\n\n## 3.2.1\n\n### Patch Changes\n\n- 41aeaae:\n  - Improved sync and stream performance\n  - Increased max installations to 10\n  - Fixed a known fork issue\n  - Added key package rotation every 30 days\n\n## 3.2.0\n\nThis release introduces several enhancements, including quantum-resistant encryption, improved identity management, and refined read/write rate limits.\n\nIf you've been building on a previous release, this one should be a **drop-in replacement**. Update as soon as possible to take advantage of these enhancements and fixes.\n\n### Support for quantum-resistant encryption\n\nXMTP now supports quantum-resistant encryption, providing enhanced security for message transmission and storage. This upgrade ensures your app is protected against future quantum computer attacks through post-quantum cryptography.\n\nTo learn more, see [Quantum resistance](https://docs.xmtp.org/protocol/security#quantum-resistance).\n\n### Consistent identity ordering\n\nWhen an inbox has multiple associated identities, the `identities` array is now ordered by the `client_timestamp_ns` field, which sorts identities based on when they were added to the inbox, placing the earliest added identity first.\n\nTo learn more, see [Select the identity to display](https://docs.xmtp.org/inboxes/manage-inboxes#select-the-identity-to-display).\n\n### Enhanced rate limits with separate read/write limits\n\nXMTP now provides separate rate limits for read and write operations, offering more granular control over API usage. Read operations are limited to 20,000 requests per 5-minute window, while write operations are limited to 3,000 messages per 5-minute window.\n\nTo learn more, see [Observe rate limits](https://docs.xmtp.org/inboxes/rate-limits).\n\n### Improved history sync\n\nHistory sync has been enhanced with better consent management across installations and improved handling of denied conversations. These changes ensure a more consistent experience when users access XMTP from multiple installations.\n\nTo learn more, see [Enable history sync](https://docs.xmtp.org/inboxes/history-sync).\n\n### Enhanced group chat updates\n\nGroup membership changes now automatically trigger group update codec messages, ensuring all participants receive consistent information about group state changes. This improves the reliability of group chat synchronization across all devices.\n\nTo learn more, see [Manage group chat membership](https://docs.xmtp.org/inboxes/group-permissions#manage-group-chat-membership).\n\n### Performance improvements and bug fixes\n\nThis release includes various performance optimizations throughout the SDK, resulting in faster message processing, improved memory usage, and better overall responsiveness. The release also includes bug fixes that improve the reliability of group chats and address a performance degradation issue that could occur when creating new groups.\n\nTo learn more about optimizing your XMTP implementation, see [Debug your app](https://docs.xmtp.org/inboxes/debug-your-app).\n\n## 3.1.3\n\n### Patch Changes\n\n- 3f4d125:\n  - Refactored `AsyncStream` to be more spec-compliant\n  - Added `onDone` callback to `AsyncStream`\n  - Updated stream methods to use new `onDone` callback to end streams\n\n## 3.1.2\n\n### Patch Changes\n\n- 6b2e3d4: Improved gRPC connection detection\n\n## 3.1.1\n\n### Patch Changes\n\n- e8fbfac: Fixed group syncing on larger groups\n\n## 3.1.0\n\n### Minor Changes\n\n- b72f006: Added `onFail` callback option to stream methods\n\n## 3.0.1\n\n### Patch Changes\n\n- 10bf2d1: Fix forks\n\n## 3.0.0\n\nThis update introduces enhancements for managing installations without a client. It also contains breaking changes related to signature management and consistency across SDKs.\n\n### BREAKING CHANGES\n\n#### Debug information has been moved to `client.debugInformation`\n\nTo better align with our mobile SDKs, debug information helpers are now accessible at the `debugInformation` property of client instances.\n\nUpdate your calls to the following:\n\n- `client.apiStatistics()` => `client.debugInformation.apiStatistics()`\n- `client.apiIdentityStatistics()` => `client.debugInformation.apiIdentityStatistics()`\n- `client.apiAggregateStatistics()` => `client.debugInformation.apiAggregateStatistics()`\n- `client.clearAllStatistics()` => `client.debugInformation.clearAllStatistics()`\n- `client.uploadDebugArchive()` => `client.debugInformation.uploadDebugArchive()`\n\n#### Signatures are now managed through signature requests\n\nThis change only affects developers who are using custom workflows with the `unsafe_*SignatureText` client methods. When using a custom signing workflow, use the new `unsafe_*SignatureRequest` methods.\n\n**Example**\n\n```ts\n// change the recovery identifier\nconst signatureRequest =\n  await this.unsafe_changeRecoveryIdentifierSignatureRequest(newIdentifier);\n\nawait this.unsafe_addSignature(signatureRequest);\nawait this.unsafe_applySignatureRequest(signatureRequest);\n```\n\nAs part of this change, the `SignatureRequestType` export has been replaced with `SignatureRequestHandle`.\n\n### Other changes\n\n- Added `Client.revokeInstallations` static method for revoking installations without a client\n- Added `Client.inboxStateFromInboxIds` static method for getting inbox state without a client\n\n## 2.2.1\n\n### Patch Changes\n\n- e86b0c9: Fixed async iterator exit when calling `end()` on `AsyncStream`\n\n## 2.2.0\n\nThis update introduces several targeted enhancements and clarifications related to managing client builds, network statistics, installations, and group chats.\n\nIf you’ve been building on a previous release, this one should be a **drop-in replacement**. Update as soon as possible to take advantage of these enhancements and fixes.\n\n### Reset network statistics for debugging\n\nA new helper, `clearAllStatistics()`, lets you reset all API/identity/stream network statistics counters.\n\nUse it to get a clean baseline between test runs or free memory on devices where cached gRPC stats grow over time.\n\nTo learn more, see [Network statistics](https://docs.xmtp.org/inboxes/debug-your-app#network-statistics).\n\n### Support installation limits and more targeted revocations\n\nXMTP now enforces up to 5 app installations per inbox ID.\n\nWhen the installation limit is reached, you can revoke an installation to free up a slot.\n\nTo learn more, see [Revoke installations](https://docs.xmtp.org/inboxes/manage-inboxes#revoke-installations).\n\n### Support slightly larger group chats\n\nThe maximum group chat size has been raised from 220 to 250 members.\n\nTo learn more, see [Create a new group chat](https://docs.xmtp.org/inboxes/create-conversations#create-a-new-group-chat).\n\n### Reduced risk of group chat forks\n\nAdditional safeguards have been added to minimize the chance of unintended group chat forks.\n\nTo learn about what group chat forks are and how they can occur, see [MLS Group State Forks: What, Why, How](https://cryspen.com/post/mls-fork-resolution/).\n\n## 2.1.0\n\nThis release delivers enhancements to messaging performance and reliability, as well as a set of developer debugging tools, all focused on making it easier to build with XMTP.\n\nIf you’ve been building on a previous release, this one should be a **drop-in replacement**—just update to the latest version to take advantage of everything below.\n\n### Consent-based listing, streaming, and syncing\n\nBy default, `conversations.list`, `conversations.listGroups`, `conversations.listDms`, `conversations.syncAll`, `conversations.streamAllMessages`, `conversations.streamAllGroupMessages`, and `conversations.streamAllDmMessages` now filter for conversations with a consent state of `ConsentState.Allowed` or `ConsentState.Unknown`.\n\nWe recommend listing `ConsentState.Allowed` conversations only. This ensures that spammy conversations with a consent state of `ConsentState.Unknown` don't degrade the user experience.\n\nTo include all conversations regardless of consent state, you can pass `[ConsentState.Allowed, ConsentState.Unknown, ConsentState.Denied]`.\n\n### Optimistic group chat creation\n\nProvides faster and offline group chat creation and message preparation before adding members.\n\n### Group chat member limit\n\n**A 220-member limit is now enforced for group chats.** This helps prevent errors that oversized groups can cause and ensures consistent behavior across clients.\n\n### Preference sync\n\nPreference syncing enables you to sync the following preference-related information across multiple existing app installations:\n\n- Conversation consent preferences\n- Conversation HMAC keys (for push notifications)\n\n### Developer tooling and debugging\n\nDelivers tools and features for debugging when building with XMTP, including group chat diagnostics, file logging, and network statistics.\n\n### Reliability and performance\n\n- Reliability improvements to message history\n- Reliability improvements to [`streamAll`](https://docs.xmtp.org/inboxes/list-and-stream#stream-all-group-chat-and-dm-messages)\n- Performance improvements to `peerInboxId`\n- [Duplicate DMs](https://docs.xmtp.org/inboxes/push-notifs/understand-push-notifs#dm-stitching-considerations-for-push-notifications) removed from streams\n\n## 2.0.9\n\n### Patch Changes\n\n- 441a029: `AsyncStream` updates\n  - Changed signature of `return` to allow no argument (e.g. `stream.return()`)\n  - Added `end` alias that calls `return` without an argument\n  - Added `AsyncStream` to exports\n\n## 2.0.8\n\n### Patch Changes\n\n- 609b509: Do not stop stream on benign message processing errors\n\n## 2.0.7\n\n### Patch Changes\n\n- 616fdec: Added `null` option to `historySyncUrl` client option to allow disabling of history sync\n\n## 2.0.6\n\n### Patch Changes\n\n- 5bc5a85: Update to the libxmtp stable release version\n\n## 2.0.5\n\n### Patch Changes\n\n- 581d465: Added guard to prevent unexpected conversation types\n\n## 2.0.4\n\n### Patch Changes\n\n- fbce324: Fix welcome processing issue that could lead to incorrect group state\n\n## 2.0.3\n\n### Patch Changes\n\n- b7a3001: Fixed message processing issue that could sometimes fork groups\n\n## 2.0.2\n\n### Patch Changes\n\n- f0a43c4: Lowercase Ethereum addresses on static Client.canMessage calls\n\n## 2.0.1\n\n### Patch Changes\n\n- Removed filter for messages when content is `undefined`\n- Converted all `any` types to `unknown`\n- Added generics for types with `unknown` where applicable\n- Prevented `CodecNotFoundError` from throwing when instantiating `DecodedMessage`\n- Added code comments\n- Updated dependencies\n  - @xmtp/content-type-group-updated@2.0.2\n  - @xmtp/content-type-primitives@2.0.2\n  - @xmtp/content-type-text@2.0.2\n\n## 2.0.0\n\nThis release focuses on new features, stability, and performance.\n\n### Upgrade from 1.2.1 to 2.0.0\n\nUse the information in these release notes to upgrade from `@xmtp/node-sdk` version `1.2.1` to `2.0.0`.\n\n### Breaking changes\n\n#### Refactored `Client.create`\n\nThe database encryption key parameter was removed from the static `Client.create` method. To use a database encryption key, add it to the client options.\n\n`1.x` code:\n\n```typescript\nimport { Client, type ClientOptions, type Signer } from \"@xmtp/node-sdk\";\n\nconst clientOptions: ClientOptions = { ... };\nconst dbEncryptionKey = MY_ENCRYPTION_KEY;\nconst signer: Signer = { ... };\nconst client = await Client.create(signer, dbEncryptionKey, clientOptions);\n```\n\n`2.0.0` code:\n\n```typescript\nimport { Client, type ClientOptions, type Signer } from \"@xmtp/node-sdk\";\n\nconst clientOptions: ClientOptions = {\n  dbEncryptionKey: MY_ENCRYPTION_KEY,\n};\nconst signer: Signer = { ... };\nconst client = await Client.create(signer, clientOptions);\n```\n\n#### Refactored `Client` constructor\n\nThe `Client` constructor now only accepts a single parameter: client options. It's no longer possible to create a client with a signer using the constructor. Use `Client.create` to create a new client with a signer.\n\n`1.x` code:\n\n```typescript\nimport { Client, type Signer } from \"@xmtp/node-sdk\";\n\nconst signer: Signer = { ... };\nconst client = new Client(XMTPClient, signer, codecs);\n```\n\n`2.0.0` code:\n\n```typescript\nimport { Client, type ClientOptions, type Signer } from \"@xmtp/node-sdk\";\n\nconst clientOptions: ClientOptions = {\n  dbEncryptionKey: MY_ENCRYPTION_KEY,\n};\nconst signer: Signer = { ... };\nconst client = await Client.create(signer, clientOptions);\n```\n\n#### Client `identifier` property is now `accountIdentifier`\n\n`1.x` code:\n\n```typescript\nconst identifier = await client.identifier;\n```\n\n`2.0.0` code:\n\n```typescript\nconst identifier = client.accountIdentifier;\n```\n\n#### Removed `requestHistorySync` method from client\n\nDevice sync is being refactored and this method will not be compatible with a future version. Removing it now with these breaking changes so we don't need to bump the major version in the near future.\n\n### New features\n\n#### Added `Client.build` static method\n\nIt's now possible to create a client without a signer using the new `Client.build` method. A signer is not required if an account is already registered on the XMTP network. Keep in mind, some client methods still require a signer.\n\n```typescript\nimport { Client, IdentifierKind, type ClientOptions, type Identifier } from \"@xmtp/node-sdk\";\n\nconst clientOptions: ClientOptions = { ... };\nconst identifier: Identifier = {\n  identifier: \"0x1234567890abcdef1234567890abcdef12345678\",\n  identifierKind: IdentifierKind.Ethereum,\n};\nconst client = await Client.build(identifier, clientOptions);\n```\n\n### Other changes\n\n- Updated `dbPath` client option to allow `null` value\n- Added more custom error types\n- Added `dbEncryptionKey` option to client options\n- Added `options` property to client\n- Added `signer` property to client\n\n## 1.2.1\n\n### Patch Changes\n\n- 6e54926: Exposed message decoding errors in streams\n\n## 1.2.0\n\n### Minor Changes\n\n- d35fbc1:\n  - Added `getHmacKeys` to `Conversation`\n  - Added custom errors\n\n## 1.1.1\n\n### Patch Changes\n\n- 7e7fad4: Fixed error handling in `AsyncStream`\n\n## 1.1.0\n\n### Minor Changes\n\n- 88e6ff6:\n  - Added `unsafe_changeRecoveryIdentifierSignatureText` method to client\n  - Added `changeRecoveryIdentifier` method to client\n  - Added `getKeyPackageStatusesForInstallationIds` method to client\n\n## 1.0.5\n\n### Patch Changes\n\n- 8bd3930: Fixed removing inboxes with invalid key packages from groups\n\n## 1.0.4\n\n### Patch Changes\n\n- 295e046:\n  - Fixed incorrect key package associations\n  - Resolved DM stitching issues for conversations without messages\n\n## 1.0.3\n\n### Patch Changes\n\n- 5845617: Refactored welcome message processing to prevent key package deletion on failure\n\n## 1.0.2\n\n### Patch Changes\n\n- Updated dependencies [340fcf4]\n  - @xmtp/content-type-group-updated@2.0.1\n  - @xmtp/content-type-primitives@2.0.1\n  - @xmtp/content-type-text@2.0.1\n  - @xmtp/proto@3.78.0\n\n## 1.0.1\n\n### Patch Changes\n\n- 607ae92: Fixed `IdentifierKind` enum export in build\n\n## 1.0.0\n\n### Major Changes\n\n- Updated `Signer` type\n- Replaced address parameters with inbox IDs or identifiers\n- Added new methods to use with identifiers\n- Added `pausedForVersion` to `Conversation`\n- Added new `Preferences` class accessible from `client.preferences`\n- Renamed `newGroupByIdentifiers` to `newGroupWithIdentifiers`\n- Renamed `newDmByIdentifier` to `newDmWithIdentifier`\n- Updated exports\n- Improved DM group stitching\n\n## 1.0.0-rc2\n\n- Renamed `newGroupByIdentifiers` to `newGroupWithIdentifiers`\n- Renamed `newDmByIdentifier` to `newDmWithIdentifier`\n\n## 1.0.0-rc1\n\n- Updated `Signer` type\n- Replaced address parameters with inbox IDs or identifiers\n- Added new methods to use with identifiers\n- Added `pausedForVersion` to `Conversation`\n- Updated exports\n\n## 0.0.47\n\n### Patch Changes\n\n- dd1a33a:\n  - Fixed stream errors\n  - Fixed build for later node versions\n\n## 0.0.46\n\n### Patch Changes\n\n- 3cf6dd9:\n  - Exposed all client signature methods\n  - Refactored client signature methods to return `undefined` instead of `null`\n  - Added guard to `Client.addAccount` to prevent automatic reassignment of inboxes\n  - Removed `allowedStates`, `conversationType`, and `includeSyncGroups` from `ListConversationsOptions`\n  - Added `contentTypes` option to `ListMessagesOptions`\n  - Added more exports from the bindings\n  - Added `Group` and `Dm` classes\n  - Refactored some functions to use the new `Group` and `Dm` classes\n\n## 0.0.45\n\n### Patch Changes\n\n- 5221111:\n  - Added new methods to create groups by inbox ID\n  - Added consent states option to `syncAllConversations`\n  - Updated list conversations options to include `consentStates` and `includeDuplicateDms`\n  - Removed automatic message filtering from DM groups\n  - Added disappearing messages methods to conversations\n  - Added optional `listMessage` property to `Conversation`\n  - Added consent streaming\n  - Added preferences streaming\n  - Added `Client.version` static getter\n\n## 0.0.44\n\n### Patch Changes\n\n- c63d8af: Make `getBlockNumber` optional for SCW signers\n\n## 0.0.43\n\n### Patch Changes\n\n- 68b0200: Refactored `Signer` type\n\n## 0.0.42\n\n### Patch Changes\n\n- ec5cd41:\n  - Removed group pinned frame URL metadata\n  - Fixed DB locking issues\n\n## 0.0.41\n\n### Patch Changes\n\n- 931c4a4: Updated `createDm` to return an existing DM group, if it exists\n\n## 0.0.40\n\n### Patch Changes\n\n- 25e0e15: Replaced some `??` with `||` to ensure string values are not empty\n\n## 0.0.39\n\n### Patch Changes\n\n- 626d420: Fixed DM group syncing across installations\n\n## 0.0.38\n\n### Patch Changes\n\n- cf6fbc0: Added default history sync URL to client with option to override\n\n## 0.0.37\n\n### Patch Changes\n\n- d09ec27:\n  - Added support for revoking specific installations\n  - Refactored `list`, `listGroups`, and `listDms` to be synchronous\n\n## 0.0.36\n\n### Patch Changes\n\n- d84932a: Added support for HMAC keys\n\n## 0.0.35\n\n### Patch Changes\n\n- 3a1e53b: Enabled group permissions updates\n  - Added `updatePermission` method to `Conversation`\n  - Exported `MetadataField` type\n\n## 0.0.34\n\n### Patch Changes\n\n- a35afb8: Upgraded bindings, refactored some methods to be async\n\n## 0.0.33\n\n### Patch Changes\n\n- 8120a39: Added support for custom permissions policy\n\n## 0.0.32\n\n### Patch Changes\n\n- 1777a23: Dropped support for CommonJS\n- Updated dependencies [1777a23]\n  - @xmtp/content-type-group-updated@2.0.0\n  - @xmtp/content-type-primitives@2.0.0\n  - @xmtp/content-type-text@2.0.0\n\n## 0.0.31\n\n### Patch Changes\n\n- 9c625ad: Do not create local DB when calling the `Client.canMessage` static method\n\n## 0.0.30\n\n### Patch Changes\n\n- 7338e0e:\n  - Removed authorization instance methods from client\n  - Added static authorization methods to client\n  - Upgraded to latest node bindings\n\n## 0.0.29\n\n### Patch Changes\n\n- f1b93bb: Upgraded to latest node bindings\n\n## 0.0.28\n\n### Patch Changes\n\n- a1f27b8:\n  - Added `isAddressAuthorized` to `Client`\n  - Added `isInstallationAuthorized` to `Client`\n\n## 0.0.27\n\n### Patch Changes\n\n- 9324310:\n  - Added `installationIdBytes` to `Client`\n  - Refactored `Client.verifySignedWithInstallationKey` to return a `boolean`\n  - Changed `Client.verifySignedWithPublicKey` to a static method\n\n## 0.0.26\n\n### Patch Changes\n\n- 7661f78:\n  - Added `syncAll` method to `Conversations`\n  - Added `signWithInstallationKey`, `verifySignedWithInstallationKey`, and `verifySignedWithPublicKey` to `Client`\n\n## 0.0.25\n\n### Patch Changes\n\n- 63e5276: Updated exports\n- Updated dependencies [63e5276]\n  - @xmtp/content-type-group-updated@1.0.1\n  - @xmtp/content-type-primitives@1.0.3\n  - @xmtp/content-type-text@1.0.1\n  - @xmtp/proto@3.72.0\n\n## 0.0.24\n\n### Patch Changes\n\n- a1a16a0:\n  - Added `Signer` interface\n  - Refactored `Client.create` to accept a `Signer` instead of account address\n  - Refactored client creation to automatically register and identity\n  - Added `disableAutoRegister` to `ClientOptions` to allow disabling of client registration after creation\n  - Removed direct access to all signature functions\n  - Added `Client.register` method for registering a client\n  - Added `Client.addAccount` method for adding another account to an installation\n  - Added `Client.removeAccount` method for removing an account from an installation\n  - Added `Client.revokeInstallations` method for revoking all other installations\n  - Added static `Client.canMessage` for checking if an address is on the network without a client\n  - Added environment to DB path\n\n## 0.0.23\n\n### Patch Changes\n\n- 31ca82d:\n  - Updated return type of `Client.canMessage` from Record to Map\n  - Added requirement of encryption key when creating a client\n  - Updated logging options\n  - Added smart contract wallet support\n  - Updated exports\n\n## 0.0.22\n\n### Patch Changes\n\n- 5a41542:\n  - Upgraded node bindings\n  - Refactored code with updated type exports\n  - Fixed streaming issues when a stream error occurs\n\n## 0.0.21\n\n### Patch Changes\n\n- 764d6c0: Refactor streams for better error handling\n\n## 0.0.20\n\n### Patch Changes\n\n- 981bcf4:\n  - Added 1:1 messages\n  - Added stream errors to the stream's async iterator values\n  - Added consent state methods to client and conversation\n  - Added signature methods for adding/revoke wallets and revoking installations\n  - Added `getLatestInboxState` to client\n  - Added inbox ID helpers\n\n## 0.0.19\n\n### Patch Changes\n\n- 87457d6:\n  - Allowed for `undefined` content type and content in messages\n  - Filtered out messages without content when calling `Conversation.messages`\n  - Added generic typing for message content to `DecodedMessage` class and `Conversations.findMessageById`\n  - Replaced temporary group updated codec with official content type\n\n## 0.0.18\n\n### Patch Changes\n\n- cdc9212: Update `@xmtp/node-bindings` to 0.0.14\n\n## 0.0.17\n\n### Patch Changes\n\n- 5f02a9b:\n  - Upgraded node bindings\n  - Added `inboxStateFromInboxIds` method to client\n  - Added logging option when creating a client\n\n## 0.0.16\n\n### Patch Changes\n\n- b8f97ba: Upgrade to latest node bindings\n\n### BREAKING CHANGE\n\nThis is a breaking change as some of the APIs have changed.\n\n- `Client.signatureText` is now an async function\n- `Client.addScwSignature` has been removed\n- `Client.addEcdsaSignature` has been renamed to `Client.addSignature`\n- `Conversation.members` is now an async function\n\n## 0.0.15\n\n### Patch Changes\n\n- b8d9b36:\n  - Upgraded to latest MLS node bindings\n  - Added `inboxState` to Client\n\n## 0.0.14\n\n### Patch Changes\n\n- 93f0fb9: Upgraded to latest MLS node bindings\n\n## 0.0.13\n\n### Patch Changes\n\n- 4c0340b:\n  - Upgraded `@xmtp/proto`\n  - Upgraded MLS bindings\n  - Added optimistic sending\n  - Added `pinnedFrameUrl` metadata to conversations\n  - Added `policySet` to conversation permissions\n\n## 0.0.12\n\n### Patch Changes\n\n- 4ec046b:\n  - Added conversation descriptions\n  - Fixed DB locking issues\n  - Fixed invalid policy error\n  - Removed Admin status from group creators (Super Admin only)\n  - Made content type optional when sending messages\n\n## 0.0.11\n\n### Patch Changes\n\n- c506faf:\n  - Upgraded to latest MLS node bindings\n  - Added `requestHistorySync` and `getInboxIdByAddress` to `Client`\n  - Renamed `get` to `getConversationById` in `Conversations`\n  - Added `getMessageById` to `Conversations`\n\n## 0.0.10\n\n### Patch Changes\n\n- b5db898: Upgrade node bindings for bug fixes\n\n## 0.0.9\n\n### Patch Changes\n\n- a419052:\n  - Upgrade to latest node bindings\n  - Rename addErc1271Signature to addScwSignature\n  - Add more options when creating a group with client.conversations.newConversation\n  - Add getter and setter for group image URL\n  - Add getter for group permissions\n  - Add more tests\n  - Add GroupPermissions to exports\n\n## 0.0.8\n\n### Patch Changes\n\n- b87672a:\n  - Add production environment\n  - Allow for all environments when creating a client\n  - Remove dependency on `@xmtp/xmtp-js` for content types and their primitives\n\n## 0.0.7\n\n### Patch Changes\n\n- 8a9b624:\n  - Add streaming callbacks\n  - Add `get` method to `Conversations` for easy access to conversations that are created, listed, or streamed during a client session\n\n## 0.0.6\n\n### Patch Changes\n\n- 6dd6a0e: Add `streamAllMessages` to Conversations\n\n## 0.0.5\n\n### Patch Changes\n\n- ff6c304: Use correct inbox ID for all environments\n\n## 0.0.4\n\n### Patch Changes\n\n- 632e6a3: Add conversation reference to messages\n\n## 0.0.3\n\n### Patch Changes\n\n- 3006d8b: Upgrade MLS node bindings, add admin features\n\n## 0.0.2\n\n### Patch Changes\n\n- ff5fcd7: Fix package.json issues\n\n## 0.0.1\n\nInitial release\n",
      "size_bytes": 30740
    },
    "apps/xmtp.chat/src/components/App/ConnectorSelect.tsx": {
      "content": "import { Grid } from \"@mantine/core\";\nimport { AccountCard } from \"@/components/App/AccountCard\";\nimport {\n  useConnectWallet,\n  type ConnectorString,\n} from \"@/hooks/useConnectWallet\";\nimport { useSettings } from \"@/hooks/useSettings\";\nimport { CoinbaseWallet } from \"@/icons/CoinbaseWallet\";\nimport { InjectedWallet } from \"@/icons/InjectedWallet\";\nimport { MetamaskWallet } from \"@/icons/MetamaskWallet\";\nimport { WalletConnectWallet } from \"@/icons/WalletConnectWallet\";\nimport classes from \"./ConnectorSelect.module.css\";\n\nexport const ConnectorSelect: React.FC = () => {\n  const { isConnected, loading } = useConnectWallet();\n  const { connector, setConnector, ephemeralAccountEnabled, useSCW } =\n    useSettings();\n\n  const handleWalletConnect = (connector: ConnectorString) => () => {\n    setConnector(connector);\n  };\n\n  const isDisabled = isConnected || loading || ephemeralAccountEnabled;\n\n  return (\n    <Grid gutter={1} className={classes.root}>\n      <Grid.Col span={{ base: 12, md: 6 }}>\n        <AccountCard\n          selected={connector === \"Injected\"}\n          disabled={isDisabled}\n          icon={<InjectedWallet />}\n          label=\"Browser injected\"\n          onClick={handleWalletConnect(\"Injected\")}\n        />\n      </Grid.Col>\n      <Grid.Col span={{ base: 12, md: 6 }}>\n        <AccountCard\n          selected={connector === \"Coinbase Wallet\"}\n          disabled={isDisabled}\n          icon={<CoinbaseWallet />}\n          label=\"Coinbase Wallet\"\n          onClick={handleWalletConnect(\"Coinbase Wallet\")}\n        />\n      </Grid.Col>\n      <Grid.Col span={{ base: 12, md: 6 }}>\n        <AccountCard\n          selected={connector === \"MetaMask\"}\n          disabled={isDisabled || useSCW}\n          icon={<MetamaskWallet />}\n          label=\"MetaMask\"\n          onClick={handleWalletConnect(\"MetaMask\")}\n        />\n      </Grid.Col>\n      <Grid.Col span={{ base: 12, md: 6 }}>\n        <AccountCard\n          selected={connector === \"WalletConnect\"}\n          disabled={isDisabled}\n          icon={<WalletConnectWallet />}\n          label=\"WalletConnect\"\n          onClick={handleWalletConnect(\"WalletConnect\")}\n        />\n      </Grid.Col>\n    </Grid>\n  );\n};\n",
      "size_bytes": 2186
    },
    "apps/xmtp.chat/src/helpers/date.ts": {
      "content": "export const nsToDate = (ns: bigint): Date => {\n  return new Date(Number(ns / 1_000_000n));\n};\n\nexport const dateToNs = (date: Date): bigint => {\n  const ms = date.getTime();\n  if (Number.isNaN(ms)) {\n    throw new Error(\"Invalid date\");\n  }\n  return BigInt(ms) * 1_000_000n;\n};\n",
      "size_bytes": 279
    },
    "sdks/browser-sdk/src/Group.ts": {
      "content": "import type {\n  Identifier,\n  MetadataField,\n  PermissionPolicy,\n  PermissionUpdateType,\n} from \"@xmtp/wasm-bindings\";\nimport type { Client } from \"@/Client\";\nimport { Conversation } from \"@/Conversation\";\nimport type { SafeConversation } from \"@/utils/conversions\";\n\n/**\n * Represents a group conversation between multiple inboxes\n *\n * This class is not intended to be initialized directly.\n */\nexport class Group<ContentTypes = unknown> extends Conversation<ContentTypes> {\n  #admins: SafeConversation[\"admins\"] = [];\n  #client: Client<ContentTypes>;\n  #description?: SafeConversation[\"description\"];\n  #id: string;\n  #imageUrl?: SafeConversation[\"imageUrl\"];\n  #name?: SafeConversation[\"name\"];\n  #superAdmins: SafeConversation[\"superAdmins\"] = [];\n\n  #syncData(data?: SafeConversation) {\n    this.#name = data?.name ?? \"\";\n    this.#imageUrl = data?.imageUrl ?? \"\";\n    this.#description = data?.description ?? \"\";\n    this.#admins = data?.admins ?? [];\n    this.#superAdmins = data?.superAdmins ?? [];\n  }\n\n  /**\n   * Creates a new group conversation instance\n   *\n   * @param client - The client instance managing this group conversation\n   * @param id - Identifier for the group conversation\n   * @param data - Optional conversation data to initialize with\n   */\n  constructor(\n    client: Client<ContentTypes>,\n    id: string,\n    data?: SafeConversation,\n  ) {\n    super(client, id, data);\n    this.#client = client;\n    this.#id = id;\n    this.#syncData(data);\n  }\n\n  /**\n   * Synchronizes the group's data with the network\n   *\n   * @returns Updated group data\n   */\n  async sync() {\n    const data = await super.sync();\n    this.#syncData(data);\n    return data;\n  }\n\n  /**\n   * The name of the group\n   */\n  get name() {\n    return this.#name;\n  }\n\n  /**\n   * Updates the group's name\n   *\n   * @param name The new name for the group\n   */\n  async updateName(name: string) {\n    await this.#client.sendMessage(\"group.updateName\", {\n      id: this.#id,\n      name,\n    });\n    this.#name = name;\n  }\n\n  /**\n   * The image URL of the group\n   */\n  get imageUrl() {\n    return this.#imageUrl;\n  }\n\n  /**\n   * Updates the group's image URL\n   *\n   * @param imageUrl The new image URL for the group\n   */\n  async updateImageUrl(imageUrl: string) {\n    await this.#client.sendMessage(\"group.updateImageUrl\", {\n      id: this.#id,\n      imageUrl,\n    });\n    this.#imageUrl = imageUrl;\n  }\n\n  /**\n   * The description of the group\n   */\n  get description() {\n    return this.#description;\n  }\n\n  /**\n   * Updates the group's description\n   *\n   * @param description The new description for the group\n   */\n  async updateDescription(description: string) {\n    await this.#client.sendMessage(\"group.updateDescription\", {\n      id: this.#id,\n      description,\n    });\n    this.#description = description;\n  }\n\n  /**\n   * The list of admins of the group by inbox ID\n   */\n  get admins() {\n    return this.#admins;\n  }\n\n  /**\n   * The list of super admins of the group by inbox ID\n   */\n  get superAdmins() {\n    return this.#superAdmins;\n  }\n\n  /**\n   * Fetches and updates the list of group admins from the server\n   *\n   * @returns Array of admin inbox IDs\n   */\n  async listAdmins() {\n    const admins = await this.#client.sendMessage(\"group.listAdmins\", {\n      id: this.#id,\n    });\n    this.#admins = admins;\n    return admins;\n  }\n\n  /**\n   * Fetches and updates the list of group super admins from the server\n   *\n   * @returns Array of super admin inbox IDs\n   */\n  async listSuperAdmins() {\n    const superAdmins = await this.#client.sendMessage(\n      \"group.listSuperAdmins\",\n      {\n        id: this.#id,\n      },\n    );\n    this.#superAdmins = superAdmins;\n    return superAdmins;\n  }\n\n  /**\n   * Retrieves the group's permissions\n   *\n   * @returns The group's permissions\n   */\n  async permissions() {\n    return this.#client.sendMessage(\"group.permissions\", {\n      id: this.#id,\n    });\n  }\n\n  /**\n   * Updates a specific permission policy for the group\n   *\n   * @param permissionType The type of permission to update\n   * @param policy The new permission policy\n   * @param metadataField Optional metadata field for the permission\n   */\n  async updatePermission(\n    permissionType: PermissionUpdateType,\n    policy: PermissionPolicy,\n    metadataField?: MetadataField,\n  ) {\n    return this.#client.sendMessage(\"group.updatePermission\", {\n      id: this.#id,\n      permissionType,\n      policy,\n      metadataField,\n    });\n  }\n\n  /**\n   * Checks if an inbox is an admin of the group\n   *\n   * @param inboxId The inbox ID to check\n   * @returns Boolean indicating if the inbox is an admin\n   */\n  async isAdmin(inboxId: string) {\n    const admins = await this.listAdmins();\n    return admins.includes(inboxId);\n  }\n\n  /**\n   * Checks if an inbox is a super admin of the group\n   *\n   * @param inboxId The inbox ID to check\n   * @returns Boolean indicating if the inbox is a super admin\n   */\n  async isSuperAdmin(inboxId: string) {\n    const superAdmins = await this.listSuperAdmins();\n    return superAdmins.includes(inboxId);\n  }\n\n  /**\n   * Adds members to the group using identifiers\n   *\n   * @param identifiers Array of member identifiers to add\n   */\n  async addMembersByIdentifiers(identifiers: Identifier[]) {\n    return this.#client.sendMessage(\"group.addMembersByIdentifiers\", {\n      id: this.#id,\n      identifiers,\n    });\n  }\n\n  /**\n   * Adds members to the group using inbox IDs\n   *\n   * @param inboxIds Array of inbox IDs to add\n   */\n  async addMembers(inboxIds: string[]) {\n    return this.#client.sendMessage(\"group.addMembers\", {\n      id: this.#id,\n      inboxIds,\n    });\n  }\n\n  /**\n   * Removes members from the group using identifiers\n   *\n   * @param identifiers Array of member identifiers to remove\n   */\n  async removeMembersByIdentifiers(identifiers: Identifier[]) {\n    return this.#client.sendMessage(\"group.removeMembersByIdentifiers\", {\n      id: this.#id,\n      identifiers,\n    });\n  }\n\n  /**\n   * Removes members from the group using inbox IDs\n   *\n   * @param inboxIds Array of inbox IDs to remove\n   */\n  async removeMembers(inboxIds: string[]) {\n    return this.#client.sendMessage(\"group.removeMembers\", {\n      id: this.#id,\n      inboxIds,\n    });\n  }\n\n  /**\n   * Promotes a group member to admin status\n   *\n   * @param inboxId The inbox ID of the member to promote\n   */\n  async addAdmin(inboxId: string) {\n    return this.#client.sendMessage(\"group.addAdmin\", {\n      id: this.#id,\n      inboxId,\n    });\n  }\n\n  /**\n   * Removes admin status from a group member\n   *\n   * @param inboxId The inbox ID of the admin to demote\n   */\n  async removeAdmin(inboxId: string) {\n    return this.#client.sendMessage(\"group.removeAdmin\", {\n      id: this.#id,\n      inboxId,\n    });\n  }\n\n  /**\n   * Promotes a group member to super admin status\n   *\n   * @param inboxId The inbox ID of the member to promote\n   */\n  async addSuperAdmin(inboxId: string) {\n    return this.#client.sendMessage(\"group.addSuperAdmin\", {\n      id: this.#id,\n      inboxId,\n    });\n  }\n\n  /**\n   * Removes super admin status from a group member\n   *\n   * @param inboxId The inbox ID of the super admin to demote\n   */\n  async removeSuperAdmin(inboxId: string) {\n    return this.#client.sendMessage(\"group.removeSuperAdmin\", {\n      id: this.#id,\n      inboxId,\n    });\n  }\n}\n",
      "size_bytes": 7311
    },
    "sdks/node-sdk/src/index.ts": {
      "content": "export type {\n  ClientOptions,\n  OtherOptions,\n  NetworkOptions,\n  StorageOptions,\n  XmtpEnv,\n} from \"./types\";\nexport { ApiUrls, HistorySyncUrls } from \"./constants\";\nexport { Client } from \"./Client\";\nexport type { ExtractCodecContentTypes } from \"./Client\";\nexport { Conversation } from \"./Conversation\";\nexport { Conversations } from \"./Conversations\";\nexport { Dm } from \"./Dm\";\nexport { Group } from \"./Group\";\nexport type { PreferenceUpdate } from \"./Preferences\";\nexport { DecodedMessage } from \"./DecodedMessage\";\nexport type { AsyncStreamProxy } from \"./AsyncStream\";\nexport type {\n  Consent,\n  ContentType,\n  ContentTypeId,\n  ConversationListItem,\n  CreateDmOptions,\n  CreateGroupOptions,\n  EncodedContent,\n  HmacKey,\n  Identifier,\n  InboxState,\n  Installation,\n  KeyPackageStatus,\n  Lifetime,\n  ListConversationsOptions,\n  ListMessagesOptions,\n  LogOptions,\n  Message,\n  MessageDisappearingSettings,\n  PermissionPolicySet,\n} from \"@xmtp/node-bindings\";\nexport {\n  ConsentEntityType,\n  ConsentState,\n  ConversationType,\n  DeliveryStatus,\n  GroupMember,\n  GroupMembershipState,\n  GroupMessageKind,\n  GroupMetadata,\n  GroupPermissions,\n  GroupPermissionsOptions,\n  IdentifierKind,\n  LogLevel,\n  MetadataField,\n  PermissionLevel,\n  PermissionPolicy,\n  PermissionUpdateType,\n  SignatureRequestHandle,\n  SortDirection,\n} from \"@xmtp/node-bindings\";\nexport { generateInboxId, getInboxIdForIdentifier } from \"./utils/inboxId\";\nexport type { Signer } from \"./utils/signer\";\nexport * from \"./utils/errors\";\nexport * from \"./utils/validation\";\nexport type * from \"./utils/streams\";\n",
      "size_bytes": 1583
    },
    "CODE_OF_CONDUCT.md": {
      "content": "# XMTP code of conduct\n\nThis code of conduct applies within all XMTP community spaces, virtual and physical, and also applies when an individual is officially representing the XMTP community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.\n\n## Our pledge\n\nWe as members pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.\n\n## Our conduct\n\nExamples of behaviors that contribute to a positive environment for our community include:\n\n- Demonstrating empathy and kindness toward other people\n- Being collaborative and respectful of differing opinions, viewpoints, and experiences. A great protocol is built by many contributors learning and working together.\n- Being bold yet intentional when presenting ideas. We are here to help ensure the world has access to secure and private communication, while also acknowledging that building successful protocols and ecosystems requires the application of logic and evidence.\n- Giving and gracefully accepting constructive feedback\n- Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\n- Focusing on what is best not just for us as individuals but for the overall community, and the people depending on XMTP for communication.\n\nExamples of unacceptable behavior include:\n\n- The use of sexualized language or imagery, and sexual attention or advances of any kind\n- Hate speech, trolling, shitposting, flaming, spamming, unsolicited advertising, baiting, insulting or derogatory comments, and personal or political attacks\n- Public or private harassment\n- Publishing others’ private information, such as a physical or email address, without their explicit permission\n\n## Moderation\n\nCommunity moderators are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.\n\nCommunity moderators have the right and responsibility to remove, edit, or reject comments, commits, code, issues, and other contributions that are not aligned to this code of conduct and will communicate reasons for moderation decisions when appropriate.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior can be reported to the community moderators responsible for enforcement at [conduct@xmtp.org](mailto:conduct@xmtp.org). All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. All community moderators are obligated to respect the privacy and security of the reporter of any incident.\n\nCommunity moderators who do not follow or enforce the code of conduct in good faith may face temporary or permanent repercussions as determined by other community moderators.\n\n## Attribution\n\nThe XMTP code of conduct is adapted from the Contributor Covenant, [version 2.1](https://www.contributor-covenant.org/version/2/1/code_of_conduct.html) and [version 1.4](https://www.contributor-covenant.org/version/1/4/code-of-conduct.html).\n",
      "size_bytes": 3683
    },
    "content-types/content-type-group-updated/CHANGELOG.md": {
      "content": "# @xmtp/content-type-group-updated\n\n## 2.0.2\n\n### Patch Changes\n\n- Updated dependencies [779fd0c]\n  - @xmtp/content-type-primitives@2.0.2\n\n## 2.0.1\n\n### Patch Changes\n\n- Updated dependencies [340fcf4]\n  - @xmtp/content-type-primitives@2.0.1\n  - @xmtp/proto@3.78.0\n\n## 2.0.0\n\n### Major Changes\n\n- 1777a23: Dropped support for CommonJS\n\n### Patch Changes\n\n- Updated dependencies [1777a23]\n  - @xmtp/content-type-primitives@2.0.0\n\n## 1.0.1\n\n### Patch Changes\n\n- Updated dependencies [63e5276]\n  - @xmtp/content-type-primitives@1.0.3\n\n## 1.0.0\n\nInitial release\n",
      "size_bytes": 557
    },
    "content-types/content-type-reply/src/Reply.test.ts": {
      "content": "import {\n  AttachmentCodec,\n  ContentTypeAttachment,\n  type Attachment,\n} from \"@xmtp/content-type-remote-attachment\";\nimport { ContentTypeText } from \"@xmtp/content-type-text\";\nimport { Client, IdentifierKind, type Signer } from \"@xmtp/node-sdk\";\nimport { createWalletClient, http, toBytes } from \"viem\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { sepolia } from \"viem/chains\";\nimport { ContentTypeReply, ReplyCodec, type Reply } from \"./Reply\";\n\nexport const createSigner = (): Signer => {\n  const account = privateKeyToAccount(generatePrivateKey());\n  const wallet = createWalletClient({\n    account,\n    chain: sepolia,\n    transport: http(),\n  });\n  return {\n    type: \"EOA\",\n    getIdentifier: () => ({\n      identifierKind: IdentifierKind.Ethereum,\n      identifier: account.address.toLowerCase(),\n    }),\n    signMessage: async (message: string) => {\n      const signature = await wallet.signMessage({\n        message,\n      });\n      return toBytes(signature);\n    },\n  };\n};\n\ndescribe(\"ReplyContentType\", () => {\n  it(\"has the right content type\", () => {\n    expect(ContentTypeReply.authorityId).toBe(\"xmtp.org\");\n    expect(ContentTypeReply.typeId).toBe(\"reply\");\n    expect(ContentTypeReply.versionMajor).toBe(1);\n    expect(ContentTypeReply.versionMinor).toBe(0);\n  });\n\n  it(\"can send a text reply\", async () => {\n    const signer1 = createSigner();\n    const client1 = await Client.create(signer1, {\n      codecs: [new ReplyCodec()],\n      env: \"local\",\n    });\n\n    const signer2 = createSigner();\n    const client2 = await Client.create(signer2, {\n      codecs: [new ReplyCodec()],\n      env: \"local\",\n    });\n\n    const dm = await client1.conversations.newDm(client2.inboxId);\n\n    const originalMessage = await dm.send(\"test\");\n\n    const reply: Reply = {\n      content: \"LGTM\",\n      contentType: ContentTypeText,\n      reference: originalMessage,\n    };\n\n    await dm.send(reply, ContentTypeReply);\n\n    await client2.conversations.sync();\n    const dms = client2.conversations.listDms();\n\n    expect(dms.length).toBe(1);\n\n    await dms[0].sync();\n    const messages = await dms[0].messages();\n    expect(messages.length).toBe(3);\n\n    const replyMessage = messages[2];\n    const messageContent = replyMessage.content as Reply;\n    expect(messageContent.content).toBe(\"LGTM\");\n    expect(messageContent.reference).toBe(originalMessage);\n  });\n\n  it(\"can send an attachment reply\", async () => {\n    const signer1 = createSigner();\n    const client1 = await Client.create(signer1, {\n      codecs: [new ReplyCodec(), new AttachmentCodec()],\n      env: \"local\",\n    });\n\n    const signer2 = createSigner();\n    const client2 = await Client.create(signer2, {\n      codecs: [new ReplyCodec(), new AttachmentCodec()],\n      env: \"local\",\n    });\n\n    const dm = await client1.conversations.newDm(client2.inboxId);\n\n    const originalMessage = await dm.send(\"test\");\n\n    const attachment: Attachment = {\n      filename: \"test.png\",\n      mimeType: \"image/png\",\n      data: Uint8Array.from([5, 4, 3, 2, 1]),\n    };\n\n    const reply: Reply = {\n      content: attachment,\n      contentType: ContentTypeAttachment,\n      reference: originalMessage,\n    };\n\n    await dm.send(reply, ContentTypeReply);\n\n    await client2.conversations.sync();\n    const dms = client2.conversations.listDms();\n\n    expect(dms.length).toBe(1);\n\n    await dms[0].sync();\n    const messages = await dms[0].messages();\n    expect(messages.length).toBe(3);\n\n    const replyMessage = messages[2];\n    const messageContent = replyMessage.content as Reply;\n    expect(ContentTypeAttachment.sameAs(messageContent.contentType)).toBe(true);\n    expect(messageContent.content).toEqual({\n      filename: \"test.png\",\n      mimeType: \"image/png\",\n      data: Uint8Array.from([5, 4, 3, 2, 1]),\n    });\n    expect(messageContent.reference).toBe(originalMessage);\n  });\n\n  it(\"has a proper shouldPush value\", () => {\n    const codec = new ReplyCodec();\n    expect(codec.shouldPush()).toBe(true);\n  });\n});\n",
      "size_bytes": 4020
    },
    "content-types/content-type-text/src/index.ts": {
      "content": "export * from \"./Text\";\n",
      "size_bytes": 24
    },
    "sdks/node-sdk/test/DebugInformation.test.ts": {
      "content": "import { describe, expect, it } from \"vitest\";\nimport {\n  createRegisteredClient,\n  createSigner,\n  createUser,\n} from \"@test/helpers\";\n\ndescribe(\"DebugInformation\", () => {\n  it(\"should return network API statistics\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n\n    const apiStats = client.debugInformation.apiStatistics();\n    expect(apiStats.fetchKeyPackage).toBe(0n);\n    expect(apiStats.queryGroupMessages).toBe(0n);\n    expect(apiStats.queryWelcomeMessages).toBe(0n);\n    expect(apiStats.sendGroupMessages).toBe(0n);\n    expect(apiStats.sendWelcomeMessages).toBe(0n);\n    expect(apiStats.subscribeMessages).toBe(0n);\n    expect(apiStats.subscribeWelcomes).toBe(0n);\n    expect(apiStats.uploadKeyPackage).toBe(1n);\n\n    const apiIdentityStats = client.debugInformation.apiIdentityStatistics();\n    expect(apiIdentityStats.getIdentityUpdatesV2).toBe(2n);\n    expect(apiIdentityStats.getInboxIds).toBe(1n);\n    expect(apiIdentityStats.publishIdentityUpdate).toBe(1n);\n    expect(apiIdentityStats.verifySmartContractWalletSignature).toBe(0n);\n\n    client.debugInformation.clearAllStatistics();\n\n    const apiStats2 = client.debugInformation.apiStatistics();\n    expect(apiStats2.uploadKeyPackage).toBe(0n);\n    expect(apiStats2.fetchKeyPackage).toBe(0n);\n    expect(apiStats2.sendGroupMessages).toBe(0n);\n    expect(apiStats2.sendWelcomeMessages).toBe(0n);\n    expect(apiStats2.queryGroupMessages).toBe(0n);\n    expect(apiStats2.queryWelcomeMessages).toBe(0n);\n    expect(apiStats2.subscribeMessages).toBe(0n);\n\n    const apiIdentityStats2 = client.debugInformation.apiIdentityStatistics();\n    expect(apiIdentityStats2.getIdentityUpdatesV2).toBe(0n);\n    expect(apiIdentityStats2.getInboxIds).toBe(0n);\n    expect(apiIdentityStats2.publishIdentityUpdate).toBe(0n);\n    expect(apiIdentityStats2.verifySmartContractWalletSignature).toBe(0n);\n\n    const apiAggregateStats = client.debugInformation.apiAggregateStatistics();\n    expect(apiAggregateStats).toBeDefined();\n  });\n\n  it(\"should upload a debug archive\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n\n    const result = await client.debugInformation.uploadDebugArchive();\n    expect(result).toBeDefined();\n  });\n});\n",
      "size_bytes": 2369
    },
    "apps/xmtp.chat-api-service/src/globals.d.ts": {
      "content": "declare global {\n  namespace NodeJS {\n    interface ProcessEnv {\n      readonly PINATA_JWT: string;\n      readonly PINATA_GATEWAY: string;\n      readonly PINATA_GROUP_ID: string;\n      readonly WEB3BIO_API_KEY: string;\n    }\n  }\n}\n",
      "size_bytes": 231
    },
    "apps/xmtp.chat/src/icons/IconCopy.tsx": {
      "content": "export type IconCopyProps = {\n  size?: number;\n};\n\nexport const IconCopy: React.FC<IconCopyProps> = ({ size = 16 }) => {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width={size}\n      height={size}\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"1.5\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\">\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z\" />\n      <path d=\"M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1\" />\n    </svg>\n  );\n};\n",
      "size_bytes": 742
    },
    "sdks/node-sdk/src/utils/streams.ts": {
      "content": "import { isPromise } from \"node:util/types\";\nimport type { StreamCloser } from \"@xmtp/node-bindings\";\nimport { AsyncStream, createAsyncStreamProxy } from \"@/AsyncStream\";\nimport { StreamFailedError, StreamInvalidRetryAttemptsError } from \"./errors\";\n\nconst wait = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\n\nexport const DEFAULT_RETRY_DELAY = 10000; // milliseconds\nexport const DEFAULT_RETRY_ATTEMPTS = 6;\n\nexport type StreamOptions<T = unknown, V = T> = {\n  /**\n   * Called when the stream ends\n   */\n  onEnd?: () => void;\n  /**\n   * Called when a stream error occurs\n   */\n  onError?: (error: Error) => void;\n  /**\n   * Called when the stream fails\n   */\n  onFail?: () => void;\n  /**\n   * Called when the stream is restarted\n   */\n  onRestart?: () => void;\n  /**\n   * Called when the stream is retried\n   */\n  onRetry?: (attempts: number, maxAttempts: number) => void;\n  /**\n   * Called when a value is emitted from the stream\n   */\n  onValue?: (value: V) => void;\n  /**\n   * The number of times to retry the stream\n   * (default: 6)\n   */\n  retryAttempts?: number;\n  /**\n   * The delay between retries (in milliseconds)\n   * (default: 10000)\n   */\n  retryDelay?: number;\n  /**\n   * Whether to retry the stream if it fails\n   * (default: true)\n   */\n  retryOnFail?: boolean;\n};\n\nexport type StreamCallback<T = unknown> = (\n  error: Error | null,\n  value: T | undefined,\n) => void;\n\nexport type StreamFunction<T = unknown> = (\n  callback: StreamCallback<T>,\n  onFail: () => void,\n) => Promise<StreamCloser>;\n\nexport type StreamValueMutator<T = unknown, V = T> = (\n  value: T,\n) => V | Promise<V>;\n\n/**\n * Creates a stream from a stream function\n *\n * If the stream fails, an attempt will be made to restart it.\n *\n * This function is not intended to be used directly.\n *\n * @param streamFunction - The stream function to create a stream from\n * @param streamValueMutator - An optional function to mutate the value emitted from the stream\n * @param options - The options for the stream\n * @param args - Additional arguments to pass to the stream function\n * @returns An async iterable stream proxy\n * @throws {StreamInvalidRetryAttemptsError} if the retryAttempts option is less than 0 and retryOnFail is true\n * @throws {StreamFailedError} if the stream fails and can't be restarted\n */\nexport const createStream = async <T = unknown, V = T>(\n  streamFunction: StreamFunction<T>,\n  streamValueMutator?: StreamValueMutator<T, V>,\n  options?: StreamOptions<T, V>,\n) => {\n  const {\n    onError,\n    onFail,\n    onRestart,\n    onRetry,\n    onValue,\n    retryAttempts = DEFAULT_RETRY_ATTEMPTS,\n    retryDelay = DEFAULT_RETRY_DELAY,\n    retryOnFail = true,\n  } = options ?? {};\n  // retry attempts must be greater than 0\n  if (retryOnFail && retryAttempts < 0) {\n    throw new StreamInvalidRetryAttemptsError();\n  }\n\n  const asyncStream = new AsyncStream<V>();\n  const streamCallback: StreamCallback<T> = (error, value) => {\n    // if a stream error occurs, call the onError callback\n    if (error) {\n      onError?.(error);\n      return;\n    }\n    // ensure the value is not undefined\n    if (value !== undefined) {\n      try {\n        // if a streamValueMutator is provided, mutate the value\n        if (streamValueMutator) {\n          const mutatedValue = streamValueMutator(value);\n          if (isPromise(mutatedValue)) {\n            void mutatedValue\n              .then((mutatedValue) => {\n                asyncStream.push(mutatedValue);\n                onValue?.(mutatedValue);\n              })\n              .catch((error: unknown) => {\n                onError?.(error as Error);\n              });\n          } else {\n            asyncStream.push(mutatedValue);\n            onValue?.(mutatedValue);\n          }\n        } else {\n          asyncStream.push(value as unknown as V);\n          onValue?.(value as unknown as V);\n        }\n      } catch (error) {\n        onError?.(error as Error);\n      }\n    }\n  };\n  const retry = async (retries: number = retryAttempts) => {\n    // if the stream has been retried the maximum number of times without\n    // success, call onError\n    if (retries === 0) {\n      void asyncStream.end();\n      onError?.(new StreamFailedError(retryAttempts));\n      return;\n    }\n\n    // wait for the retry delay before attempting to restart the stream\n    await wait(retryDelay);\n    // call the onRetry callback\n    onRetry?.(retryAttempts - retries + 1, retryAttempts);\n    try {\n      // attempt to restart the stream\n      const streamCloser = await streamFunction(streamCallback, () => {\n        // call the onFail callback\n        onFail?.();\n        void retry();\n      });\n      await streamCloser.waitForReady();\n      // when the async stream is done, end the stream\n      asyncStream.onDone = () => {\n        streamCloser.end();\n      };\n      // stream restarted, call the onRestart callback\n      onRestart?.();\n    } catch (error) {\n      onError?.(error as Error);\n      // retry\n      void retry(retries - 1);\n    }\n  };\n  const startRetry = () => {\n    // if the stream should be retried, start the process\n    if (retryOnFail) {\n      void retry();\n    } else {\n      void asyncStream.end();\n      // stream failed and should not be retried, throw an error\n      onError?.(new StreamFailedError(0));\n    }\n  };\n\n  try {\n    // create the stream\n    const streamCloser = await streamFunction(streamCallback, () => {\n      // call the onFail callback\n      onFail?.();\n      startRetry();\n    });\n    await streamCloser.waitForReady();\n    // when the async stream is done, end the stream\n    asyncStream.onDone = () => {\n      streamCloser.end();\n    };\n  } catch (error) {\n    onError?.(error as Error);\n    startRetry();\n  }\n\n  // return a proxy for the async stream\n  return createAsyncStreamProxy(asyncStream);\n};\n",
      "size_bytes": 5789
    },
    "sdks/node-sdk/src/utils/errors.ts": {
      "content": "import type { ContentTypeId } from \"@xmtp/content-type-primitives\";\n\nexport class CodecNotFoundError extends Error {\n  constructor(contentType: ContentTypeId) {\n    super(`Codec not found for \"${contentType.toString()}\" content type`);\n  }\n}\n\nexport class InboxReassignError extends Error {\n  constructor() {\n    super(\n      \"Unable to create add account signature text, `allowInboxReassign` must be true\",\n    );\n  }\n}\n\nexport class AccountAlreadyAssociatedError extends Error {\n  constructor(inboxId: string) {\n    super(`Account already associated with inbox ${inboxId}`);\n  }\n}\n\nexport class InvalidGroupMembershipChangeError extends Error {\n  constructor(messageId: string) {\n    super(`Invalid group membership change for message ${messageId}`);\n  }\n}\n\nexport class MissingContentTypeError extends Error {\n  constructor() {\n    super(\"Content type is required when sending content other than text\");\n  }\n}\n\nexport class SignerUnavailableError extends Error {\n  constructor() {\n    super(\n      \"Signer unavailable, use Client.create to create a client with a signer\",\n    );\n  }\n}\n\nexport class ClientNotInitializedError extends Error {\n  constructor() {\n    super(\n      \"Client not initialized, use Client.create or Client.build to create a client\",\n    );\n  }\n}\n\nexport class StreamFailedError extends Error {\n  constructor(retryAttempts: number) {\n    const times = `time${retryAttempts !== 1 ? \"s\" : \"\"}`;\n    super(`Stream failed, retried ${retryAttempts} ${times}`);\n  }\n}\n\nexport class StreamInvalidRetryAttemptsError extends Error {\n  constructor() {\n    super(\"Stream retry attempts must be greater than 0\");\n  }\n}\n",
      "size_bytes": 1632
    },
    "content-types/content-type-text/rollup.config.js": {
      "content": "import terser from \"@rollup/plugin-terser\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { defineConfig } from \"rollup\";\nimport { dts } from \"rollup-plugin-dts\";\n\nconst plugins = [\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n];\n\nconst external = [\"@xmtp/content-type-primitives\"];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/browser/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins: [...plugins, terser()],\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.d.ts\",\n      format: \"es\",\n    },\n    plugins: [dts()],\n  },\n]);\n",
      "size_bytes": 832
    },
    "apps/xmtp.chat/src/components/Conversation/ManagePermissionsModal.tsx": {
      "content": "import { Button, Group } from \"@mantine/core\";\nimport { GroupPermissionsOptions, Group as XmtpGroup } from \"@xmtp/browser-sdk\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport { useNavigate, useOutletContext } from \"react-router\";\nimport type { ConversationOutletContext } from \"@/components/Conversation/ConversationOutletContext\";\nimport {\n  defaultPolicySet,\n  Permissions,\n  processPermissionsUpdate,\n} from \"@/components/Conversation/Permissions\";\nimport { Modal } from \"@/components/Modal\";\nimport { useCollapsedMediaQuery } from \"@/hooks/useCollapsedMediaQuery\";\nimport { useConversation } from \"@/hooks/useConversation\";\nimport { ContentLayout } from \"@/layouts/ContentLayout\";\nimport type { PolicySet } from \"@/types\";\n\nexport const ManagePermissionsModal: React.FC = () => {\n  const [isLoading, setIsLoading] = useState(false);\n  const [permissionsPolicy, setPermissionsPolicy] =\n    useState<GroupPermissionsOptions>(GroupPermissionsOptions.Default);\n  const [policySet, setPolicySet] = useState<PolicySet>(defaultPolicySet);\n\n  const { conversationId } = useOutletContext<ConversationOutletContext>();\n  const { conversation } = useConversation(conversationId);\n  const navigate = useNavigate();\n\n  const fullScreen = useCollapsedMediaQuery();\n  const contentHeight = fullScreen ? \"auto\" : 500;\n\n  const handleClose = useCallback(() => {\n    void navigate(`/conversations/${conversation.id}`);\n  }, [navigate, conversation.id]);\n\n  const handleUpdate = useCallback(async () => {\n    if (!(conversation instanceof XmtpGroup)) {\n      return;\n    }\n    setIsLoading(true);\n    try {\n      await processPermissionsUpdate(\n        conversation,\n        permissionsPolicy,\n        policySet,\n      );\n      void navigate(`/conversations/${conversation.id}`);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [conversation.id, permissionsPolicy, policySet, navigate]);\n\n  const footer = useMemo(() => {\n    return (\n      <Group justify=\"flex-end\" flex={1} p=\"md\">\n        <Button variant=\"default\" onClick={handleClose}>\n          Cancel\n        </Button>\n        <Button\n          variant=\"filled\"\n          disabled={isLoading}\n          loading={isLoading}\n          onClick={() => void handleUpdate()}>\n          Save\n        </Button>\n      </Group>\n    );\n  }, [isLoading, handleUpdate]);\n\n  return (\n    <Modal\n      closeOnClickOutside={false}\n      closeOnEscape={false}\n      withCloseButton={false}\n      opened\n      centered\n      fullScreen={fullScreen}\n      onClose={handleClose}\n      size=\"auto\"\n      padding={0}>\n      <ContentLayout\n        title=\"Manage permissions\"\n        maxHeight={contentHeight}\n        footer={footer}\n        withScrollAreaPadding={false}>\n        <Permissions\n          conversation={conversation}\n          onPermissionsPolicyChange={setPermissionsPolicy}\n          onPolicySetChange={setPolicySet}\n        />\n      </ContentLayout>\n    </Modal>\n  );\n};\n",
      "size_bytes": 2929
    },
    "apps/xmtp.chat-api-service/src/api/v2/resolve.router.ts": {
      "content": "import { Router, type Request, type Response } from \"express\";\nimport { z } from \"zod\";\nimport { fetchProfilesFromName } from \"../../helpers/web3.bio.js\";\n\nexport const resolveNameSchema = z.string().endsWith(\".eth\");\n\nexport async function resolveName(req: Request, res: Response) {\n  try {\n    const { name } = req.params;\n    const validName = resolveNameSchema.parse(name);\n    const profiles = await fetchProfilesFromName(validName);\n    if (!profiles || profiles.length === 0) {\n      res.status(404).json({ error: \"No profiles found\" });\n      return;\n    }\n    res.json({ profiles });\n  } catch (error: unknown) {\n    if (error instanceof z.ZodError) {\n      console.log(\"zod error\", z.prettifyError(error));\n      res.status(400).json({\n        error: \"Invalid request parameter\",\n        details: z.treeifyError(error),\n      });\n      return;\n    }\n    console.error(error);\n    res.status(500).json({ error: \"Failed to resolve name\" });\n  }\n}\n\nconst resolveRouter = Router();\nresolveRouter.get(\"/name/:name\", resolveName);\n\nexport default resolveRouter;\n",
      "size_bytes": 1066
    },
    "content-types/content-type-read-receipt/CHANGELOG.md": {
      "content": "# @xmtp/content-type-read-receipt\n\n## 2.0.2\n\n### Patch Changes\n\n- Updated dependencies [779fd0c]\n  - @xmtp/content-type-primitives@2.0.2\n\n## 2.0.1\n\n### Patch Changes\n\n- Updated dependencies [340fcf4]\n  - @xmtp/content-type-primitives@2.0.1\n\n## 2.0.0\n\n### Major Changes\n\n- 1777a23: Dropped support for CommonJS\n\n### Patch Changes\n\n- Updated dependencies [1777a23]\n  - @xmtp/content-type-primitives@2.0.0\n\n## 1.1.12\n\n### Patch Changes\n\n- Updated dependencies [63e5276]\n  - @xmtp/content-type-primitives@1.0.3\n\n## 1.1.11\n\n### Patch Changes\n\n- 9addb1c:\n  - Updated `ReadReceiptCodec` type to include parameters type\n  - Added and exported `ReadReceiptParameters` type\n- Updated dependencies [9addb1c]\n  - @xmtp/content-type-primitives@1.0.2\n\n## 1.1.10\n\n### Patch Changes\n\n- [#75](https://github.com/xmtp/xmtp-js-content-types/pull/75) [`da0bd85`](https://github.com/xmtp/xmtp-js-content-types/commit/da0bd8578d5f5032b221e25f02e8492b27929d6c)\n  - Use primitives package for types\n\n## 1.1.9\n\n### Patch Changes\n\n- [#65](https://github.com/xmtp/xmtp-js-content-types/pull/65) [`c4d43dc`](https://github.com/xmtp/xmtp-js-content-types/commit/c4d43dc948231de5c7f730e06f0931076de0673b)\n  - Add `shouldPush` to all content codecs\n\n## 1.1.8\n\n### Patch Changes\n\n- [#60](https://github.com/xmtp/xmtp-js-content-types/pull/60) [`5b9310a`](https://github.com/xmtp/xmtp-js-content-types/commit/5b9310ac89fd23e5cfd74903894073b6ef8af7c3)\n  - Upgraded JS SDK to `11.3.12`\n\n## 1.1.7\n\n### Patch Changes\n\n- [#54](https://github.com/xmtp/xmtp-js-content-types/pull/54) [`718cb9f`](https://github.com/xmtp/xmtp-js-content-types/commit/718cb9fec51f74bf2402f3f22160687cae35dda8)\n  - Updated Turbo config to remove `generate:types` command and instead rely on `build`\n  - Removed all `generate:types` commands from `package.json` files\n  - Updated shared ESLint config and local ESLint configs\n  - Updated `include` field of `tsconfig.json` and `tsconfig.eslint.json` files\n  - Replaced `tsup` with `rollup`\n\n## 1.1.6\n\n### Patch Changes\n\n- [#51](https://github.com/xmtp/xmtp-js-content-types/pull/51) [`aeb6db7`](https://github.com/xmtp/xmtp-js-content-types/commit/aeb6db73a63409a33c7d3d3431e33682b0ce4c4d)\n  - Only publish files in the `/dist` directory\n\n## 1.1.5\n\n### Patch Changes\n\n- Upgraded `@xmtp/proto` package\n- Upgraded `@xmtp/xmtp-js` package\n\n## 1.1.4\n\n### Patch Changes\n\n- Update `@xmtp/proto` to latest version\n\n## 1.1.3\n\n### Patch Changes\n\n- Upgrade to JS SDK v11\n- Update client initialization for tests to use `codecs` option for proper types\n\n## 1.1.2\n\n### Patch Changes\n\n- fix: remove timestamp from the read receipt content type\n\n## 1.1.1\n\n### Patch Changes\n\n- fix: update the copy for the default fallbacks\n\n## 1.1.0\n\n### Minor Changes\n\n- Add dummy fallback field to all content types\n\n## 1.0.1\n\n### Patch Changes\n\n- added readme\n\n## 1.0.0\n\n### Major Changes\n\n- added read receipt codec\n",
      "size_bytes": 2879
    },
    "sdks/agent-sdk/src/user.ts": {
      "content": "export * from \"./user/index.js\";\n",
      "size_bytes": 33
    },
    "apps/xmtp.chat/src/helpers/attachment.ts": {
      "content": "import {\n  AttachmentCodec,\n  RemoteAttachmentCodec,\n  type Attachment,\n  type RemoteAttachment,\n} from \"@xmtp/content-type-remote-attachment\";\nimport { PinataSDK } from \"pinata\";\n\nconst pinata = new PinataSDK({\n  pinataJwt: \"\",\n  pinataGateway: import.meta.env.VITE_PINATA_GATEWAY,\n});\n\nconst MAX_FILE_SIZE = 1024 * 1024; // 1MB\n\nconst ALLOWED_FILE_TYPES = [\n  \"image/jpeg\",\n  \"image/jpg\",\n  \"image/png\",\n  \"image/gif\",\n  \"image/webp\",\n  \"video/mp4\",\n  \"video/webm\",\n  \"video/quicktime\",\n  \"audio/mpeg\",\n  \"audio/mp3\",\n  \"audio/wav\",\n  \"audio/ogg\",\n];\n\nexport type FileValidation =\n  | {\n      valid: true;\n    }\n  | {\n      valid: false;\n      error: string;\n    };\n\nexport const validateFile = (file: File): FileValidation => {\n  if (file.size > MAX_FILE_SIZE) {\n    return {\n      valid: false,\n      error: \"File size must not be greater than 1MB\",\n    };\n  }\n\n  if (!ALLOWED_FILE_TYPES.includes(file.type)) {\n    return {\n      valid: false,\n      error:\n        \"File type not supported. Please select an image, video, or audio file.\",\n    };\n  }\n\n  return { valid: true };\n};\n\nexport const getPresignedUrl = async (): Promise<string> => {\n  const response = await fetch(\n    `${import.meta.env.VITE_API_SERVICE_URL}/api/v1/pinata/presigned-url`,\n    {\n      method: \"GET\",\n    },\n  );\n  const data = (await response.json()) as { url: string };\n  return data.url;\n};\n\nexport const uploadAttachment = async (\n  file: File,\n): Promise<RemoteAttachment> => {\n  // Convert file to array buffer for encryption\n  const arrayBuffer = await file.arrayBuffer();\n  const attachment = new Uint8Array(arrayBuffer);\n\n  // Use RemoteAttachmentCodec to encrypt the attachment\n  const attachmentData: Attachment = {\n    mimeType: file.type,\n    filename: file.name,\n    data: attachment,\n  };\n\n  const encryptedAttachment = await RemoteAttachmentCodec.encodeEncrypted(\n    attachmentData,\n    new AttachmentCodec(),\n  );\n\n  // Upload the encrypted payload to Pinata\n  const encryptedBlob = new Blob(\n    [encryptedAttachment.payload as Uint8Array<ArrayBuffer>],\n    {\n      type: \"application/octet-stream\",\n    },\n  );\n  const encryptedFile = new File([encryptedBlob], file.name, {\n    type: \"application/octet-stream\",\n  });\n\n  const presignedUrl = await getPresignedUrl();\n  const upload = await pinata.upload.public\n    .file(encryptedFile)\n    .url(presignedUrl);\n  const url = `https://${import.meta.env.VITE_PINATA_GATEWAY}/ipfs/${upload.cid}`;\n\n  // Return the RemoteAttachment with encryption metadata\n  return {\n    url,\n    contentDigest: encryptedAttachment.digest,\n    salt: encryptedAttachment.salt,\n    nonce: encryptedAttachment.nonce,\n    secret: encryptedAttachment.secret,\n    scheme: \"https://\",\n    contentLength: file.size,\n    filename: file.name,\n  };\n};\n\nexport const getFileType = (filename: string) => {\n  const extension = filename.split(\".\").pop()?.toLowerCase();\n  switch (extension) {\n    case \"jpg\":\n    case \"jpeg\":\n    case \"png\":\n    case \"gif\":\n    case \"webp\":\n      return \"image\";\n    case \"mp4\":\n    case \"webm\":\n    case \"mov\":\n      return \"video\";\n    case \"mp3\":\n    case \"wav\":\n    case \"ogg\":\n      return \"audio\";\n    default:\n      return \"file\";\n  }\n};\n\nexport const formatFileSize = (fileSize: number) => {\n  if (!fileSize) return \"\";\n  const kb = fileSize / 1024;\n  if (kb < 1024) {\n    return `${kb.toFixed(1)} KB`;\n  }\n  const mb = kb / 1024;\n  return `${mb.toFixed(1)} MB`;\n};\n",
      "size_bytes": 3422
    },
    "sdks/browser-sdk/src/utils/date.ts": {
      "content": "export function nsToDate(ns: bigint): Date {\n  return new Date(Number(ns / 1_000_000n));\n}\n",
      "size_bytes": 91
    },
    "content-types/content-type-reply/rollup.config.js": {
      "content": "import terser from \"@rollup/plugin-terser\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { defineConfig } from \"rollup\";\nimport { dts } from \"rollup-plugin-dts\";\n\nconst plugins = [\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n];\n\nconst external = [\"@xmtp/proto\", \"@xmtp/content-type-primitives\"];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/browser/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins: [...plugins, terser()],\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.d.ts\",\n      format: \"es\",\n    },\n    plugins: [dts()],\n  },\n]);\n",
      "size_bytes": 847
    },
    "sdks/browser-sdk/rollup.config.js": {
      "content": "import terser from \"@rollup/plugin-terser\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { defineConfig } from \"rollup\";\nimport { dts } from \"rollup-plugin-dts\";\nimport tsConfigPaths from \"rollup-plugin-tsconfig-paths\";\n\nconst plugins = [\n  tsConfigPaths(),\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n  terser(),\n];\n\nconst external = [\n  \"@xmtp/content-type-text\",\n  \"@xmtp/wasm-bindings\",\n  \"@xmtp/content-type-primitives\",\n  \"@xmtp/content-type-group-updated\",\n  \"uuid\",\n];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/workers/client.ts\",\n    output: {\n      file: \"dist/workers/client.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/workers/utils.ts\",\n    output: {\n      file: \"dist/workers/utils.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.d.ts\",\n      format: \"es\",\n    },\n    plugins: [tsConfigPaths(), dts()],\n  },\n]);\n",
      "size_bytes": 1203
    },
    "sdks/browser-sdk/vite.config.ts": {
      "content": "import { defineConfig, mergeConfig } from \"vite\";\nimport tsconfigPaths from \"vite-tsconfig-paths\";\nimport { defineConfig as defineVitestConfig } from \"vitest/config\";\n\n// https://vitejs.dev/config/\nconst viteConfig = defineConfig({\n  plugins: [tsconfigPaths()],\n});\n\nconst vitestConfig = defineVitestConfig({\n  optimizeDeps: {\n    exclude: [\"@xmtp/wasm-bindings\"],\n  },\n  test: {\n    browser: {\n      provider: \"playwright\",\n      enabled: true,\n      headless: true,\n      screenshotFailures: false,\n      instances: [\n        {\n          browser: \"chromium\",\n        },\n      ],\n    },\n    testTimeout: 120000,\n  },\n});\n\nexport default mergeConfig(viteConfig, vitestConfig);\n",
      "size_bytes": 677
    },
    "apps/xmtp.chat/src/stores/inbox/utils.ts": {
      "content": "import { type Conversation, type DecodedMessage } from \"@xmtp/browser-sdk\";\nimport type { ContentTypes } from \"@/contexts/XMTPContext\";\n\n/**\n * Returns the most recent conversation creation timestamp.\n * Used to track the latest conversation when syncing from the network and\n * sorting conversations.\n */\nexport const getLastCreatedAt = (\n  conversation: Conversation<ContentTypes>,\n  lastCreatedAt?: bigint,\n) => {\n  return !lastCreatedAt ||\n    (conversation.createdAtNs && conversation.createdAtNs > lastCreatedAt)\n    ? conversation.createdAtNs\n    : lastCreatedAt;\n};\n\n/**\n * Checks if a message was sent after the last sent timestamp.\n * Used to track the latest message when syncing from the network and\n * determining sort order of conversations and messages.\n */\nexport const isLastSentAt = (\n  message: DecodedMessage<ContentTypes>,\n  lastSentAt?: bigint,\n) => {\n  return !lastSentAt || message.sentAtNs > lastSentAt;\n};\n\n/**\n * Sorts conversations by most recent activity (last message or creation time).\n * Conversations with more recent messages appear first.\n */\nexport const sortConversations = (\n  conversations: Map<string, Conversation<ContentTypes>>,\n  lastMessages: Map<string, DecodedMessage<ContentTypes> | undefined>,\n) => {\n  const sortedConversations = Array.from(conversations.values()).sort(\n    (a, b) => {\n      const aLastMessage = lastMessages.get(a.id);\n      const bLastMessage = lastMessages.get(b.id);\n      const aVal = aLastMessage?.sentAtNs ?? a.createdAtNs ?? 0n;\n      const bVal = bLastMessage?.sentAtNs ?? b.createdAtNs ?? 0n;\n      return Number(bVal - aVal);\n    },\n  );\n  return sortedConversations;\n};\n\n/**\n * Sorts messages by sent time in ascending order (oldest first).\n * Used to display messages in chronological order within a conversation.\n */\nexport const sortMessages = (\n  messages: Map<string, DecodedMessage<ContentTypes>>,\n) => {\n  const sortedMessages = Array.from(messages.values()).sort((a, b) => {\n    return Number(a.sentAtNs - b.sentAtNs);\n  });\n  return sortedMessages;\n};\n",
      "size_bytes": 2040
    },
    "apps/xmtp.chat/src/helpers/xmtp.ts": {
      "content": "import type { SafeGroupMember } from \"@xmtp/browser-sdk\";\n\nexport const getMemberAddress = (member: SafeGroupMember) => {\n  return member.accountIdentifiers[0].identifier;\n};\n",
      "size_bytes": 175
    },
    "sdks/browser-sdk/src/index.ts": {
      "content": "export { Client } from \"./Client\";\nexport type { ExtractCodecContentTypes } from \"./Client\";\nexport { Conversations } from \"./Conversations\";\nexport { Conversation } from \"./Conversation\";\nexport { Dm } from \"./Dm\";\nexport { Group } from \"./Group\";\nexport type { MessageDeliveryStatus, MessageKind } from \"./DecodedMessage\";\nexport { DecodedMessage } from \"./DecodedMessage\";\nexport { Utils } from \"./Utils\";\nexport { ApiUrls, HistorySyncUrls } from \"./constants\";\nexport type * from \"./types/options\";\nexport * from \"./utils/conversions\";\nexport type { AsyncStreamProxy } from \"./AsyncStream\";\nexport type {\n  Identifier,\n  IdentifierKind,\n  UserPreference,\n} from \"@xmtp/wasm-bindings\";\nexport {\n  Consent,\n  ConsentEntityType,\n  ConsentState,\n  ContentType,\n  ContentTypeId,\n  ConversationListItem,\n  ConversationType,\n  CreateDMOptions,\n  CreateGroupOptions,\n  DeliveryStatus,\n  EncodedContent,\n  GroupMember,\n  GroupMembershipState,\n  GroupMessageKind,\n  GroupMetadata,\n  GroupPermissions,\n  GroupPermissionsOptions,\n  HmacKey,\n  InboxState,\n  Installation,\n  ListConversationsOptions,\n  ListMessagesOptions,\n  LogOptions,\n  Message,\n  MessageDisappearingSettings,\n  MetadataField,\n  PermissionLevel,\n  PermissionPolicy,\n  PermissionPolicySet,\n  PermissionUpdateType,\n  SignatureRequestHandle,\n  SortDirection,\n} from \"@xmtp/wasm-bindings\";\nexport type { Signer, SafeSigner, EOASigner, SCWSigner } from \"./utils/signer\";\nexport { toSafeSigner } from \"./utils/signer\";\nexport * from \"./utils/errors\";\nexport type * from \"./utils/streams\";\n",
      "size_bytes": 1543
    },
    "sdks/browser-sdk/src/types/actions/client.ts": {
      "content": "import type { Identifier } from \"@xmtp/wasm-bindings\";\nimport type { ClientOptions } from \"@/types/options\";\nimport type { SafeKeyPackageStatus } from \"@/utils/conversions\";\nimport type { SafeSigner } from \"@/utils/signer\";\n\nexport type ClientAction =\n  | {\n      action: \"client.init\";\n      id: string;\n      result: {\n        inboxId: string;\n        installationId: string;\n        installationIdBytes: Uint8Array;\n      };\n      data: {\n        identifier: Identifier;\n        options?: ClientOptions;\n      };\n    }\n  | {\n      action: \"client.applySignatureRequest\";\n      id: string;\n      result: undefined;\n      data: {\n        signer: SafeSigner;\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.createInboxSignatureText\";\n      id: string;\n      result: {\n        signatureText?: string;\n        signatureRequestId?: string;\n      };\n      data: {\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.addAccountSignatureText\";\n      id: string;\n      result: {\n        signatureText: string;\n        signatureRequestId: string;\n      };\n      data: {\n        newIdentifier: Identifier;\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.removeAccountSignatureText\";\n      id: string;\n      result: {\n        signatureText: string;\n        signatureRequestId: string;\n      };\n      data: {\n        identifier: Identifier;\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.revokeAllOtherInstallationsSignatureText\";\n      id: string;\n      result: {\n        signatureText: string;\n        signatureRequestId: string;\n      };\n      data: {\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.revokeInstallationsSignatureText\";\n      id: string;\n      result: {\n        signatureText: string;\n        signatureRequestId: string;\n      };\n      data: {\n        installationIds: Uint8Array[];\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.changeRecoveryIdentifierSignatureText\";\n      id: string;\n      result: {\n        signatureText: string;\n        signatureRequestId: string;\n      };\n      data: {\n        identifier: Identifier;\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.registerIdentity\";\n      id: string;\n      result: undefined;\n      data: {\n        signer: SafeSigner;\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.addAccount\";\n      id: string;\n      result: undefined;\n      data: {\n        identifier: Identifier;\n        signer: SafeSigner;\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.removeAccount\";\n      id: string;\n      result: undefined;\n      data: {\n        identifier: Identifier;\n        signer: SafeSigner;\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.revokeAllOtherInstallations\";\n      id: string;\n      result: undefined;\n      data: {\n        signer: SafeSigner;\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.changeRecoveryIdentifier\";\n      id: string;\n      result: undefined;\n      data: {\n        identifier: Identifier;\n        signer: SafeSigner;\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.revokeInstallations\";\n      id: string;\n      result: undefined;\n      data: {\n        installationIds: Uint8Array[];\n        signer: SafeSigner;\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"client.isRegistered\";\n      id: string;\n      result: boolean;\n      data: undefined;\n    }\n  | {\n      action: \"client.canMessage\";\n      id: string;\n      result: Map<string, boolean>;\n      data: {\n        identifiers: Identifier[];\n      };\n    }\n  | {\n      action: \"client.findInboxIdByIdentifier\";\n      id: string;\n      result: string | undefined;\n      data: {\n        identifier: Identifier;\n      };\n    }\n  | {\n      action: \"client.signWithInstallationKey\";\n      id: string;\n      result: Uint8Array;\n      data: {\n        signatureText: string;\n      };\n    }\n  | {\n      action: \"client.verifySignedWithInstallationKey\";\n      id: string;\n      result: boolean;\n      data: {\n        signatureText: string;\n        signatureBytes: Uint8Array;\n      };\n    }\n  | {\n      action: \"client.verifySignedWithPublicKey\";\n      id: string;\n      result: boolean;\n      data: {\n        signatureText: string;\n        signatureBytes: Uint8Array;\n        publicKey: Uint8Array;\n      };\n    }\n  | {\n      action: \"client.getKeyPackageStatusesForInstallationIds\";\n      id: string;\n      result: Map<string, SafeKeyPackageStatus>;\n      data: {\n        installationIds: string[];\n      };\n    };\n",
      "size_bytes": 4736
    },
    "apps/xmtp.chat/tailwind.config.js": {
      "content": "/** @type {import('tailwindcss').Config} */\nexport default {\n  content: [\n    \"./index.html\",\n    \"./src/**/*.{js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n  corePlugins: {\n    preflight: false,\n  },\n}\n",
      "size_bytes": 226
    },
    "sdks/agent-sdk/src/core/ConversationContext.ts": {
      "content": "import {\n  ConsentState,\n  type Client,\n  type Conversation,\n  type Dm,\n  type Group,\n} from \"@xmtp/node-sdk\";\nimport { filter } from \"@/core/filter.js\";\nimport { ClientContext } from \"./ClientContext.js\";\n\nexport class ConversationContext<\n  ContentTypes = unknown,\n  ConversationType extends Conversation = Conversation,\n> extends ClientContext<ContentTypes> {\n  #conversation: ConversationType;\n\n  constructor({\n    conversation,\n    client,\n  }: {\n    conversation: ConversationType;\n    client: Client<ContentTypes>;\n  }) {\n    super({ client });\n    this.#conversation = conversation;\n  }\n\n  isDm(): this is ConversationContext<ContentTypes, Dm<ContentTypes>> {\n    return filter.isDM(this.#conversation);\n  }\n\n  isGroup(): this is ConversationContext<ContentTypes, Group<ContentTypes>> {\n    return filter.isGroup(this.#conversation);\n  }\n\n  get conversation() {\n    return this.#conversation;\n  }\n\n  get isAllowed() {\n    return this.#conversation.consentState === ConsentState.Allowed;\n  }\n\n  get isDenied() {\n    return this.#conversation.consentState === ConsentState.Denied;\n  }\n\n  get isUnknown() {\n    return this.#conversation.consentState === ConsentState.Unknown;\n  }\n}\n",
      "size_bytes": 1187
    },
    "sdks/agent-sdk/src/utils/LimitedMap.ts": {
      "content": "export class LimitedMap<K, V> {\n  #map = new Map<K, V>();\n  #limit: number;\n\n  constructor(limit: number) {\n    this.#limit = limit;\n  }\n\n  set(key: K, value: V) {\n    if (this.#map.size >= this.#limit) {\n      const it = this.#map.keys().next();\n      if (!it.done) {\n        this.#map.delete(it.value);\n      }\n    }\n    this.#map.set(key, value);\n  }\n\n  get(key: K) {\n    return this.#map.get(key);\n  }\n}\n",
      "size_bytes": 408
    },
    "sdks/agent-sdk/src/core/filter.ts": {
      "content": "import {\n  ContentTypeGroupUpdated,\n  type GroupUpdatedCodec,\n} from \"@xmtp/content-type-group-updated\";\nimport {\n  ContentTypeReaction,\n  type ReactionCodec,\n} from \"@xmtp/content-type-reaction\";\nimport {\n  ContentTypeRemoteAttachment,\n  type RemoteAttachmentCodec,\n} from \"@xmtp/content-type-remote-attachment\";\nimport { ContentTypeReply, type ReplyCodec } from \"@xmtp/content-type-reply\";\nimport { ContentTypeText, type TextCodec } from \"@xmtp/content-type-text\";\nimport {\n  Dm,\n  Group,\n  type Client,\n  type Conversation,\n  type DecodedMessage,\n} from \"@xmtp/node-sdk\";\n\nexport type DecodedMessageWithContent<ContentTypes = unknown> =\n  DecodedMessage<ContentTypes> & {\n    content: ContentTypes;\n  };\n\nconst fromSelf = <ContentTypes>(\n  message: DecodedMessage<ContentTypes>,\n  client: Client<ContentTypes>,\n) => {\n  return message.senderInboxId === client.inboxId;\n};\n\nconst hasContent = <ContentTypes>(\n  message: DecodedMessage<ContentTypes>,\n): message is DecodedMessageWithContent<ContentTypes> => {\n  return message.content !== undefined && message.content !== null;\n};\n\nconst isDM = (conversation: Conversation): conversation is Dm => {\n  return conversation instanceof Dm;\n};\n\nconst isGroup = (conversation: Conversation): conversation is Group => {\n  return conversation instanceof Group;\n};\n\nconst isGroupAdmin = (conversation: Conversation, message: DecodedMessage) => {\n  if (isGroup(conversation)) {\n    return conversation.isAdmin(message.senderInboxId);\n  }\n  return false;\n};\n\nconst isGroupSuperAdmin = (\n  conversation: Conversation,\n  message: DecodedMessage,\n) => {\n  if (isGroup(conversation)) {\n    return conversation.isSuperAdmin(message.senderInboxId);\n  }\n  return false;\n};\n\nconst isGroupUpdate = (\n  message: DecodedMessage,\n): message is DecodedMessage & {\n  content: ReturnType<GroupUpdatedCodec[\"decode\"]>;\n} => {\n  return !!message.contentType?.sameAs(ContentTypeGroupUpdated);\n};\n\nconst isReaction = (\n  message: DecodedMessage,\n): message is DecodedMessage & {\n  content: ReturnType<ReactionCodec[\"decode\"]>;\n} => {\n  return !!message.contentType?.sameAs(ContentTypeReaction);\n};\n\nconst isReply = (\n  message: DecodedMessage,\n): message is DecodedMessage & {\n  content: ReturnType<ReplyCodec[\"decode\"]>;\n} => {\n  return !!message.contentType?.sameAs(ContentTypeReply);\n};\n\nconst isRemoteAttachment = (\n  message: DecodedMessage,\n): message is DecodedMessage & {\n  content: ReturnType<RemoteAttachmentCodec[\"decode\"]>;\n} => {\n  return !!message.contentType?.sameAs(ContentTypeRemoteAttachment);\n};\n\nconst isText = (\n  message: DecodedMessage,\n): message is DecodedMessageWithContent<ReturnType<TextCodec[\"decode\"]>> => {\n  return !!message.contentType?.sameAs(ContentTypeText);\n};\n\nconst isTextReply = (message: DecodedMessage) => {\n  return isReply(message) && typeof message.content.content === \"string\";\n};\n\nexport const filter = {\n  fromSelf,\n  hasContent,\n  isDM,\n  isGroup,\n  isGroupAdmin,\n  isGroupSuperAdmin,\n  isGroupUpdate,\n  isReaction,\n  isRemoteAttachment,\n  isReply,\n  isText,\n  isTextReply,\n};\n\nexport const f = filter;\n",
      "size_bytes": 3073
    },
    "sdks/browser-sdk/test/DebugInformation.test.ts": {
      "content": "import { describe, expect, it } from \"vitest\";\nimport {\n  createClient,\n  createRegisteredClient,\n  createSigner,\n  createUser,\n} from \"@test/helpers\";\n\ndescribe(\"DebugInformation\", () => {\n  it(\"should return network API statistics\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n\n    const apiStats = await client.debugInformation.apiStatistics();\n    expect(apiStats.fetchKeyPackage).toBe(0n);\n    expect(apiStats.queryGroupMessages).toBe(0n);\n    expect(apiStats.queryWelcomeMessages).toBe(0n);\n    expect(apiStats.sendGroupMessages).toBe(0n);\n    expect(apiStats.sendWelcomeMessages).toBe(0n);\n    expect(apiStats.subscribeMessages).toBe(0n);\n    expect(apiStats.subscribeWelcomes).toBe(0n);\n    expect(apiStats.uploadKeyPackage).toBe(1n);\n\n    const apiIdentityStats =\n      await client.debugInformation.apiIdentityStatistics();\n    // expect(apiIdentityStats.getIdentityUpdatesV2).toBe(2n);\n    expect(apiIdentityStats.getInboxIds).toBe(1n);\n    expect(apiIdentityStats.publishIdentityUpdate).toBe(1n);\n    expect(apiIdentityStats.verifySmartContractWalletSignature).toBe(0n);\n\n    await client.debugInformation.clearAllStatistics();\n\n    const apiStats2 = await client.debugInformation.apiStatistics();\n    expect(apiStats2.fetchKeyPackage).toBe(0n);\n    expect(apiStats2.queryGroupMessages).toBe(0n);\n    expect(apiStats2.queryWelcomeMessages).toBe(0n);\n    expect(apiStats2.sendWelcomeMessages).toBe(0n);\n    expect(apiStats2.subscribeMessages).toBe(0n);\n    expect(apiStats2.subscribeWelcomes).toBe(0n);\n    expect(apiStats2.uploadKeyPackage).toBe(0n);\n\n    const apiIdentityStats2 =\n      await client.debugInformation.apiIdentityStatistics();\n    expect(apiIdentityStats2.getIdentityUpdatesV2).toBe(0n);\n    expect(apiIdentityStats2.getInboxIds).toBe(0n);\n    expect(apiIdentityStats2.publishIdentityUpdate).toBe(0n);\n    expect(apiIdentityStats2.verifySmartContractWalletSignature).toBe(0n);\n\n    const apiAggregateStats =\n      await client.debugInformation.apiAggregateStatistics();\n    expect(apiAggregateStats).toBeDefined();\n  });\n\n  it(\"should upload a debug archive\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createClient(signer);\n\n    const result = await client.debugInformation.uploadDebugArchive();\n    expect(result).toBeDefined();\n  });\n});\n",
      "size_bytes": 2432
    },
    "content-types/content-type-wallet-send-calls/src/WalletSendCalls.ts": {
      "content": "import {\n  ContentTypeId,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\n\nexport const ContentTypeWalletSendCalls = new ContentTypeId({\n  authorityId: \"xmtp.org\",\n  typeId: \"walletSendCalls\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\nexport type WalletSendCallsParams = {\n  version: string;\n  chainId: `0x${string}`; // Hex chain id\n  from: `0x${string}`;\n  calls: {\n    to?: `0x${string}`;\n    data?: `0x${string}`;\n    value?: `0x${string}`; // Hex value\n    gas?: `0x${string}`;\n    metadata?: {\n      description: string;\n      transactionType: string;\n    } & Record<string, string>;\n  }[];\n  capabilities?: Record<string, string>;\n};\n\nexport class WalletSendCallsCodec\n  implements ContentCodec<WalletSendCallsParams>\n{\n  get contentType(): ContentTypeId {\n    return ContentTypeWalletSendCalls;\n  }\n\n  encode(content: WalletSendCallsParams): EncodedContent {\n    const encoded = {\n      type: ContentTypeWalletSendCalls,\n      parameters: {},\n      content: new TextEncoder().encode(JSON.stringify(content)),\n    };\n    return encoded;\n  }\n\n  decode(encodedContent: EncodedContent): WalletSendCallsParams {\n    const uint8Array = encodedContent.content;\n    const contentReceived = JSON.parse(\n      new TextDecoder().decode(uint8Array),\n    ) as WalletSendCallsParams;\n    return contentReceived;\n  }\n\n  fallback(content: WalletSendCallsParams): string | undefined {\n    return `[Transaction request generated]: ${JSON.stringify(content)}`;\n  }\n\n  shouldPush() {\n    return true;\n  }\n}\n",
      "size_bytes": 1532
    },
    "apps/xmtp.chat/src/components/InboxTools/InstallationTable.tsx": {
      "content": "import { Checkbox, Table, Text, Tooltip, useMatches } from \"@mantine/core\";\nimport type { SafeInstallation } from \"@xmtp/browser-sdk\";\nimport { formatDistanceToNow } from \"date-fns\";\nimport { BadgeWithCopy } from \"@/components/BadgeWithCopy\";\nimport { nsToDate } from \"@/helpers/date\";\n\ntype InstallationTableRowProps = {\n  installation: SafeInstallation;\n  selectedInstallationIds: string[];\n  setSelectedInstallationIds: React.Dispatch<React.SetStateAction<string[]>>;\n};\n\nconst InstallationTableRow: React.FC<InstallationTableRowProps> = ({\n  installation,\n  selectedInstallationIds,\n  setSelectedInstallationIds,\n}) => {\n  const maw = useMatches({\n    base: \"6rem\",\n    sm: \"10rem\",\n  });\n\n  const createdAt = nsToDate(installation.clientTimestampNs ?? 0n);\n  const checked = selectedInstallationIds.includes(installation.id);\n\n  return (\n    <Table.Tr>\n      <Table.Td maw=\"2rem\">\n        <Checkbox\n          checked={checked}\n          onChange={(event) => {\n            if (event.currentTarget.checked) {\n              setSelectedInstallationIds([\n                ...selectedInstallationIds,\n                installation.id,\n              ]);\n            } else {\n              setSelectedInstallationIds(\n                selectedInstallationIds.filter((id) => id !== installation.id),\n              );\n            }\n          }}\n        />\n      </Table.Td>\n      <Table.Td>\n        <BadgeWithCopy value={installation.id} />\n      </Table.Td>\n      <Table.Td maw={maw}>\n        <Tooltip label={createdAt.toISOString()}>\n          <Text size=\"sm\" style={{ whiteSpace: \"nowrap\" }}>\n            {formatDistanceToNow(createdAt, {\n              addSuffix: true,\n            })}\n          </Text>\n        </Tooltip>\n      </Table.Td>\n    </Table.Tr>\n  );\n};\n\ntype InstallationTableProps = {\n  installations: SafeInstallation[];\n  selectedInstallationIds: string[];\n  setSelectedInstallationIds: React.Dispatch<React.SetStateAction<string[]>>;\n};\n\nexport const InstallationTable: React.FC<InstallationTableProps> = ({\n  installations,\n  selectedInstallationIds,\n  setSelectedInstallationIds,\n}) => {\n  return (\n    <Table>\n      <Table.Thead>\n        <Table.Tr>\n          <Table.Th></Table.Th>\n          <Table.Th>Installation ID</Table.Th>\n          <Table.Th>Created</Table.Th>\n        </Table.Tr>\n      </Table.Thead>\n      <Table.Tbody>\n        {installations.map((installation) => (\n          <InstallationTableRow\n            key={installation.id}\n            installation={installation}\n            selectedInstallationIds={selectedInstallationIds}\n            setSelectedInstallationIds={setSelectedInstallationIds}\n          />\n        ))}\n      </Table.Tbody>\n    </Table>\n  );\n};\n",
      "size_bytes": 2692
    },
    "apps/xmtp.chat/src/components/Conversations/CreateDmModal.tsx": {
      "content": "import { Box, Button, Group, TextInput } from \"@mantine/core\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport { useNavigate } from \"react-router\";\nimport { Modal } from \"@/components/Modal\";\nimport { useCollapsedMediaQuery } from \"@/hooks/useCollapsedMediaQuery\";\nimport { useConversations } from \"@/hooks/useConversations\";\nimport { useMemberId } from \"@/hooks/useMemberId\";\nimport { ContentLayout } from \"@/layouts/ContentLayout\";\nimport { useActions } from \"@/stores/inbox/hooks\";\n\nexport const CreateDmModal: React.FC = () => {\n  const { newDm } = useConversations();\n  const { addConversation } = useActions();\n  const [loading, setLoading] = useState(false);\n  const {\n    memberId,\n    setMemberId,\n    error: memberIdError,\n    inboxId,\n  } = useMemberId();\n  const navigate = useNavigate();\n  const fullScreen = useCollapsedMediaQuery();\n  const contentHeight = fullScreen ? \"auto\" : 500;\n\n  const handleClose = useCallback(() => {\n    void navigate(-1);\n  }, [navigate]);\n\n  const handleCreate = async () => {\n    setLoading(true);\n\n    try {\n      const conversation = await newDm(inboxId);\n      // ensure conversation is added to store so navigation works\n      await addConversation(conversation);\n      void navigate(`/conversations/${conversation.id}`);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const footer = useMemo(() => {\n    return (\n      <Group justify=\"flex-end\" flex={1} p=\"md\">\n        <Button variant=\"default\" onClick={handleClose}>\n          Cancel\n        </Button>\n        <Button\n          variant=\"filled\"\n          disabled={loading || memberIdError !== null || !inboxId}\n          loading={loading}\n          onClick={() => void handleCreate()}>\n          Create\n        </Button>\n      </Group>\n    );\n  }, [handleClose, handleCreate, loading]);\n\n  return (\n    <Modal\n      closeOnClickOutside={false}\n      closeOnEscape={false}\n      withCloseButton={false}\n      opened\n      centered\n      fullScreen={fullScreen}\n      onClose={handleClose}\n      size=\"600\"\n      padding={0}>\n      <ContentLayout\n        title=\"Create direct message\"\n        maxHeight={contentHeight}\n        footer={footer}\n        withScrollAreaPadding={false}>\n        <Box p=\"md\">\n          <TextInput\n            size=\"sm\"\n            label=\"Address, inbox ID, ENS name, or Base name\"\n            styles={{\n              label: {\n                marginBottom: \"var(--mantine-spacing-xxs)\",\n              },\n            }}\n            error={memberIdError}\n            value={memberId}\n            onChange={(event) => {\n              setMemberId(event.target.value);\n            }}\n          />\n        </Box>\n      </ContentLayout>\n    </Modal>\n  );\n};\n",
      "size_bytes": 2700
    },
    "apps/xmtp.chat/src/hooks/useRedirect.ts": {
      "content": "import { useLocalStorage } from \"@mantine/hooks\";\n\nexport const useRedirect = () => {\n  const [redirectUrl, setRedirectUrl] = useLocalStorage({\n    key: \"XMTP_REDIRECT_URL\",\n    defaultValue: \"\",\n    getInitialValueInEffect: false,\n  });\n\n  return {\n    redirectUrl,\n    setRedirectUrl,\n  };\n};\n",
      "size_bytes": 295
    },
    "apps/xmtp.chat/src/components/Conversations/ConversationList.tsx": {
      "content": "import type { Conversation } from \"@xmtp/browser-sdk\";\nimport { useMemo, type ComponentProps } from \"react\";\nimport { useParams } from \"react-router\";\nimport { Virtuoso } from \"react-virtuoso\";\nimport type { ContentTypes } from \"@/contexts/XMTPContext\";\nimport { ConversationCard } from \"./ConversationCard\";\nimport classes from \"./ConversationList.module.css\";\n\nconst List = (props: ComponentProps<\"div\">) => {\n  return <div className={classes.root} {...props} />;\n};\n\nexport type ConversationsListProps = {\n  conversations: Conversation<ContentTypes>[];\n};\n\nexport const ConversationsList: React.FC<ConversationsListProps> = ({\n  conversations,\n}) => {\n  const { conversationId } = useParams();\n  const selectedConversationIndex = useMemo(\n    () =>\n      conversations.findIndex(\n        (conversation) => conversation.id === conversationId,\n      ),\n    [conversations, conversationId],\n  );\n  return (\n    <Virtuoso\n      components={{\n        List,\n      }}\n      initialTopMostItemIndex={Math.max(selectedConversationIndex, 0)}\n      style={{ flexGrow: 1 }}\n      data={conversations}\n      itemContent={(_, conversation) => (\n        <ConversationCard\n          key={conversation.id}\n          conversationId={conversation.id}\n        />\n      )}\n    />\n  );\n};\n",
      "size_bytes": 1270
    },
    "sdks/browser-sdk/src/types/actions/group.ts": {
      "content": "import type {\n  Identifier,\n  MetadataField,\n  PermissionPolicy,\n  PermissionUpdateType,\n} from \"@xmtp/wasm-bindings\";\nimport type { SafeConversation } from \"@/utils/conversions\";\n\nexport type GroupAction =\n  | {\n      action: \"group.listAdmins\";\n      id: string;\n      result: string[];\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"group.listSuperAdmins\";\n      id: string;\n      result: string[];\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"group.isAdmin\";\n      id: string;\n      result: boolean;\n      data: {\n        id: string;\n        inboxId: string;\n      };\n    }\n  | {\n      action: \"group.isSuperAdmin\";\n      id: string;\n      result: boolean;\n      data: {\n        id: string;\n        inboxId: string;\n      };\n    }\n  | {\n      action: \"group.addMembersByIdentifiers\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        identifiers: Identifier[];\n      };\n    }\n  | {\n      action: \"group.removeMembersByIdentifiers\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        identifiers: Identifier[];\n      };\n    }\n  | {\n      action: \"group.addMembers\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        inboxIds: string[];\n      };\n    }\n  | {\n      action: \"group.removeMembers\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        inboxIds: string[];\n      };\n    }\n  | {\n      action: \"group.addAdmin\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        inboxId: string;\n      };\n    }\n  | {\n      action: \"group.removeAdmin\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        inboxId: string;\n      };\n    }\n  | {\n      action: \"group.addSuperAdmin\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        inboxId: string;\n      };\n    }\n  | {\n      action: \"group.removeSuperAdmin\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        inboxId: string;\n      };\n    }\n  | {\n      action: \"group.updateName\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        name: string;\n      };\n    }\n  | {\n      action: \"group.updateDescription\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        description: string;\n      };\n    }\n  | {\n      action: \"group.updateImageUrl\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        imageUrl: string;\n      };\n    }\n  | {\n      action: \"group.updatePermission\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        permissionType: PermissionUpdateType;\n        policy: PermissionPolicy;\n        metadataField?: MetadataField;\n      };\n    }\n  | {\n      action: \"group.permissions\";\n      id: string;\n      result: SafeConversation[\"permissions\"];\n      data: {\n        id: string;\n      };\n    };\n",
      "size_bytes": 3002
    },
    "content-types/content-type-reply/README.md": {
      "content": "# Reply content type\n\nThis package provides an XMTP content type to support direct replies to messages.\n\n> **Open for feedback**  \n> You are welcome to provide feedback on this implementation by commenting on [XIP-20: Reactions content type](https://community.xmtp.org/t/xip-20-reactions-content-type/524).\n\n## What’s a reply?\n\nA reply action is a way to respond directly to a specific message in a conversation. Instead of sending a new message, users can select and reply to a particular message.\n\n## Why replies?\n\nProviding replies in your app enables users to maintain context and clarity in their conversations. Replies can also help organize messages, making messages easier to find and reference in the future. This user experience can help make your app a great tool for collaboration.\n\n## Install the package\n\n```bash\n# npm\nnpm i @xmtp/content-type-reply\n\n# yarn\nyarn add @xmtp/content-type-reply\n\n# pnpm\npnpm i @xmtp/content-type-reply\n```\n\n## Create a reply\n\nWith XMTP, replies are represented as objects with the following keys:\n\n- `reference`: The message ID for the message that is being reacted to\n- `content`: A string representation of the reply\n\n```tsx\nconst reply: Reply = {\n  reference: someMessageID,\n  content: \"I concur\",\n};\n```\n\n## Send a reply\n\nNow that you have a reply, you can send it:\n\n```tsx\nawait conversation.messages.send(reply, {\n  contentType: ContentTypeReply,\n});\n```\n\n> **Note**  \n> `contentFallback` text is provided by the codec and gives clients that _don't_ support a content type the option to display some useful context. For cases where clients *do* support the content type, they can use the content fallback as alt text for accessibility purposes.\n\n## Receive a reply\n\nNow that you can send a reply, you need a way to receive a reply. For example:\n\n```tsx\n// Assume `loadLastMessage` is a thing you have\nconst message: DecodedMessage = await loadLastMessage();\n\nif (!message.contentType.sameAs(ContentTypeReply)) {\n  // We do not have a reply. A topic for another blog post.\n  return;\n}\n\n// We've got a reply.\nconst reply: Reply = message.content;\n```\n\n## Display the reply\n\nGenerally, replies should be displayed alongside the original message to provide context. Ultimately, how you choose to display replies is completely up to you.\n\n## Developing\n\nRun `yarn dev` to build the content type and watch for changes, which will trigger a rebuild.\n\nFor more information on contributing to this repository, see our [contributing guidelines](../../CONTRIBUTING.md).\n",
      "size_bytes": 2512
    },
    "apps/xmtp.chat/src/components/Conversation/ManageConsentModal.tsx": {
      "content": "import { Box, Button, Group, NativeSelect } from \"@mantine/core\";\nimport { ConsentState } from \"@xmtp/browser-sdk\";\nimport {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ChangeEvent,\n} from \"react\";\nimport { useNavigate, useOutletContext } from \"react-router\";\nimport { Modal } from \"@/components/Modal\";\nimport { useCollapsedMediaQuery } from \"@/hooks/useCollapsedMediaQuery\";\nimport { useConversation } from \"@/hooks/useConversation\";\nimport { ContentLayout } from \"@/layouts/ContentLayout\";\nimport type { ConversationOutletContext } from \"./ConversationOutletContext\";\n\nexport const ManageConsentModal: React.FC = () => {\n  const { conversationId } = useOutletContext<ConversationOutletContext>();\n  const { conversation } = useConversation(conversationId);\n  const navigate = useNavigate();\n  const fullScreen = useCollapsedMediaQuery();\n  const contentHeight = fullScreen ? \"auto\" : 500;\n  const initialConsentState = useRef<ConsentState>(ConsentState.Unknown);\n  const [consentState, setConsentState] = useState<ConsentState>(\n    ConsentState.Unknown,\n  );\n  const [consentStateLoading, setConsentStateLoading] = useState(false);\n\n  useEffect(() => {\n    const loadConsentState = async () => {\n      const consentState = await conversation.consentState();\n      initialConsentState.current = consentState;\n      setConsentState(consentState);\n    };\n    void loadConsentState();\n  }, [conversation.id]);\n\n  const handleClose = useCallback(() => {\n    void navigate(`/conversations/${conversation.id}`);\n  }, [navigate, conversation.id]);\n\n  const handleConsentStateChange = useCallback(\n    (event: ChangeEvent<HTMLSelectElement>) => {\n      const newValue = parseInt(event.currentTarget.value, 10) as ConsentState;\n      setConsentState(newValue);\n    },\n    [conversation.id],\n  );\n\n  const handleConsentStateUpdate = useCallback(async () => {\n    setConsentStateLoading(true);\n    try {\n      await conversation.updateConsentState(consentState);\n      handleClose();\n    } finally {\n      setConsentStateLoading(false);\n    }\n  }, [conversation.id, consentState, handleClose]);\n\n  const footer = useMemo(() => {\n    return (\n      <Group justify=\"flex-end\" flex={1} p=\"md\">\n        <Button variant=\"default\" onClick={handleClose}>\n          Cancel\n        </Button>\n        <Button\n          variant=\"filled\"\n          disabled={consentState === initialConsentState.current}\n          loading={consentStateLoading}\n          onClick={() => void handleConsentStateUpdate()}>\n          Save\n        </Button>\n      </Group>\n    );\n  }, [consentState, handleConsentStateUpdate]);\n\n  return (\n    <Modal\n      closeOnClickOutside={false}\n      closeOnEscape={false}\n      withCloseButton={false}\n      opened\n      centered\n      fullScreen={fullScreen}\n      onClose={handleClose}\n      size=\"xs\"\n      padding={0}>\n      <ContentLayout\n        title=\"Manage consent\"\n        maxHeight={contentHeight}\n        footer={footer}\n        withScrollFade={false}\n        withScrollAreaPadding={false}>\n        <Box p=\"md\">\n          <NativeSelect\n            size=\"sm\"\n            disabled={consentStateLoading}\n            value={consentState}\n            onChange={(event) => {\n              handleConsentStateChange(event);\n            }}\n            data={[\n              { value: \"0\", label: \"Unknown\" },\n              { value: \"1\", label: \"Allowed\" },\n              { value: \"2\", label: \"Denied\" },\n            ]}\n          />\n        </Box>\n      </ContentLayout>\n    </Modal>\n  );\n};\n",
      "size_bytes": 3516
    },
    "sdks/node-sdk/scripts/groups.ts": {
      "content": "import { readFile } from \"node:fs/promises\";\nimport path from \"node:path\";\nimport { IdentifierKind } from \"@xmtp/node-bindings\";\nimport { Client } from \"@/Client\";\nimport { createSigner, createUser, type User } from \"@test/helpers\";\n\nexport const createRegisteredClient = async (\n  user: User,\n  dbPath?: string | null,\n) => {\n  return Client.create(createSigner(user), {\n    env: \"local\",\n    dbPath,\n  });\n};\n\nconst accountsJsonPath = path.join(import.meta.dirname, \"accounts.json\");\nconst parsedAccounts = JSON.parse(\n  await readFile(accountsJsonPath, \"utf-8\"),\n) as Record<string, string>;\n\ntype Account = { key: string; address: string };\nconst accounts: Account[] = Object.entries(parsedAccounts).map(\n  ([key, address]) => ({ key, address }),\n);\n\nconst primaryAccount = accounts.shift() as Account;\n\nconst primaryAccountClient = await createRegisteredClient(\n  createUser(primaryAccount.key as `0x${string}`),\n  \"./test.db3\",\n);\n\nconsole.log(\"Registering accounts...\");\n\nfor (const a of accounts) {\n  await createRegisteredClient(createUser(a.key as `0x${string}`), null);\n}\n\nconst groups = [];\n\nconsole.log(\"Creating groups...\");\n\n// create a bunch of groups\nwhile (accounts.length > 200) {\n  const groupsAccounts = accounts.splice(0, 4);\n  const group =\n    await primaryAccountClient.conversations.newGroupWithIdentifiers(\n      groupsAccounts.map((a) => ({\n        identifierKind: IdentifierKind.Ethereum,\n        identifier: a.address,\n      })),\n    );\n  groups.push(group);\n}\n\nconsole.log(`Created ${groups.length} groups`);\n\nconsole.log(`Sending \"gm\" message into each group...`);\n\nfor (const group of groups) {\n  await group.send(\"gm\");\n}\n\nconsole.log(\"Creating DM groups...\");\n\nconst dmGroups = [];\n\nwhile (accounts.length > 0) {\n  const dmGroup = await primaryAccountClient.conversations.newDmWithIdentifier({\n    identifierKind: IdentifierKind.Ethereum,\n    identifier: (accounts.pop() as Account).address,\n  });\n  dmGroups.push(dmGroup);\n}\n\nconsole.log(`Created ${dmGroups.length} DM groups`);\n\nconsole.log(\"Sending 'gm' message into each DM group...\");\n\nfor (const dmGroup of dmGroups) {\n  await dmGroup.send(\"gm\");\n}\n\nconsole.log(\"Syncing all conversations...\");\n\nawait primaryAccountClient.conversations.syncAll();\n\nconsole.log(\"Querying DM groups...\");\n\nconst groupConvos = primaryAccountClient.conversations.listGroups();\nconst dmConvos = primaryAccountClient.conversations.listDms();\n\nconsole.log(`Found ${dmConvos.length} DM conversations`);\nconsole.log(`Found ${groupConvos.length} group conversations`);\n",
      "size_bytes": 2534
    },
    "apps/xmtp.chat/src/components/App/AppMenu.tsx": {
      "content": "import { ActionIcon, Menu } from \"@mantine/core\";\nimport { useCallback } from \"react\";\nimport { useNavigate } from \"react-router\";\nimport { useRedirect } from \"@/hooks/useRedirect\";\nimport { IconDots } from \"@/icons/IconDots\";\n\nexport const AppMenu: React.FC = () => {\n  const navigate = useNavigate();\n  const { setRedirectUrl } = useRedirect();\n\n  const handleDisconnect = useCallback(() => {\n    setRedirectUrl(`${location.pathname}${location.search}`);\n    void navigate(\"/disconnect\");\n  }, [navigate, setRedirectUrl]);\n\n  return (\n    <Menu shadow=\"md\" position=\"bottom-end\">\n      <Menu.Target>\n        <ActionIcon\n          variant=\"light\"\n          radius=\"xl\"\n          size=\"lg\"\n          style={{\n            background:\n              \"linear-gradient(130deg, rgba(10, 255, 241, 0.16), rgba(151, 114, 251, 0.24))\",\n            border: \"1px solid rgba(10, 255, 241, 0.25)\",\n            color: \"var(--mantine-color-gray-0)\",\n            boxShadow: \"0 14px 26px rgba(10, 255, 241, 0.18)\",\n          }}>\n          <IconDots />\n        </ActionIcon>\n      </Menu.Target>\n      <Menu.Dropdown miw={200}>\n        <Menu.Label>Actions</Menu.Label>\n        <Menu.Item onClick={() => void navigate(\"new-dm\")}>\n          New direct message\n        </Menu.Item>\n        <Menu.Item onClick={() => void navigate(\"new-group\")}>\n          New group\n        </Menu.Item>\n        <Menu.Item onClick={handleDisconnect}>Disconnect</Menu.Item>\n      </Menu.Dropdown>\n    </Menu>\n  );\n};\n",
      "size_bytes": 1477
    },
    "apps/xmtp.chat/src/components/Conversation/MemberPopover.module.css": {
      "content": ".profile {\n  position: relative;\n}\n\n.menu {\n  position: absolute;\n  top: 0;\n  right: 0;\n}\n",
      "size_bytes": 90
    },
    "content-types/content-type-read-receipt/README.md": {
      "content": "# Read receipt content type\n\nThis package provides an XMTP content type to support read receipts to messages.\n\n## What’s a read receipt?\n\nA read receipt is a message sent to confirm that a previously sent message has been read by the recipient. With XMTP, read receipts are special messages with the `ReadReceipt` content type. They contain a timestamp of when the original message was read.\n\nWhen someone receives a message using an app with read receipts enabled, their XMTP client can send a read receipt when they open that message.\n\n## Why read receipts?\n\nRead receipts give the sender confirmation that the recipient has read their message. This avoids uncertainty about whether a message was seen, without needing to rely on a manual response.\n\n## Install the package\n\n```bash\n# npm\nnpm i @xmtp/content-type-read-receipt\n\n# yarn\nyarn add @xmtp/content-type-read-receipt\n\n# pnpm\npnpm i @xmtp/content-type-read-receipt\n```\n\n## Provide an opt-out option\n\nWhile this is a per-app decision, the best practice is to provide users with the option to opt out of sending read receipts. If a user opts out, when they read a message, a read receipt will not be sent to the sender of the message.\n\n## Create a read receipt\n\nWith XMTP, read receipts are represented as empty objects.\n\n```tsx\nconst readReceipt: ReadReceipt = {};\n```\n\n## Send a read receipt\n\nIf a sender has opened a conversation and has not yet sent a read receipt for its received messages (this can either be done with each message or the most recent message and is an individual app decision), you can send a read receipt like so:\n\n```tsx\nawait conversation.messages.send({}, ContentTypeReadReceipt);\n```\n\n## Receive a read receipt\n\nNow that you can send a read receipt, you can also receive a read receipt that was sent from another user. For example:\n\n```tsx\n// Assume `loadLastMessage` is a thing you have\nconst message: DecodedMessage = await loadLastMessage();\n\nif (message.contentType.sameAs(ContentTypeReadReceipt)) {\n  // We have a read receipt\n  return;\n}\n```\n\n## Display the read receipt\n\nGenerally, a read receipt indicator should be displayed under the message it's associated with. The indicator can include a timestamp. Ultimately, how you choose to display a read receipt indicator is completely up to you.\n\n> [!IMPORTANT]\n> The read receipt is provided as an **empty message** whose timestamp provides the data needed for the indicators. **Be sure to filter out read receipt empty messages and not display them to users.**\n\n## Developing\n\nRun `yarn dev` to build the content type and watch for changes, which will trigger a rebuild.\n\nFor more information on contributing to this repository, see our [contributing guidelines](../../CONTRIBUTING.md).\n",
      "size_bytes": 2731
    },
    "content-types/content-type-primitives/rollup.config.js": {
      "content": "import terser from \"@rollup/plugin-terser\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { defineConfig } from \"rollup\";\nimport { dts } from \"rollup-plugin-dts\";\n\nconst plugins = [\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n];\n\nconst external = [\"@xmtp/proto\"];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/browser/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins: [...plugins, terser()],\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.d.ts\",\n      format: \"es\",\n    },\n    plugins: [dts()],\n  },\n]);\n",
      "size_bytes": 814
    },
    "sdks/node-sdk/src/utils/createClient.ts": {
      "content": "import { join } from \"node:path\";\nimport process from \"node:process\";\nimport {\n  createClient as createNodeClient,\n  LogLevel,\n  SyncWorkerMode,\n  type Identifier,\n  type LogOptions,\n} from \"@xmtp/node-bindings\";\nimport { ApiUrls, HistorySyncUrls } from \"@/constants\";\nimport type { ClientOptions } from \"@/types\";\nimport { generateInboxId, getInboxIdForIdentifier } from \"@/utils/inboxId\";\nimport { isHexString } from \"./validation\";\n\nexport const createClient = async (\n  identifier: Identifier,\n  options?: ClientOptions,\n) => {\n  const env = options?.env || \"dev\";\n  const host = options?.apiUrl || ApiUrls[env];\n  const isSecure = host.startsWith(\"https\");\n  const inboxId =\n    (await getInboxIdForIdentifier(identifier, env)) ||\n    generateInboxId(identifier);\n  let dbPath: string | null;\n  if (options?.dbPath === undefined) {\n    // Default: auto-generated path\n    dbPath = join(process.cwd(), `xmtp-${env}-${inboxId}.db3`);\n  } else if (typeof options.dbPath === \"function\") {\n    // Callback function: call with inbox ID\n    dbPath = options.dbPath(inboxId);\n  } else {\n    // String or null: use as-is\n    dbPath = options.dbPath;\n  }\n\n  const logOptions: LogOptions = {\n    structured: options?.structuredLogging ?? false,\n    level: options?.loggingLevel ?? LogLevel.off,\n  };\n  const historySyncUrl =\n    options?.historySyncUrl === undefined\n      ? HistorySyncUrls[env]\n      : options.historySyncUrl;\n\n  const deviceSyncWorkerMode = options?.disableDeviceSync\n    ? SyncWorkerMode.disabled\n    : SyncWorkerMode.enabled;\n\n  const dbEncryptionKey = isHexString(options?.dbEncryptionKey)\n    ? Buffer.from(options.dbEncryptionKey.replace(/^0x/, \"\"), \"hex\")\n    : options?.dbEncryptionKey;\n\n  return createNodeClient(\n    host,\n    isSecure,\n    dbPath,\n    inboxId,\n    identifier,\n    dbEncryptionKey,\n    historySyncUrl,\n    deviceSyncWorkerMode,\n    logOptions,\n    undefined,\n    options?.debugEventsEnabled,\n    options?.appVersion,\n  );\n};\n",
      "size_bytes": 1964
    },
    "apps/xmtp.chat/src/components/Messages/Messages.tsx": {
      "content": "import { Box, Text } from \"@mantine/core\";\nimport type { DecodedMessage } from \"@xmtp/browser-sdk\";\nimport { MessageList } from \"./MessageList\";\n\nexport type ConversationProps = {\n  messages: DecodedMessage[];\n};\n\nexport const Messages: React.FC<ConversationProps> = ({ messages }) => {\n  return messages.length === 0 ? (\n    <Box\n      display=\"flex\"\n      style={{\n        flexGrow: 1,\n        alignItems: \"center\",\n        justifyContent: \"center\",\n      }}>\n      <Text>No messages</Text>\n    </Box>\n  ) : (\n    <MessageList messages={messages} />\n  );\n};\n",
      "size_bytes": 560
    },
    "sdks/node-sdk/rollup.config.js": {
      "content": "import json from \"@rollup/plugin-json\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { defineConfig } from \"rollup\";\nimport { dts } from \"rollup-plugin-dts\";\nimport tsConfigPaths from \"rollup-plugin-tsconfig-paths\";\n\nconst external = [\n  \"node:path\",\n  \"node:process\",\n  \"node:util/types\",\n  \"@xmtp/content-type-group-updated\",\n  \"@xmtp/content-type-primitives\",\n  \"@xmtp/content-type-text\",\n  \"@xmtp/node-bindings\",\n  \"@xmtp/node-bindings/version.json\",\n];\n\nconst plugins = [\n  tsConfigPaths(),\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n  json({\n    preferConst: true,\n  }),\n];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: true,\n      importAttributesKey: \"with\",\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.d.ts\",\n      format: \"es\",\n    },\n    plugins: [tsConfigPaths(), dts()],\n  },\n]);\n",
      "size_bytes": 996
    },
    "sdks/agent-sdk/src/middleware/CommandRouter.ts": {
      "content": "import {\n  type AgentMessageHandler,\n  type AgentMiddleware,\n} from \"@/core/Agent.js\";\nimport { filter } from \"@/core/filter.js\";\nimport type { MessageContext } from \"@/core/MessageContext.js\";\n\nexport class CommandRouter<ContentTypes> {\n  private commandMap = new Map<string, AgentMessageHandler>();\n  private defaultHandler: AgentMessageHandler | null = null;\n\n  command(command: string, handler: AgentMessageHandler): this {\n    if (!command.startsWith(\"/\")) {\n      throw new Error('Command must start with \"/\"');\n    }\n    this.commandMap.set(command.toLowerCase(), handler);\n    return this;\n  }\n\n  default(handler: AgentMessageHandler): this {\n    this.defaultHandler = handler;\n    return this;\n  }\n\n  async handle(ctx: MessageContext): Promise<boolean> {\n    if (!filter.isText(ctx.message)) {\n      return false;\n    }\n\n    const messageText = ctx.message.content;\n    const parts = messageText.split(\" \");\n    const command = parts[0]?.toLowerCase();\n\n    if (!command) {\n      return false;\n    }\n\n    // Check if this is a command message\n    if (command.startsWith(\"/\")) {\n      const handler = this.commandMap.get(command);\n      if (handler) {\n        await handler(ctx);\n        return true;\n      }\n    }\n\n    // If no command matched and there's a default handler, use it\n    if (this.defaultHandler) {\n      await this.defaultHandler(ctx);\n      return true;\n    }\n\n    return false;\n  }\n\n  middleware: () => AgentMiddleware<ContentTypes> = () => async (ctx, next) => {\n    const handled = await this.handle(ctx);\n    if (!handled) {\n      await next();\n    }\n  };\n}\n",
      "size_bytes": 1587
    },
    "apps/xmtp.chat/src/components/Messages/TransactionReferenceContent.tsx": {
      "content": "import { Anchor, Box, Text } from \"@mantine/core\";\nimport type { TransactionReference } from \"@xmtp/content-type-transaction-reference\";\nimport { useMemo } from \"react\";\nimport * as viemChains from \"viem/chains\";\n\nexport type TransactionReferenceContentProps = {\n  content: TransactionReference;\n};\n\nexport const TransactionReferenceContent: React.FC<\n  TransactionReferenceContentProps\n> = ({ content }) => {\n  const chain = useMemo(() => {\n    const chains = Object.values(viemChains);\n    const chainId =\n      typeof content.networkId === \"string\"\n        ? parseInt(content.networkId, 16)\n        : content.networkId;\n    return chains.find((chain) => chain.id === chainId);\n  }, [content.networkId]);\n  if (!chain) {\n    return (\n      <Box>\n        <Text>Chain Id: {content.networkId}</Text>\n        <Text>Transaction Hash: {content.reference}</Text>\n      </Box>\n    );\n  }\n  return (\n    <Anchor\n      href={`${chain.blockExplorers?.default.url}/tx/${content.reference}`}\n      target=\"_blank\"\n      underline=\"hover\"\n      onClick={(event) => {\n        event.stopPropagation();\n      }}>\n      View in explorer\n    </Anchor>\n  );\n};\n",
      "size_bytes": 1143
    },
    "apps/xmtp.chat/src/helpers/names.ts": {
      "content": "import { Utils, type XmtpEnv } from \"@xmtp/browser-sdk\";\nimport { queryClient } from \"@/helpers/queries\";\nimport { isValidEthereumAddress } from \"@/helpers/strings\";\nimport { profilesStore, type Profile } from \"@/stores/profiles\";\n\nconst utils = new Utils();\n\nexport const isValidName = (name: string): name is string =>\n  /^_?[a-zA-Z0-9-]+(\\.base)?\\.eth$/.test(name);\n\nexport const resolveNameQuery = async (name: string) => {\n  return queryClient.fetchQuery({\n    queryKey: [\"resolveName\", name],\n    queryFn: () => resolveName(name),\n    // do not re-query the name for this session\n    staleTime: Infinity,\n    gcTime: Infinity,\n  });\n};\n\nexport const resolveName = async (name: string, force: boolean = false) => {\n  if (!isValidName(name)) {\n    return null;\n  }\n\n  // check cached profiles\n  const cachedProfiles = profilesStore.getState().getProfilesByName(name);\n  if (!force && cachedProfiles.length > 0) {\n    return cachedProfiles;\n  }\n\n  const response = await fetch(\n    `${import.meta.env.VITE_API_SERVICE_URL}/api/v2/resolve/name/${window.encodeURIComponent(name)}`,\n    {\n      method: \"GET\",\n    },\n  );\n\n  if (!response.ok) {\n    return cachedProfiles;\n  }\n\n  const data = (await response.json()) as { profiles: Profile[] };\n\n  if (data.profiles.length > 0) {\n    // cache the profiles\n    profilesStore.getState().addProfiles(data.profiles);\n  }\n\n  // return updated cached profiles\n  return profilesStore.getState().getProfilesByName(name);\n};\n\nexport const getInboxIdForAddressQuery = async (\n  address: string,\n  environment: XmtpEnv,\n) => {\n  return queryClient.fetchQuery({\n    queryKey: [\"getInboxIdForAddress\", address, environment],\n    queryFn: () => getInboxIdForAddress(address, environment),\n    // do not re-query the address for this session\n    staleTime: Infinity,\n    gcTime: Infinity,\n  });\n};\n\nexport const getInboxIdForAddress = async (\n  address: string,\n  environment: XmtpEnv,\n): Promise<string | undefined> => {\n  if (!isValidEthereumAddress(address)) {\n    return undefined;\n  }\n\n  const inboxId = await utils.getInboxIdForIdentifier(\n    {\n      identifier: address.toLowerCase(),\n      identifierKind: \"Ethereum\",\n    },\n    environment,\n  );\n\n  return inboxId;\n};\n",
      "size_bytes": 2212
    },
    "apps/xmtp.chat/src/globals.d.ts": {
      "content": "/// <reference types=\"vite/client\" />\n\ndeclare module \"*.module.css\" {\n  const classes: { [key: string]: string };\n  export default classes;\n}\n\ndeclare module \"*.png\" {\n  const src: string;\n  export default src;\n}\n\ninterface ImportMetaEnv {\n  readonly VITE_PROJECT_ID: string;\n  readonly VITE_PINATA_GATEWAY: string;\n  readonly VITE_API_SERVICE_URL: string;\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv;\n}\n",
      "size_bytes": 417
    },
    "content-types/content-type-read-receipt/src/ReadReceipt.ts": {
      "content": "import {\n  ContentTypeId,\n  type ContentCodec,\n} from \"@xmtp/content-type-primitives\";\n\nexport const ContentTypeReadReceipt = new ContentTypeId({\n  authorityId: \"xmtp.org\",\n  typeId: \"readReceipt\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\nexport type ReadReceipt = Record<string, never>;\n\nexport type ReadReceiptParameters = Record<string, never>;\n\nexport class ReadReceiptCodec\n  implements ContentCodec<ReadReceipt, ReadReceiptParameters>\n{\n  get contentType(): ContentTypeId {\n    return ContentTypeReadReceipt;\n  }\n\n  encode() {\n    return {\n      type: ContentTypeReadReceipt,\n      parameters: {},\n      content: new Uint8Array(),\n    };\n  }\n\n  decode(): ReadReceipt {\n    return {};\n  }\n\n  fallback(): string | undefined {\n    return undefined;\n  }\n\n  shouldPush() {\n    return false;\n  }\n}\n",
      "size_bytes": 800
    },
    "sdks/agent-sdk/src/user/index.ts": {
      "content": "export * from \"./User.js\";\nexport * from \"./NameResolver.js\";\n",
      "size_bytes": 62
    },
    "sdks/agent-sdk/src/core/MessageContext.ts": {
      "content": "import type { ContentCodec } from \"@xmtp/content-type-primitives\";\nimport {\n  ContentTypeReaction,\n  type Reaction,\n  type ReactionCodec,\n} from \"@xmtp/content-type-reaction\";\nimport type { RemoteAttachmentCodec } from \"@xmtp/content-type-remote-attachment\";\nimport {\n  ContentTypeReply,\n  type Reply,\n  type ReplyCodec,\n} from \"@xmtp/content-type-reply\";\nimport { ContentTypeText, type TextCodec } from \"@xmtp/content-type-text\";\nimport { filter, type DecodedMessageWithContent } from \"@/core/filter.js\";\nimport type { AgentBaseContext } from \"./Agent.js\";\nimport { ConversationContext } from \"./ConversationContext.js\";\n\nexport type MessageContextParams<ContentTypes = unknown> = Omit<\n  AgentBaseContext<ContentTypes>,\n  \"message\"\n> & {\n  message: DecodedMessageWithContent<ContentTypes>;\n};\n\nexport class MessageContext<\n  ContentTypes = unknown,\n> extends ConversationContext<ContentTypes> {\n  #message: DecodedMessageWithContent<ContentTypes>;\n\n  constructor({\n    message,\n    conversation,\n    client,\n  }: MessageContextParams<ContentTypes>) {\n    super({ conversation, client });\n    this.#message = message;\n  }\n\n  usesCodec<T extends ContentCodec>(\n    codecClass: new () => T,\n  ): this is MessageContext<ReturnType<T[\"decode\"]>> {\n    return (\n      this.#message.contentType?.sameAs(new codecClass().contentType) || false\n    );\n  }\n\n  isText(): this is MessageContext<ReturnType<TextCodec[\"decode\"]>> {\n    return filter.isText(this.#message);\n  }\n\n  isReply(): this is MessageContext<ReturnType<ReplyCodec[\"decode\"]>> {\n    return filter.isReply(this.#message);\n  }\n\n  isReaction(): this is MessageContext<ReturnType<ReactionCodec[\"decode\"]>> {\n    return filter.isReaction(this.#message);\n  }\n\n  isRemoteAttachment(): this is MessageContext<\n    ReturnType<RemoteAttachmentCodec[\"decode\"]>\n  > {\n    return filter.isRemoteAttachment(this.#message);\n  }\n\n  async sendReaction(content: string, schema: Reaction[\"schema\"] = \"unicode\") {\n    const reaction: Reaction = {\n      action: \"added\",\n      reference: this.#message.id,\n      referenceInboxId: this.#message.senderInboxId,\n      schema,\n      content,\n    };\n    await this.conversation.send(reaction, ContentTypeReaction);\n  }\n\n  async sendText(text: string): Promise<void> {\n    await this.conversation.send(text, ContentTypeText);\n  }\n\n  async sendTextReply(text: string) {\n    const reply: Reply = {\n      reference: this.#message.id,\n      referenceInboxId: this.#message.senderInboxId,\n      contentType: ContentTypeText,\n      content: text,\n    };\n    await this.conversation.send(reply, ContentTypeReply);\n  }\n\n  async getSenderAddress() {\n    const inboxState = await this.client.preferences.inboxStateFromInboxIds([\n      this.#message.senderInboxId,\n    ]);\n    return inboxState[0]?.identifiers[0]?.identifier;\n  }\n\n  get message() {\n    return this.#message;\n  }\n}\n",
      "size_bytes": 2852
    },
    "apps/xmtp.chat/src/components/App/Connect.tsx": {
      "content": "import { Stepper } from \"@mantine/core\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport { useLocation, useNavigate } from \"react-router\";\nimport { ConnectXMTP } from \"@/components/App/ConnectXMTP\";\nimport { WalletConnect } from \"@/components/App/WalletConnect\";\nimport { useXMTP } from \"@/contexts/XMTPContext\";\nimport { useConnectWallet } from \"@/hooks/useConnectWallet\";\nimport { useRedirect } from \"@/hooks/useRedirect\";\nimport { useSettings } from \"@/hooks/useSettings\";\n\nexport const Connect = () => {\n  const { isConnected, disconnect, loading } = useConnectWallet();\n  const {\n    ephemeralAccountEnabled,\n    setEphemeralAccountEnabled,\n    setAutoConnect,\n  } = useSettings();\n  const { client } = useXMTP();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const { redirectUrl, setRedirectUrl } = useRedirect();\n  const [active, setActive] = useState(0);\n\n  // redirect if there's already a client\n  useEffect(() => {\n    if (!client) {\n      return;\n    }\n    if (redirectUrl) {\n      setRedirectUrl(\"\");\n      void navigate(redirectUrl);\n      return;\n    }\n    if (location.pathname === \"/welcome\") {\n      void navigate(\"/conversations\");\n    }\n  }, [client, redirectUrl, location.pathname, navigate, setRedirectUrl]);\n\n  useEffect(() => {\n    if (isConnected || ephemeralAccountEnabled) {\n      setActive(1);\n    } else {\n      setActive(0);\n    }\n  }, [isConnected, ephemeralAccountEnabled]);\n\n  const handleDisconnectWallet = useCallback(() => {\n    if (isConnected) {\n      disconnect();\n    } else {\n      setEphemeralAccountEnabled(false);\n    }\n    setAutoConnect(false);\n  }, [isConnected, disconnect]);\n\n  return (\n    <Stepper active={active} onStepClick={setActive}>\n      <Stepper.Step\n        label=\"Connect your wallet\"\n        allowStepSelect={false}\n        loading={loading}>\n        <WalletConnect />\n      </Stepper.Step>\n      <Stepper.Step label=\"Connect to MMCT (MumbleChat)\" allowStepSelect={false}>\n        <ConnectXMTP onDisconnectWallet={handleDisconnectWallet} />\n      </Stepper.Step>\n    </Stepper>\n  );\n};\n",
      "size_bytes": 2089
    },
    "content-types/content-type-text/src/Text.test.ts": {
      "content": "import { describe, expect, it } from \"vitest\";\nimport { ContentTypeText, Encoding, TextCodec } from \"./Text\";\n\ndescribe(\"ContentTypeText\", () => {\n  it(\"can encode/decode text\", () => {\n    const text = \"Hey\";\n    const codec = new TextCodec();\n    const ec = codec.encode(text);\n    expect(ec.type.sameAs(ContentTypeText)).toBe(true);\n    expect(ec.parameters.encoding).toEqual(Encoding.utf8);\n    const text2 = codec.decode(ec);\n    expect(text2).toEqual(text);\n  });\n\n  it(\"defaults to utf-8\", () => {\n    const text = \"Hey\";\n    const codec = new TextCodec();\n    const ec = codec.encode(text);\n    expect(ec.type.sameAs(ContentTypeText)).toBe(true);\n    expect(ec.parameters.encoding).toEqual(Encoding.utf8);\n    const text2 = codec.decode(ec);\n    expect(text2).toEqual(text);\n  });\n\n  it(\"throws on invalid input\", () => {\n    const codec = new TextCodec();\n    const ec = {\n      type: ContentTypeText,\n      parameters: {\n        encoding: Encoding.utf8,\n      },\n      content: {} as Uint8Array,\n    };\n    expect(() => codec.decode(ec)).toThrow();\n  });\n\n  it(\"throws on unknown encoding\", () => {\n    const codec = new TextCodec();\n    const ec = {\n      type: ContentTypeText,\n      parameters: { encoding: \"UTF-16\" } as unknown as { encoding: Encoding },\n      content: new Uint8Array(0),\n    };\n    expect(() => codec.decode(ec)).toThrow(\"unrecognized encoding UTF-16\");\n  });\n});\n",
      "size_bytes": 1396
    },
    "dev/uploadService/index.js": {
      "content": "const fs = require(\"fs\");\nconst https = require(\"https\");\nconst express = require(\"express\");\nconst bodyParser = require(\"body-parser\");\nconst app = express();\nconst port = 3000;\n\nconst key = fs.readFileSync(\"key.pem\", \"utf-8\");\nconst cert = fs.readFileSync(\"cert.pem\", \"utf-8\");\n\nconst UPLOADS = {};\n\napp.use(bodyParser.raw({ type: \"application/octet-stream\" }));\n\napp.get(\"/:path\", (req, res) => {\n  const path = req.params.path;\n  console.log(`GET /${path}`);\n  const file = UPLOADS[path];\n  if (file) {\n    res.header(\"Content-Type\", \"application/octet-stream\");\n    res.send(file);\n  } else {\n    console.log(`Upload path found: ${path}`);\n  }\n});\n\napp.post(\"/:path\", (req, res) => {\n  const path = req.params.path;\n  console.log(`POST /${path}`);\n  UPLOADS[path] = req.body;\n  res.sendStatus(200);\n});\n\nhttps.createServer({ key, cert }, app).listen(port, () => {\n  console.log(`Upload service listening on port ${port}`);\n});\n",
      "size_bytes": 932
    },
    "CLAUDE.md": {
      "content": "# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Project Overview\n\nXMTP-JS is a monorepo containing TypeScript SDKs and content types for XMTP messaging protocol. It includes browser and Node.js SDKs, various content types for different message formats, and example applications.\n\n## Repository Structure\n\n- `sdks/` - Client SDKs for different environments\n  - `browser-sdk/` - XMTP client SDK for browsers (uses Web Workers)\n  - `node-sdk/` - XMTP client SDK for Node.js\n- `content-types/` - Message content type packages (text, reactions, attachments, etc.)\n- `apps/` - Example applications\n  - `xmtp.chat/` - React chat application demo\n- `dev/` - Development environment setup (Docker compose)\n\n## Development Commands\n\n### Essential Commands\n\n- `yarn` - Install dependencies\n- `yarn build` - Build all packages using Turbo\n- `yarn test` - Run all tests across workspaces\n- `yarn lint` - Lint code (requires build first)\n- `yarn typecheck` - TypeScript type checking\n- `yarn format` - Format code with Prettier\n- `yarn clean` - Remove all build artifacts and dependencies\n- `yarn reset` - Full clean and rebuild\n\n### Testing Setup\n\n- `yarn test:setup` - Start local XMTP node via Docker (run once)\n- `yarn test:teardown` - Stop local XMTP node\n\n### Individual Package Commands\n\nNavigate to specific package directories to run:\n\n- `yarn test` - Run package tests (uses Vitest)\n- `yarn build` - Build specific package\n- `yarn dev` - Watch mode for development\n\n## Architecture\n\n### Core Components\n\n- **Client**: Main entry point for XMTP operations, handles authentication and configuration\n- **Conversations**: Manages DMs and group conversations\n- **DecodedMessage**: Represents messages with content type handling\n- **Content Types**: Extensible system for different message formats (text, reactions, attachments, etc.)\n\n### SDK Differences\n\n- **Browser SDK**: Uses Web Workers for performance, includes worker-specific classes (WorkerClient, WorkerConversation)\n- **Node SDK**: Direct bindings, includes utility scripts for account/group generation\n\n### Content Type System\n\nContent types define how different message formats are encoded/decoded:\n\n- Primitives package provides base interfaces\n- Each content type (text, reaction, reply, etc.) is a separate package\n- Custom content types can be registered with clients\n\n## Technology Stack\n\n- **Build System**: Turbo monorepo with Rollup bundling\n- **Testing**: Vitest with coverage via V8\n- **Linting**: ESLint 9 with TypeScript integration\n- **Formatting**: Prettier with import sorting\n- **Package Management**: Yarn 4 with workspaces\n- **TypeScript**: v5.8+ with strict configuration\n\n## Development Guidelines\n\n### Code Style (from .cursor/rules)\n\n- Use ES modules exclusively\n- Favor named exports over default exports\n- Use type inference where possible, avoid enums\n- Prefer `unknown` over `any`\n- Use early returns to reduce nesting\n- Write comprehensive tests for new features\n- Document with JSDoc comments\n\n### Testing Requirements\n\n- Unit tests must pass before PRs\n- Some tests require local XMTP node (use `yarn test:setup`)\n- Browser SDK tests run in browser environment via Vitest + Playwright\n- Node SDK tests run in Node environment\n\n### Publishing\n\n- Uses Changesets for version management\n- PRs require changeset for publishing\n- Changesets bot guides through process\n",
      "size_bytes": 3418
    },
    "content-types/content-type-transaction-reference/src/TransactionReference.test.ts": {
      "content": "import { Client, IdentifierKind, type Signer } from \"@xmtp/node-sdk\";\nimport { createWalletClient, http, toBytes } from \"viem\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { sepolia } from \"viem/chains\";\nimport {\n  ContentTypeTransactionReference,\n  TransactionReferenceCodec,\n  type TransactionReference,\n} from \"./TransactionReference\";\n\nexport const createSigner = (): Signer => {\n  const account = privateKeyToAccount(generatePrivateKey());\n  const wallet = createWalletClient({\n    account,\n    chain: sepolia,\n    transport: http(),\n  });\n  return {\n    type: \"EOA\",\n    getIdentifier: () => ({\n      identifierKind: IdentifierKind.Ethereum,\n      identifier: account.address.toLowerCase(),\n    }),\n    signMessage: async (message: string) => {\n      const signature = await wallet.signMessage({\n        message,\n      });\n      return toBytes(signature);\n    },\n  };\n};\n\ntest(\"content type exists\", () => {\n  expect(ContentTypeTransactionReference.authorityId).toBe(\"xmtp.org\");\n  expect(ContentTypeTransactionReference.typeId).toBe(\"transactionReference\");\n  expect(ContentTypeTransactionReference.versionMajor).toBe(1);\n  expect(ContentTypeTransactionReference.versionMinor).toBe(0);\n});\n\ntest(\"should successfully send and receive a TransactionReference message\", async () => {\n  const signer1 = createSigner();\n  const client1 = await Client.create(signer1, {\n    codecs: [new TransactionReferenceCodec()],\n    env: \"local\",\n  });\n\n  const signer2 = createSigner();\n  const client2 = await Client.create(signer2, {\n    codecs: [new TransactionReferenceCodec()],\n    env: \"local\",\n  });\n\n  const dm = await client1.conversations.newDm(client2.inboxId);\n\n  const transactionRefToSend: TransactionReference = {\n    namespace: \"eip155\",\n    networkId: \"0x14a33\",\n    reference:\n      \"0xa7cd32b79204559e46b4ef9b519fce58cedb25246f48d0c00bd628e873a81f2f\",\n    metadata: {\n      transactionType: \"transfer\",\n      currency: \"USDC\",\n      amount: 1337,\n      decimals: 6,\n      fromAddress: (await signer1.getIdentifier()).identifier,\n      toAddress: (await signer2.getIdentifier()).identifier,\n    },\n  };\n\n  await dm.send(transactionRefToSend, ContentTypeTransactionReference);\n\n  await client2.conversations.sync();\n  const dms = client2.conversations.listDms();\n\n  expect(dms.length).toBe(1);\n\n  await dms[0].sync();\n  const messages = await dms[0].messages();\n  expect(messages.length).toBe(2);\n\n  const message = messages[1];\n  const messageContent = message.content as TransactionReference;\n\n  expect(messageContent.namespace).toBe(transactionRefToSend.namespace);\n  expect(messageContent.networkId).toBe(transactionRefToSend.networkId);\n  expect(messageContent.reference).toBe(transactionRefToSend.reference);\n  expect(messageContent.metadata).toEqual(transactionRefToSend.metadata);\n});\n\ntest(\"has a proper shouldPush value\", () => {\n  const codec = new TransactionReferenceCodec();\n  expect(codec.shouldPush()).toBe(true);\n});\n",
      "size_bytes": 2977
    },
    "content-types/content-type-primitives/src/index.test.ts": {
      "content": "import { describe, expect, it } from \"vitest\";\nimport { ContentTypeId } from \".\";\n\ndescribe(\"ContentTypeId\", () => {\n  it(\"creates a new content type\", () => {\n    const contentType = new ContentTypeId({\n      authorityId: \"foo\",\n      typeId: \"bar\",\n      versionMajor: 1,\n      versionMinor: 0,\n    });\n    expect(contentType.authorityId).toEqual(\"foo\");\n    expect(contentType.typeId).toEqual(\"bar\");\n    expect(contentType.versionMajor).toEqual(1);\n    expect(contentType.versionMinor).toEqual(0);\n  });\n\n  it(\"creates a string from a content type\", () => {\n    const contentType = new ContentTypeId({\n      authorityId: \"foo\",\n      typeId: \"bar\",\n      versionMajor: 1,\n      versionMinor: 0,\n    });\n    expect(contentType.toString()).toEqual(\"foo/bar:1.0\");\n  });\n\n  it(\"creates a content type from a string\", () => {\n    const contentType = ContentTypeId.fromString(\"foo/bar:1.0\");\n    expect(contentType.authorityId).toEqual(\"foo\");\n    expect(contentType.typeId).toEqual(\"bar\");\n    expect(contentType.versionMajor).toEqual(1);\n    expect(contentType.versionMinor).toEqual(0);\n  });\n\n  it(\"compares two content types\", () => {\n    const contentType1 = new ContentTypeId({\n      authorityId: \"foo\",\n      typeId: \"bar\",\n      versionMajor: 1,\n      versionMinor: 0,\n    });\n    const contentType2 = new ContentTypeId({\n      authorityId: \"baz\",\n      typeId: \"qux\",\n      versionMajor: 1,\n      versionMinor: 0,\n    });\n    expect(contentType1.sameAs(contentType2)).toBe(false);\n    expect(contentType1.sameAs(contentType1)).toBe(true);\n  });\n});\n",
      "size_bytes": 1557
    },
    "sdks/browser-sdk/src/utils/signer.ts": {
      "content": "import type { Identifier } from \"@xmtp/wasm-bindings\";\n\nexport type SignMessage = (message: string) => Promise<Uint8Array> | Uint8Array;\nexport type GetIdentifier = () => Promise<Identifier> | Identifier;\nexport type GetChainId = () => bigint;\nexport type GetBlockNumber = () => bigint;\n\nexport type Signer =\n  | {\n      type: \"EOA\";\n      getIdentifier: GetIdentifier;\n      signMessage: SignMessage;\n    }\n  | {\n      type: \"SCW\";\n      getIdentifier: GetIdentifier;\n      signMessage: SignMessage;\n      getBlockNumber?: GetBlockNumber;\n      getChainId: GetChainId;\n    };\n\nexport type EOASigner = Extract<Signer, { type: \"EOA\" }>;\nexport type SCWSigner = Extract<Signer, { type: \"SCW\" }>;\n\nexport type SafeSigner =\n  | {\n      type: \"EOA\";\n      identifier: Identifier;\n      signature: Uint8Array;\n    }\n  | {\n      type: \"SCW\";\n      identifier: Identifier;\n      signature: Uint8Array;\n      chainId: bigint;\n      blockNumber?: bigint;\n    };\n\nexport const toSafeSigner = async (\n  signer: Signer,\n  signature: Uint8Array,\n): Promise<SafeSigner> => {\n  switch (signer.type) {\n    case \"EOA\":\n      return {\n        type: \"EOA\",\n        identifier: await signer.getIdentifier(),\n        signature,\n      };\n    case \"SCW\":\n      return {\n        type: \"SCW\",\n        identifier: await signer.getIdentifier(),\n        signature,\n        chainId: signer.getChainId(),\n        blockNumber: signer.getBlockNumber?.(),\n      };\n  }\n};\n",
      "size_bytes": 1438
    },
    "sdks/agent-sdk/src/debug/log.ts": {
      "content": "import { Client } from \"@xmtp/node-sdk\";\n\nexport const logDetails = async <ContentTypes>(\n  client: Client<ContentTypes>,\n) => {\n  const xmtp = `\\x1b[38;2;252;76;52m\n    ██╗  ██╗███╗   ███╗████████╗██████╗ \n    ╚██╗██╔╝████╗ ████║╚══██╔══╝██╔══██╗\n     ╚███╔╝ ██╔████╔██║   ██║   ██████╔╝\n     ██╔██╗ ██║╚██╔╝██║   ██║   ██╔═══╝ \n    ██╔╝ ██╗██║ ╚═╝ ██║   ██║   ██║     \n    ╚═╝  ╚═╝╚═╝     ╚═╝   ╚═╝   ╚═╝     \n  \\x1b[0m`;\n\n  const clientsByAddress = client.accountIdentifier?.identifier;\n  const inboxId = client.inboxId;\n  const installationId = client.installationId;\n  const environments = client.options?.env ?? \"dev\";\n\n  const urls = [`http://xmtp.chat/dm/${clientsByAddress}`];\n\n  const conversations = await client.conversations.list();\n  const inboxState = await client.preferences.inboxState();\n  const keyPackageStatuses =\n    await client.getKeyPackageStatusesForInstallationIds([installationId]);\n\n  let createdDate = new Date();\n  let expiryDate = new Date();\n\n  // Extract key package status for the specific installation\n  const keyPackageStatus = keyPackageStatuses[installationId] ?? {};\n  if (keyPackageStatus.lifetime) {\n    createdDate = new Date(Number(keyPackageStatus.lifetime.notBefore) * 1000);\n    expiryDate = new Date(Number(keyPackageStatus.lifetime.notAfter) * 1000);\n  }\n  console.log(`\n    ${xmtp}\n    \n    ✓ XMTP Client:\n    • InboxId: ${inboxId}\n    • Version: ${Client.version}\n    • Address: ${clientsByAddress}\n    • Conversations: ${conversations.length}\n    • Installations: ${inboxState.installations.length}\n    • InstallationId: ${installationId}\n    • Key Package created: ${createdDate.toLocaleString()}\n    • Key Package valid until: ${expiryDate.toLocaleString()}\n    • Networks: ${environments}\n    ${urls.map((url) => `• URL: ${url}`).join(\"\\n\")}`);\n};\n\n/**\n * Returns a URL to test your agent on https://xmtp.chat/ (for development purposes only).\n *\n * @param client - Your XMTP client\n * @returns The URL to test your agent with\n */\nexport const getTestUrl = <ContentTypes>(client: Client<ContentTypes>) => {\n  const address = client.accountIdentifier?.identifier;\n  const env = client.options?.env ?? \"dev\";\n  return `http://xmtp.chat/dm/${address}?env=${env}`;\n};\n\ntype InstallationInfo = {\n  totalInstallations: number;\n  installationId: string;\n  mostRecentInstallationId: null | string;\n  isMostRecent: boolean;\n};\n\nexport const getInstallationInfo = async <ContentTypes>(\n  client: Client<ContentTypes>,\n): Promise<InstallationInfo> => {\n  const myInboxId = client.inboxId;\n  const myInstallationId = client.installationId;\n\n  const inboxStates = await Client.inboxStateFromInboxIds(\n    [myInboxId],\n    client.options?.env,\n  );\n\n  const installations =\n    inboxStates.find((state) => state.inboxId === myInboxId)?.installations ||\n    [];\n\n  const sortedInstallations = [...installations].sort((a, b) => {\n    const aTime = a.clientTimestampNs ?? 0n;\n    const bTime = b.clientTimestampNs ?? 0n;\n    return bTime > aTime ? 1 : bTime < aTime ? -1 : 0;\n  });\n\n  const mostRecentInstallation = sortedInstallations[0];\n\n  const myInstallationIdHex = Buffer.from(client.installationIdBytes).toString(\n    \"hex\",\n  );\n\n  const info: InstallationInfo = {\n    totalInstallations: installations.length,\n    installationId: myInstallationId,\n    mostRecentInstallationId: null,\n    isMostRecent: false,\n  };\n\n  if (mostRecentInstallation) {\n    const mostRecentIdHex = Buffer.from(mostRecentInstallation.bytes).toString(\n      \"hex\",\n    );\n    info.mostRecentInstallationId = mostRecentIdHex;\n    info.isMostRecent = myInstallationIdHex === mostRecentIdHex;\n  }\n\n  return info;\n};\n",
      "size_bytes": 3977
    },
    "apps/xmtp.chat/src/components/LoadingMessage.tsx": {
      "content": "import { Loader, LoadingOverlay, Stack, Text } from \"@mantine/core\";\n\nexport type LoadingMessageProps = {\n  message: string;\n};\n\nexport const LoadingMessage: React.FC<LoadingMessageProps> = ({ message }) => {\n  return (\n    <LoadingOverlay\n      visible={true}\n      loaderProps={{\n        children: (\n          <Stack gap=\"xs\" justify=\"center\" align=\"center\">\n            <Loader />\n            <Text>{message}</Text>\n          </Stack>\n        ),\n      }}\n    />\n  );\n};\n",
      "size_bytes": 473
    },
    "apps/xmtp.chat-api-service/src/middleware/error.ts": {
      "content": "import type { NextFunction, Request, Response } from \"express\";\n\nexport const errorMiddleware = (\n  err: Error,\n  _req: Request,\n  res: Response,\n  _next: NextFunction,\n): void => {\n  console.error(err);\n  res.status(500).json({\n    error: {\n      name: err.name,\n      message: err.message,\n    },\n  });\n};\n",
      "size_bytes": 308
    },
    "apps/xmtp.chat/src/components/Identity.tsx": {
      "content": "import { type MantineStyleProps } from \"@mantine/core\";\nimport {\n  MemberPopover,\n  type MemberPopoverProps,\n} from \"@/components/Conversation/MemberPopover\";\nimport {\n  IdentityBadge,\n  type IdentityBadgeProps,\n} from \"@/components/IdentityBadge\";\n\nexport type IdentityProps = MemberPopoverProps &\n  Pick<IdentityBadgeProps, \"size\"> & {} & Pick<MantineStyleProps, \"w\">;\n\nexport const Identity: React.FC<IdentityProps> = ({\n  size = \"lg\",\n  w,\n  ...props\n}) => {\n  return (\n    <MemberPopover {...props}>\n      <IdentityBadge\n        address={props.address}\n        displayName={props.displayName}\n        size={size}\n        w={w}\n      />\n    </MemberPopover>\n  );\n};\n",
      "size_bytes": 670
    },
    "content-types/content-type-transaction-reference/src/TransactionReference.ts": {
      "content": "import {\n  ContentTypeId,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\n\nexport const ContentTypeTransactionReference = new ContentTypeId({\n  authorityId: \"xmtp.org\",\n  typeId: \"transactionReference\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\nexport type TransactionReference = {\n  /**\n   * The namespace for the networkId\n   */\n  namespace?: string;\n  /**\n   * The networkId for the transaction, in decimal or hexidecimal format\n   */\n  networkId: number | string;\n  /**\n   * The transaction hash\n   */\n  reference: string;\n  /**\n   * Optional metadata object\n   */\n  metadata?: {\n    transactionType: string;\n    currency: string;\n    amount: number;\n    decimals: number;\n    fromAddress: string;\n    toAddress: string;\n  };\n};\n\nexport class TransactionReferenceCodec\n  implements ContentCodec<TransactionReference>\n{\n  get contentType(): ContentTypeId {\n    return ContentTypeTransactionReference;\n  }\n\n  encode(content: TransactionReference): EncodedContent {\n    const encoded = {\n      type: ContentTypeTransactionReference,\n      parameters: {},\n      content: new TextEncoder().encode(JSON.stringify(content)),\n    };\n    return encoded;\n  }\n\n  decode(encodedContent: EncodedContent): TransactionReference {\n    const uint8Array = encodedContent.content;\n    const contentReceived = JSON.parse(\n      new TextDecoder().decode(uint8Array),\n    ) as TransactionReference;\n    return contentReceived;\n  }\n\n  fallback(content: TransactionReference): string | undefined {\n    if (content.reference) {\n      return `[Crypto transaction] Use a blockchain explorer to learn more using the transaction hash: ${content.reference}`;\n    }\n    return `Crypto transaction`;\n  }\n\n  shouldPush() {\n    return true;\n  }\n}\n",
      "size_bytes": 1754
    },
    "apps/xmtp.chat/src/components/Conversation/ReplyPreview.tsx": {
      "content": "import { ActionIcon, Box, Group, Paper, Text } from \"@mantine/core\";\nimport type { DecodedMessage } from \"@xmtp/browser-sdk\";\nimport { IdentityBadge } from \"@/components/IdentityBadge\";\nimport { AttachmentDetails } from \"@/components/Messages/AttachmentDetails\";\nimport { BreakableText } from \"@/components/Messages/BreakableText\";\nimport { useConversationContext } from \"@/contexts/ConversationContext\";\nimport { formatFileSize } from \"@/helpers/attachment\";\nimport { isRemoteAttachment, stringify } from \"@/helpers/messages\";\nimport { MEMBER_NO_LONGER_IN_GROUP } from \"@/helpers/strings\";\nimport { getMemberAddress } from \"@/helpers/xmtp\";\nimport { useConversation } from \"@/hooks/useConversation\";\nimport { IconArrowBackUp } from \"@/icons/IconArrowBackUp\";\nimport { IconX } from \"@/icons/IconX\";\n\nexport type ReplyPreviewProps = {\n  message: DecodedMessage;\n  onCancel: () => void;\n  disabled?: boolean;\n};\n\nconst ReplyPreviewContent: React.FC<Pick<ReplyPreviewProps, \"message\">> = ({\n  message,\n}) => {\n  if (isRemoteAttachment(message)) {\n    return (\n      <AttachmentDetails\n        filename={message.content.filename}\n        fileSize={formatFileSize(message.content.contentLength)}\n        align=\"left\"\n      />\n    );\n  }\n  return (\n    <BreakableText mt={6} fw={700} size=\"sm\" lineClamp={2}>\n      {stringify(message)}\n    </BreakableText>\n  );\n};\n\nexport const ReplyPreview: React.FC<ReplyPreviewProps> = ({\n  message,\n  onCancel,\n  disabled,\n}) => {\n  const { conversationId } = useConversationContext();\n  const { members } = useConversation(conversationId);\n  const fromMember = members.get(message.senderInboxId);\n  return (\n    <>\n      <Box miw=\"0\">\n        <Paper p=\"xs\" radius=\"sm\" withBorder>\n          <Group gap={6} align=\"center\" w=\"100%\" miw={0}>\n            <IconArrowBackUp color=\"var(--mantine-color-dimmed)\" />\n            <Text size=\"sm\" c=\"dimmed\">\n              Replying to\n            </Text>\n            <Box>\n              <IdentityBadge\n                address={fromMember ? getMemberAddress(fromMember) : \"\"}\n                displayName={message.senderInboxId}\n                tooltip={fromMember ? undefined : MEMBER_NO_LONGER_IN_GROUP}\n              />\n            </Box>\n          </Group>\n          <ReplyPreviewContent message={message} />\n        </Paper>\n      </Box>\n      <Box style={{ alignSelf: \"start\" }}>\n        <ActionIcon\n          aria-label=\"Cancel reply\"\n          variant=\"light\"\n          radius=\"xl\"\n          onClick={onCancel}\n          disabled={disabled}>\n          <IconX size={18} />\n        </ActionIcon>\n      </Box>\n    </>\n  );\n};\n",
      "size_bytes": 2600
    },
    "apps/xmtp.chat-api-service/README.md": {
      "content": "# xmtp.chat API service\n\nThis package contains code for the xmtp.chat API service.\n\n### Get started\n\n#### Setup environment\n\nCopy `.env.example` to `.env` and fill in the proper values.\n\n#### Run the app locally\n\n```bash\n# Run the app in watch mode\nyarn dev\n```\n\n#### Run the app locally with Docker\n\n```bash\n# Build the Docker image\ndocker build -t \"xmtp-chat-api-service\" .\n\n# Run the Docker container\ndocker run --env-file .env -d -p 4000:4000 xmtp-chat-api-service\n```\n\nAdjust the `-p 4000:4000` flag to match the port in the `.env` file. The default port is `4000`.\n",
      "size_bytes": 571
    },
    "apps/xmtp.chat/src/hooks/useConversation.ts": {
      "content": "import type { ContentTypeId } from \"@xmtp/content-type-primitives\";\nimport { useState } from \"react\";\nimport { type ContentTypes } from \"@/contexts/XMTPContext\";\nimport {\n  useActions,\n  useConversation as useConversationState,\n  useLastSentAt,\n  useMembers,\n  useMessages,\n  useMetadata,\n  usePermissions,\n} from \"@/stores/inbox/hooks\";\n\nexport const useConversation = (conversationId: string) => {\n  const { addMessages } = useActions();\n  const conversation = useConversationState(conversationId);\n  const members = useMembers(conversationId);\n  const permissions = usePermissions(conversationId);\n  const { name, description, imageUrl } = useMetadata(conversationId);\n  const messages = useMessages(conversationId);\n  const lastSentAt = useLastSentAt(conversationId);\n  const [loading, setLoading] = useState(false);\n  const [syncing, setSyncing] = useState(false);\n  const [sending, setSending] = useState(false);\n\n  if (!conversation) {\n    throw new Error(\n      `useConversation: Conversation ${conversationId} not found`,\n    );\n  }\n\n  const sync = async (fromNetwork: boolean = false) => {\n    if (fromNetwork) {\n      setSyncing(true);\n\n      try {\n        const isActive = await conversation.isActive();\n        // ensure group is active before syncing\n        if (isActive) {\n          await conversation.sync();\n        }\n      } finally {\n        setSyncing(false);\n      }\n    }\n\n    setLoading(true);\n\n    try {\n      const msgs = await conversation.messages({\n        sentAfterNs: lastSentAt,\n      });\n      await addMessages(conversation.id, msgs);\n      return msgs;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const send = async (message: ContentTypes, contentType?: ContentTypeId) => {\n    setSending(true);\n\n    try {\n      await conversation.send(message, contentType);\n    } finally {\n      setSending(false);\n    }\n  };\n\n  return {\n    conversation,\n    description,\n    imageUrl,\n    loading,\n    members,\n    messages,\n    name,\n    permissions,\n    send,\n    sending,\n    sync,\n    syncing,\n  };\n};\n",
      "size_bytes": 2040
    },
    "content-types/content-type-remote-attachment/src/index.ts": {
      "content": "export * from \"./Attachment\";\nexport * from \"./RemoteAttachment\";\n",
      "size_bytes": 66
    },
    "apps/xmtp.chat/src/components/Conversations/ConversationsNavbar.tsx": {
      "content": "import { Badge, Box, Group, Text } from \"@mantine/core\";\nimport { useCallback, useEffect, useRef } from \"react\";\nimport { ConversationsList } from \"@/components/Conversations/ConversationList\";\nimport { ConversationsMenu } from \"@/components/Conversations/ConversationsMenu\";\nimport { useConversations } from \"@/hooks/useConversations\";\nimport { ContentLayout } from \"@/layouts/ContentLayout\";\nimport classes from \"./ConversationsNavbar.module.css\";\n\nexport const ConversationsNavbar: React.FC = () => {\n  const {\n    sync,\n    loading,\n    syncing,\n    conversations,\n    stream,\n    streamAllMessages,\n    syncAll,\n  } = useConversations();\n  const stopConversationStreamRef = useRef<(() => void) | null>(null);\n  const stopAllMessagesStreamRef = useRef<(() => void) | null>(null);\n\n  const startStreams = useCallback(async () => {\n    stopConversationStreamRef.current = await stream();\n    stopAllMessagesStreamRef.current = await streamAllMessages();\n  }, [stream, streamAllMessages]);\n\n  const stopStreams = useCallback(() => {\n    stopConversationStreamRef.current?.();\n    stopConversationStreamRef.current = null;\n    stopAllMessagesStreamRef.current?.();\n    stopAllMessagesStreamRef.current = null;\n  }, []);\n\n  const handleSync = useCallback(async () => {\n    stopStreams();\n    await sync();\n    await startStreams();\n  }, [sync, startStreams, stopStreams]);\n\n  const handleSyncAll = useCallback(async () => {\n    stopStreams();\n    await syncAll();\n    await startStreams();\n  }, [syncAll, startStreams, stopStreams]);\n\n  // loading conversations on mount, and start streaming\n  useEffect(() => {\n    const loadConversations = async () => {\n      await sync(true);\n      await startStreams();\n    };\n    void loadConversations();\n  }, []);\n\n  // stop streaming on unmount\n  useEffect(() => {\n    return () => {\n      stopStreams();\n    };\n  }, []);\n\n  return (\n    <ContentLayout\n      className={classes.shell}\n      headerClassName={classes.header}\n      contentClassName={classes.content}\n      title={\n        <Group align=\"center\" gap=\"sm\">\n          <Text size=\"lg\" fw={700} c=\"var(--mantine-color-gray-0)\">\n            Conversations\n          </Text>\n          <Badge\n            radius=\"md\"\n            size=\"lg\"\n            variant=\"light\"\n            style={{\n              background: \"rgba(10, 255, 241, 0.16)\",\n              color: \"#0afff1\",\n              border: \"1px solid rgba(10, 255, 241, 0.28)\",\n            }}>\n            {conversations.length}\n          </Badge>\n        </Group>\n      }\n      loading={conversations.length === 0 && loading}\n      headerActions={\n        <ConversationsMenu\n          loading={syncing || loading}\n          onSync={() => void handleSync()}\n          onSyncAll={() => void handleSyncAll()}\n          disabled={syncing}\n        />\n      }\n      withScrollArea={false}>\n      {conversations.length === 0 ? (\n        <Box\n          display=\"flex\"\n          style={{\n            flexGrow: 1,\n            alignItems: \"center\",\n            justifyContent: \"center\",\n          }}\n          className={classes.empty}>\n          <Text>No conversations found</Text>\n        </Box>\n      ) : (\n        <ConversationsList conversations={conversations} />\n      )}\n    </ContentLayout>\n  );\n};\n",
      "size_bytes": 3250
    },
    "content-types/content-type-reply/vitest.setup.ts": {
      "content": "import { unlink } from \"node:fs/promises\";\nimport { dirname, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { glob } from \"fast-glob\";\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nexport const teardown = async () => {\n  const files = await glob(\"**/*.db3*\", { cwd: __dirname });\n  await Promise.all(files.map((file) => unlink(join(__dirname, file))));\n};\n",
      "size_bytes": 398
    },
    "apps/xmtp.chat/src/components/App/NetworkSelect.tsx": {
      "content": "import { Group, NativeSelect, Stack, Text, Tooltip } from \"@mantine/core\";\nimport { ApiUrls, type XmtpEnv } from \"@xmtp/browser-sdk\";\nimport { useSettings } from \"@/hooks/useSettings\";\n\nexport const NetworkSelect: React.FC = () => {\n  const { environment, setEnvironment } = useSettings();\n\n  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {\n    setEnvironment(event.currentTarget.value as XmtpEnv);\n  };\n\n  return (\n    <Stack gap=\"xs\">\n      <Group gap=\"xs\" justify=\"space-between\">\n        <Text fw=\"bold\" size=\"lg\">\n          Network\n        </Text>\n        <Tooltip\n          label={ApiUrls[environment]}\n          withArrow\n          events={{ hover: true, focus: true, touch: true }}>\n          <NativeSelect\n            data={[\"local\", \"dev\", \"production\"]}\n            value={environment}\n            onChange={handleChange}\n          />\n        </Tooltip>\n      </Group>\n      <Text size=\"sm\">Select the network you want to connect to</Text>\n    </Stack>\n  );\n};\n",
      "size_bytes": 996
    },
    "sdks/node-sdk/test/AsyncStream.test.ts": {
      "content": "import { describe, expect, it, vi } from \"vitest\";\nimport { AsyncStream, createAsyncStreamProxy } from \"@/AsyncStream\";\n\nconst testError = new Error(\"test\");\n\ndescribe(\"AsyncStream\", () => {\n  it(\"should return values from push() in sequence\", async () => {\n    const stream = new AsyncStream<number>();\n    const onReturnSpy = vi.fn();\n    const onDoneSpy = vi.fn();\n\n    stream.onReturn = onReturnSpy;\n    stream.onDone = onDoneSpy;\n\n    stream.push(1);\n    stream.push(2);\n    stream.push(3);\n    stream.push(4);\n    stream.push(5);\n\n    const values: (number | undefined)[] = [];\n    let iterationCount = 0;\n\n    for await (const value of stream) {\n      values.push(value);\n      iterationCount++;\n\n      if (iterationCount === 3) {\n        break;\n      }\n    }\n\n    expect(values).toEqual([1, 2, 3]);\n    expect(onReturnSpy).toHaveBeenCalledOnce();\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n  });\n\n  it(\"should handle values added during iteration\", async () => {\n    const stream = new AsyncStream<number>();\n    const onReturnSpy = vi.fn();\n    const onDoneSpy = vi.fn();\n\n    stream.onReturn = onReturnSpy;\n    stream.onDone = onDoneSpy;\n\n    stream.push(1);\n\n    const values: (number | undefined)[] = [];\n    let iterationCount = 0;\n\n    for await (const value of stream) {\n      values.push(value);\n      iterationCount++;\n\n      if (iterationCount === 1) {\n        stream.push(2);\n        stream.push(3);\n      }\n\n      if (iterationCount === 3) {\n        break;\n      }\n    }\n\n    expect(values).toEqual([1, 2, 3]);\n    expect(onReturnSpy).toHaveBeenCalledOnce();\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n  });\n\n  it(\"should catch an error thrown in the for..await loop and cleanup properly\", async () => {\n    const stream = new AsyncStream<number>();\n    const onReturnSpy = vi.fn();\n    const onDoneSpy = vi.fn();\n\n    stream.onReturn = onReturnSpy;\n    stream.onDone = onDoneSpy;\n    stream.push(1);\n    stream.push(2);\n\n    try {\n      for await (const value of stream) {\n        expect(value).toBe(1);\n        throw testError;\n      }\n    } catch (error) {\n      expect(error).toBe(testError);\n    }\n\n    expect(onReturnSpy).toHaveBeenCalledOnce();\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n  });\n\n  it(\"should end for await..of loop when stream is ended and call onDone\", async () => {\n    const stream = new AsyncStream<number>();\n    const onDoneSpy = vi.fn();\n    const onReturnSpy = vi.fn();\n\n    stream.onDone = onDoneSpy;\n    stream.onReturn = onReturnSpy;\n\n    stream.push(1);\n    stream.push(2);\n\n    setTimeout(() => {\n      void stream.end();\n    }, 100);\n\n    const values: (number | undefined)[] = [];\n\n    for await (const value of stream) {\n      values.push(value);\n    }\n\n    expect(values).toEqual([1, 2]);\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(onReturnSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n\n    stream.push(3);\n\n    for await (const _value of stream) {\n      // this block should never be reached\n      expect(false).toBe(true);\n    }\n  });\n\n  it(\"should handle multiple concurrent next() calls\", async () => {\n    const stream = new AsyncStream<number>();\n\n    const nextPromise1 = stream.next();\n    const nextPromise2 = stream.next();\n    const nextPromise3 = stream.next();\n\n    stream.push(1);\n    stream.push(2);\n    stream.push(3);\n\n    const [result1, result2, result3] = await Promise.all([\n      nextPromise1,\n      nextPromise2,\n      nextPromise3,\n    ]);\n\n    expect(result1).toEqual({ done: false, value: 1 });\n    expect(result2).toEqual({ done: false, value: 2 });\n    expect(result3).toEqual({ done: false, value: 3 });\n    expect(stream.isDone).toBe(false);\n  });\n\n  it(\"should handle return() with pending promises\", async () => {\n    const stream = new AsyncStream<number>();\n    const onReturnSpy = vi.fn();\n\n    stream.onReturn = onReturnSpy;\n\n    const nextPromise1 = stream.next();\n    const nextPromise2 = stream.next();\n\n    const returnResult = await stream.return();\n\n    expect(returnResult).toEqual({ done: true, value: undefined });\n    expect(onReturnSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n\n    const result1 = await nextPromise1;\n    const result2 = await nextPromise2;\n\n    expect(result1).toEqual({ done: true, value: undefined });\n    expect(result2).toEqual({ done: true, value: undefined });\n  });\n\n  it(\"should not process callbacks after being done\", async () => {\n    const stream = new AsyncStream<number>();\n    const onDoneSpy = vi.fn();\n    const onReturnSpy = vi.fn();\n\n    stream.onDone = onDoneSpy;\n    stream.onReturn = onReturnSpy;\n\n    // End the stream\n    await stream.end();\n\n    // These callbacks should be ignored\n    stream.push(1);\n\n    for await (const _value of stream) {\n      // this block should never be reached\n      expect(false).toBe(true);\n    }\n\n    expect(stream.isDone).toBe(true);\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(onReturnSpy).toHaveBeenCalledOnce();\n\n    const result = await stream.next();\n    expect(result).toEqual({ done: true, value: undefined });\n  });\n\n  it(\"should handle queue properly when values arrive faster than consumption\", async () => {\n    const stream = new AsyncStream<number>();\n\n    for (let i = 1; i <= 5; i++) {\n      stream.push(i);\n    }\n\n    const values: (number | undefined)[] = [];\n\n    for (let i = 0; i < 3; i++) {\n      const result = await stream.next();\n      expect(result.done).toBe(false);\n      values.push(result.value);\n    }\n\n    expect(values).toEqual([1, 2, 3]);\n    expect(stream.isDone).toBe(false);\n\n    await stream.end();\n\n    const finalResult = await stream.next();\n    expect(finalResult).toEqual({ done: true, value: undefined });\n  });\n});\n\ndescribe(\"createAsyncStreamProxy\", () => {\n  it(\"should only expose allowed methods and properties\", () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    expect(typeof proxy.next).toBe(\"function\");\n    expect(typeof proxy.end).toBe(\"function\");\n    expect(typeof proxy.return).toBe(\"function\");\n    expect(typeof proxy[Symbol.asyncIterator]).toBe(\"function\");\n\n    const ownProperties = Object.getOwnPropertyNames(proxy);\n    expect(ownProperties).toHaveLength(4);\n    expect(ownProperties).toContain(\"end\");\n    expect(ownProperties).toContain(\"return\");\n    expect(ownProperties).toContain(\"isDone\");\n    expect(ownProperties).toContain(\"next\");\n  });\n\n  it(\"should prevent setting properties\", () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    // this will fail silently\n    proxy.isDone = true;\n\n    expect(proxy.isDone).toBe(false);\n  });\n\n  it(\"should correctly forward next() calls to the underlying stream\", async () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    stream.push(1);\n    stream.push(2);\n\n    const result1 = await proxy.next();\n    const result2 = await proxy.next();\n\n    expect(result1).toEqual({ done: false, value: 1 });\n    expect(result2).toEqual({ done: false, value: 2 });\n  });\n\n  it(\"should correctly forward end() calls to the underlying stream\", async () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n    const onDoneSpy = vi.fn();\n\n    stream.onDone = onDoneSpy;\n\n    const result = await proxy.end();\n\n    expect(result).toEqual({ done: true, value: undefined });\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n    expect(proxy.isDone).toBe(true);\n  });\n\n  it(\"should maintain async iterator functionality\", async () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    stream.push(1);\n    stream.push(2);\n    stream.push(3);\n\n    const values: number[] = [];\n    let iterationCount = 0;\n\n    for await (const value of proxy) {\n      values.push(value);\n      iterationCount++;\n\n      if (iterationCount === 3) {\n        break;\n      }\n    }\n\n    expect(values).toEqual([1, 2, 3]);\n    expect(stream.isDone).toBe(true);\n    expect(proxy.isDone).toBe(true);\n  });\n\n  it(\"should end for await..of loop when proxy is ended and call onDone\", async () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n    const onDoneSpy = vi.fn();\n\n    stream.onDone = onDoneSpy;\n\n    stream.push(1);\n    stream.push(2);\n\n    setTimeout(() => {\n      void proxy.end();\n    }, 100);\n\n    const values: number[] = [];\n\n    for await (const value of proxy) {\n      values.push(value);\n    }\n\n    expect(values).toEqual([1, 2]);\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n    expect(proxy.isDone).toBe(true);\n\n    stream.push(3);\n\n    for await (const _value of proxy) {\n      // this block should never be reached\n      expect(false).toBe(true);\n    }\n  });\n\n  it(\"should correctly implement has() trap\", () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    expect(\"isDone\" in proxy).toBe(true);\n    expect(\"next\" in proxy).toBe(true);\n    expect(\"end\" in proxy).toBe(true);\n    expect(\"return\" in proxy).toBe(true);\n    expect(Symbol.asyncIterator in proxy).toBe(true);\n\n    expect(\"push\" in proxy).toBe(false);\n    expect(\"error\" in proxy).toBe(false);\n    expect(\"onDone\" in proxy).toBe(false);\n    expect(\"onError\" in proxy).toBe(false);\n    expect(\"onReturn\" in proxy).toBe(false);\n    expect(\"nonExistentProperty\" in proxy).toBe(false);\n  });\n\n  it(\"should correctly implement ownKeys() trap\", () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    const keys = Object.getOwnPropertyNames(proxy);\n    const symbols = Object.getOwnPropertySymbols(proxy);\n\n    expect(keys).toHaveLength(4);\n    expect(keys).toContain(\"next\");\n    expect(keys).toContain(\"end\");\n    expect(keys).toContain(\"return\");\n    expect(keys).toContain(\"isDone\");\n    expect(symbols).toHaveLength(1);\n    expect(symbols).toContain(Symbol.asyncIterator);\n  });\n\n  it(\"should correctly implement getOwnPropertyDescriptor() trap\", () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    const nextDescriptor = Object.getOwnPropertyDescriptor(proxy, \"next\");\n    expect(nextDescriptor).toBeDefined();\n    expect(nextDescriptor?.enumerable).toBe(true);\n    expect(nextDescriptor?.configurable).toBe(true);\n    expect(typeof nextDescriptor?.value).toBe(\"function\");\n\n    const endDescriptor = Object.getOwnPropertyDescriptor(proxy, \"end\");\n    expect(endDescriptor).toBeDefined();\n    expect(endDescriptor?.enumerable).toBe(true);\n    expect(endDescriptor?.configurable).toBe(true);\n    expect(typeof endDescriptor?.value).toBe(\"function\");\n\n    const returnDescriptor = Object.getOwnPropertyDescriptor(proxy, \"return\");\n    expect(returnDescriptor).toBeDefined();\n    expect(returnDescriptor?.enumerable).toBe(true);\n    expect(returnDescriptor?.configurable).toBe(true);\n    expect(typeof returnDescriptor?.value).toBe(\"function\");\n\n    const asyncIteratorDescriptor = Object.getOwnPropertyDescriptor(\n      proxy,\n      Symbol.asyncIterator,\n    );\n    expect(asyncIteratorDescriptor).toBeDefined();\n    expect(asyncIteratorDescriptor?.enumerable).toBe(true);\n    expect(asyncIteratorDescriptor?.configurable).toBe(true);\n    expect(typeof asyncIteratorDescriptor?.value).toBe(\"function\");\n\n    // Non-exposed properties should return undefined\n    const callbackDescriptor = Object.getOwnPropertyDescriptor(\n      proxy,\n      \"callback\",\n    );\n    expect(callbackDescriptor).toBeUndefined();\n\n    const isDoneDescriptor = Object.getOwnPropertyDescriptor(proxy, \"isDone\");\n    expect(isDoneDescriptor).toBeDefined();\n    expect(isDoneDescriptor?.enumerable).toBe(true);\n    expect(isDoneDescriptor?.configurable).toBe(true);\n    expect(typeof isDoneDescriptor?.value).toBe(\"boolean\");\n  });\n\n  it(\"should handle concurrent operations through proxy\", async () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    const nextPromise1 = proxy.next();\n    const nextPromise2 = proxy.next();\n    const nextPromise3 = proxy.next();\n\n    stream.push(1);\n    stream.push(2);\n    stream.push(3);\n\n    const [result1, result2, result3] = await Promise.all([\n      nextPromise1,\n      nextPromise2,\n      nextPromise3,\n    ]);\n\n    expect(result1).toEqual({ done: false, value: 1 });\n    expect(result2).toEqual({ done: false, value: 2 });\n    expect(result3).toEqual({ done: false, value: 3 });\n  });\n\n  it(\"should work correctly when stream is already done\", async () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    stream.push(1);\n    await proxy.end();\n\n    const result1 = await proxy.next();\n    const result2 = await proxy.next();\n\n    expect(result1).toEqual({ done: true, value: undefined });\n    expect(result2).toEqual({ done: true, value: undefined });\n  });\n});\n",
      "size_bytes": 13172
    },
    "content-types/content-type-remote-attachment/src/Attachment.ts": {
      "content": "import {\n  ContentTypeId,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\n\nexport const ContentTypeAttachment = new ContentTypeId({\n  authorityId: \"xmtp.org\",\n  typeId: \"attachment\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\nexport type Attachment = {\n  filename: string;\n  mimeType: string;\n  data: Uint8Array;\n};\n\nexport type AttachmentParameters = {\n  filename: string;\n  mimeType: string;\n};\n\nexport class AttachmentCodec\n  implements ContentCodec<Attachment, AttachmentParameters>\n{\n  get contentType(): ContentTypeId {\n    return ContentTypeAttachment;\n  }\n\n  encode(content: Attachment) {\n    return {\n      type: ContentTypeAttachment,\n      parameters: {\n        filename: content.filename,\n        mimeType: content.mimeType,\n      },\n      content: content.data,\n    };\n  }\n\n  decode(content: EncodedContent<AttachmentParameters>): Attachment {\n    return {\n      filename: content.parameters.filename,\n      mimeType: content.parameters.mimeType,\n      data: content.content,\n    };\n  }\n\n  fallback(content: Attachment): string | undefined {\n    return `Can’t display \"${content.filename}\". This app doesn’t support attachments.`;\n  }\n\n  shouldPush() {\n    return true;\n  }\n}\n",
      "size_bytes": 1229
    },
    "content-types/content-type-remote-attachment/CHANGELOG.md": {
      "content": "# @xmtp/content-type-remote-attachment\n\n## 2.0.2\n\n### Patch Changes\n\n- Updated dependencies [779fd0c]\n  - @xmtp/content-type-primitives@2.0.2\n\n## 2.0.1\n\n### Patch Changes\n\n- Updated dependencies [340fcf4]\n  - @xmtp/content-type-primitives@2.0.1\n  - @xmtp/proto@3.78.0\n  - @noble/secp256k1@2.2.3\n\n## 2.0.0\n\n### Major Changes\n\n- 1777a23: Dropped support for CommonJS\n\n### Patch Changes\n\n- Updated dependencies [1777a23]\n  - @xmtp/content-type-primitives@2.0.0\n\n## 1.1.12\n\n### Patch Changes\n\n- Updated dependencies [63e5276]\n  - @xmtp/content-type-primitives@1.0.3\n\n## 1.1.11\n\n### Patch Changes\n\n- b81dbff: Fixed encryption dependency\n\n## 1.1.10\n\n### Patch Changes\n\n- 9addb1c:\n  - Updated `AttachmentCodec` type to include parameters type\n  - Added and exported `AttachmentParameters` type\n  - Updated `RemoteAttachmentCodec` type to include parameters type\n  - Added and exported `RemoteAttachmentParameters` type\n- Updated dependencies [9addb1c]\n  - @xmtp/content-type-primitives@1.0.2\n\n## 1.1.9\n\n### Patch Changes\n\n- [#75](https://github.com/xmtp/xmtp-js-content-types/pull/75) [`da0bd85`](https://github.com/xmtp/xmtp-js-content-types/commit/da0bd8578d5f5032b221e25f02e8492b27929d6c)\n  - Use primitives package for types\n\n## 1.1.8\n\n### Patch Changes\n\n- [#65](https://github.com/xmtp/xmtp-js-content-types/pull/65) [`c4d43dc`](https://github.com/xmtp/xmtp-js-content-types/commit/c4d43dc948231de5c7f730e06f0931076de0673b)\n  - Add `shouldPush` to all content codecs\n\n## 1.1.7\n\n### Patch Changes\n\n- [#60](https://github.com/xmtp/xmtp-js-content-types/pull/60) [`5b9310a`](https://github.com/xmtp/xmtp-js-content-types/commit/5b9310ac89fd23e5cfd74903894073b6ef8af7c3)\n  - Upgraded JS SDK to `11.3.12`\n\n## 1.1.6\n\n### Patch Changes\n\n- [#54](https://github.com/xmtp/xmtp-js-content-types/pull/54) [`718cb9f`](https://github.com/xmtp/xmtp-js-content-types/commit/718cb9fec51f74bf2402f3f22160687cae35dda8)\n  - Updated Turbo config to remove `generate:types` command and instead rely on `build`\n  - Removed all `generate:types` commands from `package.json` files\n  - Updated shared ESLint config and local ESLint configs\n  - Updated `include` field of `tsconfig.json` and `tsconfig.eslint.json` files\n  - Replaced `tsup` with `rollup`\n\n## 1.1.5\n\n### Patch Changes\n\n- [#51](https://github.com/xmtp/xmtp-js-content-types/pull/51) [`aeb6db7`](https://github.com/xmtp/xmtp-js-content-types/commit/aeb6db73a63409a33c7d3d3431e33682b0ce4c4d)\n  - Only publish files in the `/dist` directory\n\n## 1.1.4\n\n### Patch Changes\n\n- Upgraded `@xmtp/proto` package\n- Upgraded `@xmtp/xmtp-js` package\n\n## 1.1.3\n\n### Patch Changes\n\n- Update `@xmtp/proto` to latest version\n\n## 1.1.2\n\n### Patch Changes\n\n- Upgrade to JS SDK v11\n- Update client initialization for tests to use `codecs` option for proper types\n\n## 1.1.1\n\n### Patch Changes\n\n- fix: update the copy for the default fallbacks\n\n## 1.1.0\n\n### Minor Changes\n\n- Add dummy fallback field to all content types\n",
      "size_bytes": 2935
    },
    "content-types/content-type-wallet-send-calls/vitest.setup.ts": {
      "content": "import { unlink } from \"node:fs/promises\";\nimport { dirname, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { glob } from \"fast-glob\";\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nexport const teardown = async () => {\n  const files = await glob(\"**/*.db3*\", { cwd: __dirname });\n  await Promise.all(files.map((file) => unlink(join(__dirname, file))));\n};\n",
      "size_bytes": 398
    },
    "sdks/node-sdk/src/DebugInformation.ts": {
      "content": "import type { Client } from \"@xmtp/node-bindings\";\nimport { HistorySyncUrls } from \"@/constants\";\nimport type { ClientOptions } from \"@/types\";\n\n/**\n * Debug information helpers for the client\n *\n * This class is not intended to be initialized directly.\n */\nexport class DebugInformation {\n  #client: Client;\n  #options?: ClientOptions;\n\n  constructor(client: Client, options?: ClientOptions) {\n    this.#client = client;\n    this.#options = options;\n  }\n\n  apiStatistics() {\n    return this.#client.apiStatistics();\n  }\n\n  apiIdentityStatistics() {\n    return this.#client.apiIdentityStatistics();\n  }\n\n  apiAggregateStatistics() {\n    return this.#client.apiAggregateStatistics();\n  }\n\n  clearAllStatistics() {\n    this.#client.clearAllStatistics();\n  }\n\n  uploadDebugArchive(serverUrl?: string) {\n    const env = this.#options?.env || \"dev\";\n    const historySyncUrl =\n      this.#options?.historySyncUrl || HistorySyncUrls[env];\n    return this.#client.uploadDebugArchive(serverUrl || historySyncUrl);\n  }\n}\n",
      "size_bytes": 1012
    },
    "apps/xmtp.chat/src/components/App/ErrorModal.tsx": {
      "content": "import { Box, Button, Group, Tabs } from \"@mantine/core\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { CodeWithCopy } from \"@/components/CodeWithCopy\";\nimport { Modal } from \"@/components/Modal\";\nimport { useCollapsedMediaQuery } from \"@/hooks/useCollapsedMediaQuery\";\nimport { ContentLayout } from \"@/layouts/ContentLayout\";\n\nexport const ErrorModal: React.FC = () => {\n  const [unhandledRejectionError, setUnhandledRejectionError] =\n    useState<Error | null>(null);\n  const fullScreen = useCollapsedMediaQuery();\n  const contentHeight = fullScreen ? \"auto\" : 500;\n\n  useEffect(() => {\n    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {\n      setUnhandledRejectionError(event.reason as Error);\n    };\n    window.addEventListener(\"unhandledrejection\", handleUnhandledRejection);\n    return () => {\n      window.removeEventListener(\n        \"unhandledrejection\",\n        handleUnhandledRejection,\n      );\n    };\n  }, []);\n\n  const footer = useMemo(() => {\n    return (\n      <Group justify=\"space-between\" flex={1} p=\"md\">\n        <Button\n          variant=\"default\"\n          component=\"a\"\n          href=\"https://github.com/xmtp/xmtp-js/issues/new/choose\"\n          target=\"_blank\">\n          Report issue\n        </Button>\n        <Button\n          onClick={() => {\n            setUnhandledRejectionError(null);\n          }}>\n          OK\n        </Button>\n      </Group>\n    );\n  }, []);\n\n  return unhandledRejectionError ? (\n    <Modal\n      opened={!!unhandledRejectionError}\n      onClose={() => {\n        setUnhandledRejectionError(null);\n      }}\n      fullScreen={fullScreen}\n      closeOnEscape={false}\n      closeOnClickOutside={false}\n      withCloseButton={false}\n      padding={0}\n      centered>\n      <ContentLayout\n        title=\"Application error\"\n        maxHeight={contentHeight}\n        footer={footer}\n        withScrollFade={false}\n        withScrollAreaPadding={false}>\n        <Box p=\"md\">\n          <Tabs defaultValue=\"message\">\n            <Tabs.List>\n              <Tabs.Tab value=\"message\">Message</Tabs.Tab>\n              <Tabs.Tab value=\"stackTrace\">Stack trace</Tabs.Tab>\n            </Tabs.List>\n            <Tabs.Panel value=\"message\" py=\"md\">\n              <CodeWithCopy code={unhandledRejectionError.message} />\n            </Tabs.Panel>\n            <Tabs.Panel value=\"stackTrace\" py=\"md\">\n              <CodeWithCopy\n                code={\n                  unhandledRejectionError.stack ?? \"Stack trace not available\"\n                }\n              />\n            </Tabs.Panel>\n          </Tabs>\n        </Box>\n      </ContentLayout>\n    </Modal>\n  ) : null;\n};\n",
      "size_bytes": 2643
    },
    "content-types/content-type-transaction-reference/README.md": {
      "content": "# Transaction reference content type\n\nThis package provides an XMTP content type to support on-chain transaction references.\n\n> **Open for feedback**  \n> You are welcome to provide feedback on this implementation by commenting on [XIP-21: On-chain transaction reference content type](https://community.xmtp.org/t/xip-21-on-chain-transaction-reference-content-type/532).\n\n## What’s a transaction reference?\n\nIt is a reference to an on-chain transaction sent as a message. This content type facilitates sharing transaction hashes or IDs, thereby providing a direct link to on-chain activities.\n\n## Why transaction references?\n\nTransaction references serve to display transaction details, facilitating the sharing of on-chain activities, such as token transfers, between users.\n\n## Install the package\n\n```bash\n# npm\nnpm i @xmtp/content-type-transaction-reference\n\n# yarn\nyarn add @xmtp/content-type-transaction-reference\n\n# pnpm\npnpm i @xmtp/content-type-transaction-reference\n```\n\n## Create a transaction reference\n\nWith XMTP, a transaction reference is represented as an object with the following keys:\n\n```tsx\nconst transactionReference: TransactionReference = {\n  /**\n   * Optional namespace for the networkId\n   */\n  namespace: \"eip155\";\n  /**\n   * The networkId for the transaction, in decimal or hexadecimal format\n   */\n  networkId: 1;\n  /**\n   * The transaction hash\n   */\n  reference: \"0x123...abc\";\n  /**\n   * Optional metadata object\n   */\n  metadata: {\n    transactionType: \"transfer\",\n    currency: \"USDC\",\n    amount: 100000, // In integer format, this represents 1 USDC (100000/10^6)\n    decimals: 6, // Specifies that the currency uses 6 decimal places\n    fromAddress: \"0x456...def\",\n    toAddress: \"0x789...ghi\"\n  };\n};\n```\n\n## Send a transaction reference\n\nOnce you have a transaction reference, you can send it as part of your conversation:\n\n```tsx\nawait conversation.messages.send(transactionReference, {\n  contentType: ContentTypeTransactionReference,\n});\n```\n\n## Receive a transaction reference\n\nTo receive and process a transaction reference:\n\n```tsx\n// Assume `loadLastMessage` is a thing you have\nconst message: DecodedMessage = await loadLastMessage();\n\nif (!message.contentType.sameAs(ContentTypeTransactionReference)) {\n  // Handle non-transaction reference message\n  return;\n}\n\nconst transactionRef: TransactionReference = message.content;\n// Process the transaction reference here\n```\n\n## Display the transaction reference\n\nDisplaying a transaction reference typically involves rendering details such as the transaction hash, network ID, and any relevant metadata. The exact UI representation can vary based on your application's design, you might want to fetch on-chain data before showing them to the user.\n\n## Note on Metadata\n\nThe optional metadata within a transaction reference, such as transaction type, currency, amount, and addresses, are provided for informational purposes only. These details should not be solely relied upon for verifying transaction specifics. Developers are responsible for ensuring the accuracy of transaction data, either by directing users to the appropriate block explorer or by fetching and displaying verified transaction data from the blockchain.\n\n## Developing\n\nRun `yarn dev` to build the content type and watch for changes, which will trigger a rebuild.\n\nFor more information on contributing to this repository, see our [contributing guidelines](../../CONTRIBUTING.md).\n",
      "size_bytes": 3443
    },
    "apps/xmtp.chat/src/components/App/AppFooter.tsx": {
      "content": "import { Stack, Text } from \"@mantine/core\";\n\nexport const AppFooter: React.FC = () => {\n  return (\n    <Stack\n      align=\"center\"\n      gap={6}\n      px=\"md\"\n      py=\"lg\"\n      style={{\n        width: \"100%\",\n        borderRadius: \"18px\",\n        background:\n          \"linear-gradient(135deg, rgba(10, 255, 241, 0.12), rgba(151, 114, 251, 0.16))\",\n      }}>\n      <Text\n        fw={700}\n        size=\"sm\"\n        style={{\n          letterSpacing: \"0.08em\",\n          textTransform: \"uppercase\",\n          color: \"var(--mantine-color-teal-3)\",\n        }}>\n        MumbleChat • Ramestta\n      </Text>\n      <Text size=\"xs\" c=\"dimmed\" ta=\"center\">\n        © {new Date().getFullYear()} MumbleChat. Secure, decentralized messaging for communities\n        building on Ramestta.\n      </Text>\n    </Stack>\n  );\n};\n",
      "size_bytes": 814
    },
    "apps/xmtp.chat/src/components/InboxTools/NetworkSelect.tsx": {
      "content": "import { Group, NativeSelect, Text, Tooltip } from \"@mantine/core\";\nimport { ApiUrls, type XmtpEnv } from \"@xmtp/browser-sdk\";\nimport { useSettings } from \"@/hooks/useSettings\";\n\nexport const NetworkSelect: React.FC = () => {\n  const { environment, setEnvironment } = useSettings();\n\n  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {\n    setEnvironment(event.currentTarget.value as XmtpEnv);\n  };\n\n  return (\n    <Group gap=\"xs\" justify=\"space-between\">\n      <Text fw=\"bold\">XMTP network</Text>\n      <Tooltip\n        label={ApiUrls[environment]}\n        withArrow\n        events={{ hover: true, focus: true, touch: true }}>\n        <NativeSelect\n          data={[\"local\", \"dev\", \"production\"]}\n          value={environment}\n          onChange={handleChange}\n        />\n      </Tooltip>\n    </Group>\n  );\n};\n",
      "size_bytes": 833
    },
    "content-types/content-type-group-updated/rollup.config.js": {
      "content": "import terser from \"@rollup/plugin-terser\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { defineConfig } from \"rollup\";\nimport { dts } from \"rollup-plugin-dts\";\n\nconst plugins = [\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n];\n\nconst external = [\"@xmtp/content-type-primitives\", \"@xmtp/proto\"];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/browser/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins: [...plugins, terser()],\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.d.ts\",\n      format: \"es\",\n    },\n    plugins: [dts()],\n  },\n]);\n",
      "size_bytes": 847
    },
    "apps/xmtp.chat/src/components/Conversation/ConversationOutletContext.ts": {
      "content": "export type ConversationOutletContext = {\n  conversationId: string;\n};\n",
      "size_bytes": 71
    },
    "apps/xmtp.chat/src/components/Conversation/MemberCard.module.css": {
      "content": ".member {\n  cursor: pointer;\n}\n\n.member:hover {\n  background-color: var(--mantine-color-default-hover);\n}\n",
      "size_bytes": 106
    },
    "sdks/browser-sdk/src/utils/createClient.ts": {
      "content": "import {\n  createClient as createWasmClient,\n  generateInboxId,\n  getInboxIdForIdentifier,\n  LogOptions,\n  type Identifier,\n} from \"@xmtp/wasm-bindings\";\nimport { ApiUrls, HistorySyncUrls } from \"@/constants\";\nimport type { ClientOptions } from \"@/types/options\";\n\nexport const createClient = async (\n  identifier: Identifier,\n  options?: Omit<ClientOptions, \"codecs\">,\n) => {\n  const env = options?.env || \"dev\";\n  const host = options?.apiUrl || ApiUrls[env];\n  const inboxId =\n    (await getInboxIdForIdentifier(host, identifier)) ||\n    generateInboxId(identifier);\n  const dbPath =\n    options?.dbPath === undefined\n      ? `xmtp-${env}-${inboxId}.db3`\n      : options.dbPath;\n  const isLogging =\n    options &&\n    (options.loggingLevel !== undefined ||\n      options.structuredLogging ||\n      options.performanceLogging);\n\n  const historySyncUrl =\n    options?.historySyncUrl === undefined\n      ? HistorySyncUrls[env]\n      : options.historySyncUrl;\n\n  const deviceSyncWorkerMode = options?.disableDeviceSync\n    ? \"disabled\"\n    : \"enabled\";\n\n  return createWasmClient(\n    host,\n    inboxId,\n    identifier,\n    dbPath,\n    options?.dbEncryptionKey,\n    historySyncUrl,\n    deviceSyncWorkerMode,\n    isLogging\n      ? new LogOptions(\n          options.structuredLogging ?? false,\n          options.performanceLogging ?? false,\n          options.loggingLevel,\n        )\n      : undefined,\n    undefined,\n    options?.debugEventsEnabled,\n    options?.appVersion,\n  );\n};\n",
      "size_bytes": 1480
    },
    "sdks/browser-sdk/src/Conversation.ts": {
      "content": "import type { ContentTypeId } from \"@xmtp/content-type-primitives\";\nimport { ContentTypeText } from \"@xmtp/content-type-text\";\nimport type { ConsentState } from \"@xmtp/wasm-bindings\";\nimport { v4 } from \"uuid\";\nimport type { Client } from \"@/Client\";\nimport { DecodedMessage } from \"@/DecodedMessage\";\nimport type {\n  SafeConversation,\n  SafeListMessagesOptions,\n  SafeMessage,\n} from \"@/utils/conversions\";\nimport { nsToDate } from \"@/utils/date\";\nimport { MissingContentTypeError } from \"@/utils/errors\";\nimport {\n  createStream,\n  type StreamCallback,\n  type StreamOptions,\n} from \"@/utils/streams\";\n\n/**\n * Represents a conversation\n *\n * This class is not intended to be initialized directly.\n */\nexport class Conversation<ContentTypes = unknown> {\n  #addedByInboxId?: SafeConversation[\"addedByInboxId\"];\n  #client: Client<ContentTypes>;\n  #createdAtNs?: SafeConversation[\"createdAtNs\"];\n  #id: string;\n  #metadata?: SafeConversation[\"metadata\"];\n  #isCommitLogForked?: SafeConversation[\"isCommitLogForked\"];\n\n  /**\n   * Creates a new conversation instance\n   *\n   * @param client - The client instance managing the conversation\n   * @param id - The unique identifier for this conversation\n   * @param data - Optional conversation data to initialize with\n   */\n  constructor(\n    client: Client<ContentTypes>,\n    id: string,\n    data?: SafeConversation,\n  ) {\n    this.#client = client;\n    this.#id = id;\n    this.#syncData(data);\n  }\n\n  #syncData(data?: SafeConversation) {\n    this.#addedByInboxId = data?.addedByInboxId;\n    this.#metadata = data?.metadata;\n    this.#createdAtNs = data?.createdAtNs;\n    this.#isCommitLogForked = data?.isCommitLogForked;\n  }\n\n  get id() {\n    return this.#id;\n  }\n\n  get isCommitLogForked() {\n    return this.#isCommitLogForked;\n  }\n\n  get addedByInboxId() {\n    return this.#addedByInboxId;\n  }\n\n  get createdAtNs() {\n    return this.#createdAtNs;\n  }\n\n  get createdAt() {\n    return this.#createdAtNs ? nsToDate(this.#createdAtNs) : undefined;\n  }\n\n  get metadata() {\n    return this.#metadata;\n  }\n\n  async lastMessage() {\n    const lastMessage = await this.#client.sendMessage(\n      \"conversation.lastMessage\",\n      {\n        id: this.#id,\n      },\n    );\n    return lastMessage\n      ? new DecodedMessage(this.#client, lastMessage)\n      : undefined;\n  }\n\n  async isActive() {\n    return this.#client.sendMessage(\"conversation.isActive\", {\n      id: this.#id,\n    });\n  }\n\n  /**\n   * Gets the conversation members\n   *\n   * @returns Promise that resolves with the conversation members\n   */\n  async members() {\n    return this.#client.sendMessage(\"conversation.members\", {\n      id: this.#id,\n    });\n  }\n\n  /**\n   * Synchronizes conversation data from the network\n   *\n   * @returns Promise that resolves with the updated conversation data\n   */\n  async sync() {\n    const data = await this.#client.sendMessage(\"conversation.sync\", {\n      id: this.#id,\n    });\n    this.#syncData(data);\n    return data;\n  }\n\n  /**\n   * Publishes pending messages that were sent optimistically\n   *\n   * @returns Promise that resolves when publishing is complete\n   */\n  async publishMessages() {\n    return this.#client.sendMessage(\"conversation.publishMessages\", {\n      id: this.#id,\n    });\n  }\n\n  /**\n   * Prepares a message to be published\n   *\n   * @param content - The content to send\n   * @param contentType - Optional content type of the message content\n   * @returns Promise that resolves with the message ID\n   * @throws {MissingContentTypeError} if content type is required but not provided\n   */\n  async sendOptimistic(content: ContentTypes, contentType?: ContentTypeId) {\n    if (typeof content !== \"string\" && !contentType) {\n      throw new MissingContentTypeError();\n    }\n\n    const safeEncodedContent =\n      typeof content === \"string\"\n        ? this.#client.encodeContent(content, contentType ?? ContentTypeText)\n        : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this.#client.encodeContent(content, contentType!);\n\n    return this.#client.sendMessage(\"conversation.sendOptimistic\", {\n      id: this.#id,\n      content: safeEncodedContent,\n    });\n  }\n\n  /**\n   * Publishes a new message\n   *\n   * @param content - The content to send\n   * @param contentType - Optional content type of the message content\n   * @returns Promise that resolves with the message ID after it has been sent\n   * @throws {MissingContentTypeError} if content type is required but not provided\n   */\n  async send(content: ContentTypes, contentType?: ContentTypeId) {\n    if (typeof content !== \"string\" && !contentType) {\n      throw new MissingContentTypeError();\n    }\n\n    const safeEncodedContent =\n      typeof content === \"string\"\n        ? this.#client.encodeContent(content, contentType ?? ContentTypeText)\n        : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this.#client.encodeContent(content, contentType!);\n\n    return this.#client.sendMessage(\"conversation.send\", {\n      id: this.#id,\n      content: safeEncodedContent,\n    });\n  }\n\n  /**\n   * Lists messages in this conversation\n   *\n   * @param options - Optional filtering and pagination options\n   * @returns Promise that resolves with an array of decoded messages\n   */\n  async messages(options?: SafeListMessagesOptions) {\n    const messages = await this.#client.sendMessage(\"conversation.messages\", {\n      id: this.#id,\n      options,\n    });\n\n    return messages.map((message) => new DecodedMessage(this.#client, message));\n  }\n\n  /**\n   * Gets the consent state for this conversation\n   *\n   * @returns Promise that resolves with the current consent state\n   */\n  async consentState() {\n    return this.#client.sendMessage(\"conversation.consentState\", {\n      id: this.#id,\n    });\n  }\n\n  /**\n   * Updates the consent state for this conversation\n   *\n   * @param state - The new consent state to set\n   * @returns Promise that resolves when the update is complete\n   */\n  async updateConsentState(state: ConsentState) {\n    return this.#client.sendMessage(\"conversation.updateConsentState\", {\n      id: this.#id,\n      state,\n    });\n  }\n\n  /**\n   * Gets the message disappearing settings for this conversation\n   *\n   * @returns Promise that resolves with the current message disappearing settings\n   */\n  async messageDisappearingSettings() {\n    return this.#client.sendMessage(\n      \"conversation.messageDisappearingSettings\",\n      {\n        id: this.#id,\n      },\n    );\n  }\n\n  /**\n   * Updates message disappearing settings for this conversation\n   *\n   * @param fromNs - The timestamp from which messages should start disappearing\n   * @param inNs - The duration after which messages should disappear\n   * @returns Promise that resolves when the update is complete\n   */\n  async updateMessageDisappearingSettings(fromNs: bigint, inNs: bigint) {\n    return this.#client.sendMessage(\n      \"conversation.updateMessageDisappearingSettings\",\n      {\n        id: this.#id,\n        fromNs,\n        inNs,\n      },\n    );\n  }\n\n  /**\n   * Removes message disappearing settings from this conversation\n   *\n   * @returns Promise that resolves when the settings are removed\n   */\n  async removeMessageDisappearingSettings() {\n    return this.#client.sendMessage(\n      \"conversation.removeMessageDisappearingSettings\",\n      {\n        id: this.#id,\n      },\n    );\n  }\n\n  /**\n   * Checks if message disappearing is enabled for this conversation\n   *\n   * @returns Promise that resolves with whether message disappearing is enabled\n   */\n  async isMessageDisappearingEnabled() {\n    return this.#client.sendMessage(\n      \"conversation.isMessageDisappearingEnabled\",\n      {\n        id: this.#id,\n      },\n    );\n  }\n\n  /**\n   * Creates a stream for new messages in this conversation\n   *\n   * @param callback - Optional callback function for handling new stream values\n   * @returns Stream instance for new messages\n   */\n  async stream(\n    options?: StreamOptions<SafeMessage, DecodedMessage<ContentTypes>>,\n  ) {\n    const stream = async (\n      callback: StreamCallback<SafeMessage>,\n      onFail: () => void,\n    ) => {\n      const streamId = v4();\n      // sync the conversation\n      await this.sync();\n      // start the stream\n      await this.#client.sendMessage(\"conversation.stream\", {\n        groupId: this.#id,\n        streamId,\n      });\n      // handle stream messages\n      return this.#client.handleStreamMessage<\n        SafeMessage,\n        DecodedMessage<ContentTypes>\n      >(streamId, callback, {\n        ...options,\n        onFail,\n      });\n    };\n    const convertMessage = (value: SafeMessage) => {\n      return new DecodedMessage(this.#client, value);\n    };\n\n    return createStream(stream, convertMessage, options);\n  }\n\n  async pausedForVersion() {\n    return this.#client.sendMessage(\"conversation.pausedForVersion\", {\n      id: this.#id,\n    });\n  }\n\n  /**\n   * Retrieves HMAC keys for this conversation\n   *\n   * @returns Promise that resolves with the HMAC keys\n   */\n  async getHmacKeys() {\n    return this.#client.sendMessage(\"conversation.getHmacKeys\", {\n      id: this.#id,\n    });\n  }\n\n  /**\n   * Retrieves information for this conversation to help with debugging\n   *\n   * @returns The debug information for this conversation\n   */\n  async debugInfo() {\n    return this.#client.sendMessage(\"conversation.debugInfo\", {\n      id: this.#id,\n    });\n  }\n}\n",
      "size_bytes": 9372
    },
    "sdks/browser-sdk/src/WorkerClient.ts": {
      "content": "import {\n  verifySignedWithPublicKey,\n  type Client,\n  type Identifier,\n  type KeyPackageStatus,\n  type SignatureRequestHandle,\n} from \"@xmtp/wasm-bindings\";\nimport type { ClientOptions } from \"@/types/options\";\nimport { createClient } from \"@/utils/createClient\";\nimport type { SafeSigner } from \"@/utils/signer\";\nimport { WorkerConversations } from \"@/WorkerConversations\";\nimport { WorkerDebugInformation } from \"@/WorkerDebugInformation\";\nimport { WorkerPreferences } from \"@/WorkerPreferences\";\n\nexport class WorkerClient {\n  #client: Client;\n  #conversations: WorkerConversations;\n  #debugInformation: WorkerDebugInformation;\n  #preferences: WorkerPreferences;\n\n  constructor(client: Client, options?: ClientOptions) {\n    this.#client = client;\n    const conversations = client.conversations();\n    this.#conversations = new WorkerConversations(this, conversations);\n    this.#debugInformation = new WorkerDebugInformation(client, options);\n    this.#preferences = new WorkerPreferences(client, conversations);\n  }\n\n  static async create(\n    identifier: Identifier,\n    options?: Omit<ClientOptions, \"codecs\">,\n  ) {\n    const client = await createClient(identifier, options);\n    return new WorkerClient(client, options);\n  }\n\n  get accountIdentifier() {\n    return this.#client.accountIdentifier;\n  }\n\n  get inboxId() {\n    return this.#client.inboxId;\n  }\n\n  get installationId() {\n    return this.#client.installationId;\n  }\n\n  get installationIdBytes() {\n    return this.#client.installationIdBytes;\n  }\n\n  get isRegistered() {\n    return this.#client.isRegistered;\n  }\n\n  get conversations() {\n    return this.#conversations;\n  }\n\n  get debugInformation() {\n    return this.#debugInformation;\n  }\n\n  get preferences() {\n    return this.#preferences;\n  }\n\n  async canMessage(identifiers: Identifier[]) {\n    return this.#client.canMessage(identifiers) as Promise<\n      Map<string, boolean>\n    >;\n  }\n\n  async addSignature(\n    signatureRequest: SignatureRequestHandle,\n    signer: SafeSigner,\n  ) {\n    switch (signer.type) {\n      case \"SCW\":\n        await signatureRequest.addScwSignature(\n          signer.identifier,\n          signer.signature,\n          signer.chainId,\n          signer.blockNumber,\n        );\n        break;\n      case \"EOA\":\n        await signatureRequest.addEcdsaSignature(signer.signature);\n        break;\n    }\n  }\n\n  async applySignatureRequest(signatureRequest: SignatureRequestHandle) {\n    return this.#client.applySignatureRequest(signatureRequest);\n  }\n\n  async processSignatureRequest(\n    signer: SafeSigner,\n    signatureRequest: SignatureRequestHandle,\n  ) {\n    await this.addSignature(signatureRequest, signer);\n    await this.applySignatureRequest(signatureRequest);\n  }\n\n  createInboxSignatureRequest() {\n    return this.#client.createInboxSignatureRequest();\n  }\n\n  async addAccountSignatureRequest(newAccountIdentifier: Identifier) {\n    return this.#client.addWalletSignatureRequest(newAccountIdentifier);\n  }\n\n  async removeAccountSignatureRequest(identifier: Identifier) {\n    return this.#client.revokeWalletSignatureRequest(identifier);\n  }\n\n  async revokeAllOtherInstallationsSignatureRequest() {\n    return this.#client.revokeAllOtherInstallationsSignatureRequest();\n  }\n\n  async revokeInstallationsSignatureRequest(installationIds: Uint8Array[]) {\n    return this.#client.revokeInstallationsSignatureRequest(installationIds);\n  }\n\n  async changeRecoveryIdentifierSignatureRequest(identifier: Identifier) {\n    return this.#client.changeRecoveryIdentifierSignatureRequest(identifier);\n  }\n\n  async registerIdentity(\n    signer: SafeSigner,\n    signatureRequest: SignatureRequestHandle,\n  ) {\n    await this.addSignature(signatureRequest, signer);\n    await this.#client.registerIdentity(signatureRequest);\n  }\n\n  async findInboxIdByIdentifier(identifier: Identifier) {\n    return this.#client.findInboxIdByIdentifier(identifier);\n  }\n\n  signWithInstallationKey(signatureText: string) {\n    return this.#client.signWithInstallationKey(signatureText);\n  }\n\n  verifySignedWithInstallationKey(\n    signatureText: string,\n    signatureBytes: Uint8Array,\n  ) {\n    try {\n      this.#client.verifySignedWithInstallationKey(\n        signatureText,\n        signatureBytes,\n      );\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  verifySignedWithPublicKey(\n    signatureText: string,\n    signatureBytes: Uint8Array,\n    publicKey: Uint8Array,\n  ) {\n    try {\n      verifySignedWithPublicKey(signatureText, signatureBytes, publicKey);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async getKeyPackageStatusesForInstallationIds(installationIds: string[]) {\n    return this.#client.getKeyPackageStatusesForInstallationIds(\n      installationIds,\n    ) as Promise<Map<string, KeyPackageStatus>>;\n  }\n}\n",
      "size_bytes": 4792
    },
    "apps/xmtp.chat/src/hooks/useConversations.ts": {
      "content": "import type {\n  Conversation,\n  DecodedMessage,\n  Identifier,\n  SafeCreateGroupOptions,\n} from \"@xmtp/browser-sdk\";\nimport { useState } from \"react\";\nimport { useClient, type ContentTypes } from \"@/contexts/XMTPContext\";\nimport { dateToNs } from \"@/helpers/date\";\nimport {\n  useActions,\n  useConversations as useConversationsState,\n  useLastCreatedAt,\n} from \"@/stores/inbox/hooks\";\n\nexport const useConversations = () => {\n  const client = useClient();\n  const { addConversations, addConversation, addMessage, setLastSyncedAt } =\n    useActions();\n  const conversations = useConversationsState();\n  const lastCreatedAt = useLastCreatedAt();\n  const [loading, setLoading] = useState(false);\n  const [syncing, setSyncing] = useState(false);\n\n  const sync = async (fromNetwork: boolean = false) => {\n    if (fromNetwork) {\n      setSyncing(true);\n\n      try {\n        await client.conversations.sync();\n      } finally {\n        setSyncing(false);\n      }\n    }\n\n    setLoading(true);\n\n    try {\n      const convos = await client.conversations.list({\n        createdAfterNs: lastCreatedAt,\n      });\n      await addConversations(convos);\n      setLastSyncedAt(dateToNs(new Date()));\n      return convos;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const syncAll = async () => {\n    setSyncing(true);\n\n    try {\n      await client.conversations.syncAll();\n    } finally {\n      setSyncing(false);\n    }\n  };\n\n  const getConversationById = async (conversationId: string) => {\n    setLoading(true);\n\n    try {\n      const conversation =\n        await client.conversations.getConversationById(conversationId);\n      return conversation;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const getDmByInboxId = async (inboxId: string) => {\n    setLoading(true);\n\n    try {\n      const dm = await client.conversations.getDmByInboxId(inboxId);\n      return dm;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const getMessageById = async (messageId: string) => {\n    setLoading(true);\n\n    try {\n      const message = await client.conversations.getMessageById(messageId);\n      return message;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const newGroup = async (\n    inboxIds: string[],\n    options?: SafeCreateGroupOptions,\n  ) => {\n    setLoading(true);\n\n    try {\n      const conversation = await client.conversations.newGroup(\n        inboxIds,\n        options,\n      );\n      void addConversation(conversation);\n      return conversation;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const newGroupWithIdentifiers = async (\n    identifiers: Identifier[],\n    options?: SafeCreateGroupOptions,\n  ) => {\n    setLoading(true);\n\n    try {\n      const conversation = await client.conversations.newGroupWithIdentifiers(\n        identifiers,\n        options,\n      );\n      void addConversation(conversation);\n      return conversation;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const newDm = async (inboxId: string) => {\n    setLoading(true);\n\n    try {\n      const conversation = await client.conversations.newDm(inboxId);\n      void addConversation(conversation);\n      return conversation;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const newDmWithIdentifier = async (identifier: Identifier) => {\n    setLoading(true);\n\n    try {\n      const conversation =\n        await client.conversations.newDmWithIdentifier(identifier);\n      void addConversation(conversation);\n      return conversation;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const stream = async () => {\n    const onValue = (conversation: Conversation<ContentTypes>) => {\n      const shouldAdd =\n        conversation.metadata?.conversationType === \"dm\" ||\n        conversation.metadata?.conversationType === \"group\";\n      if (shouldAdd) {\n        void addConversation(conversation);\n      }\n    };\n\n    const stream = await client.conversations.stream({\n      onValue,\n    });\n\n    return () => {\n      void stream.end();\n    };\n  };\n\n  const streamAllMessages = async () => {\n    const onValue = (message: DecodedMessage<ContentTypes>) => {\n      void addMessage(message.conversationId, message);\n    };\n\n    const stream = await client.conversations.streamAllMessages({\n      onValue,\n    });\n\n    return () => {\n      void stream.end();\n    };\n  };\n\n  return {\n    conversations,\n    getConversationById,\n    getDmByInboxId,\n    getMessageById,\n    loading,\n    newDm,\n    newDmWithIdentifier,\n    newGroup,\n    newGroupWithIdentifiers,\n    stream,\n    streamAllMessages,\n    sync,\n    syncAll,\n    syncing,\n  };\n};\n",
      "size_bytes": 4556
    },
    "apps/xmtp.chat/src/components/Conversation/MemberCard.tsx": {
      "content": "import { Avatar, Card, Group, Stack, Text } from \"@mantine/core\";\nimport { forwardRef } from \"react\";\nimport { useMemberPopover } from \"@/components/Conversation/MemberPopover\";\nimport { shortAddress } from \"@/helpers/strings\";\nimport classes from \"./MemberCard.module.css\";\n\nexport type Member = {\n  address: string;\n  displayName: string | null;\n  avatar: string | null;\n  description: string | null;\n};\n\nexport type MemberCardProps = Member & {\n  withClass?: boolean;\n  shortenAddress?: boolean;\n};\n\nexport const MemberCard = forwardRef<HTMLDivElement, MemberCardProps>(\n  (\n    {\n      address,\n      displayName,\n      avatar,\n      description,\n      withClass = true,\n      shortenAddress = true,\n    },\n    ref,\n  ) => {\n    const { setOpened } = useMemberPopover();\n    return (\n      <Card\n        ref={ref}\n        shadow=\"sm\"\n        px=\"xxxs\"\n        py=\"xxs\"\n        radius=\"md\"\n        withBorder\n        onClick={() => {\n          setOpened((o) => !o);\n        }}\n        className={withClass ? classes.member : undefined}\n        tabIndex={0}>\n        <Group gap=\"xxs\" align=\"center\" wrap=\"nowrap\">\n          <Avatar src={avatar} size=\"md\" radius=\"xl\" variant=\"default\" />\n          <Stack gap=\"0\" flex={1} style={{ overflow: \"hidden\" }}>\n            <Text size=\"sm\" truncate>\n              {displayName ||\n                (shortenAddress ? shortAddress(address) : address)}\n            </Text>\n            <Text size=\"xs\" truncate c=\"dimmed\">\n              {description}\n            </Text>\n          </Stack>\n        </Group>\n      </Card>\n    );\n  },\n);\n\nMemberCard.displayName = \"MemberCard\";\n",
      "size_bytes": 1614
    },
    "apps/xmtp.chat/src/components/Messages/MessageList.tsx": {
      "content": "import type { DecodedMessage } from \"@xmtp/browser-sdk\";\nimport { useCallback, useMemo, useRef, type ComponentProps } from \"react\";\nimport { Virtuoso, type VirtuosoHandle } from \"react-virtuoso\";\nimport { Message } from \"./Message\";\nimport classes from \"./MessageList.module.css\";\n\nconst List = (props: ComponentProps<\"div\">) => {\n  return <div className={classes.root} {...props} />;\n};\n\nexport type MessageListProps = {\n  messages: DecodedMessage[];\n};\n\nexport const MessageList: React.FC<MessageListProps> = ({ messages }) => {\n  const virtuoso = useRef<VirtuosoHandle>(null);\n  const messageMap = useMemo(() => {\n    const map = new Map<string, number>();\n    messages.forEach((message, index) => {\n      map.set(message.id, index);\n    });\n    return map;\n  }, [messages]);\n  const scrollToMessage = useCallback(\n    (id: string) => {\n      const index = messageMap.get(id);\n      if (index !== undefined) {\n        virtuoso.current?.scrollToIndex(index);\n      }\n    },\n    [messageMap],\n  );\n  return (\n    <Virtuoso\n      ref={virtuoso}\n      alignToBottom\n      followOutput=\"auto\"\n      style={{ flexGrow: 1 }}\n      components={{\n        List,\n      }}\n      initialTopMostItemIndex={messages.length - 1}\n      data={messages}\n      itemContent={(_, message) => (\n        <Message\n          key={message.id}\n          message={message}\n          scrollToMessage={scrollToMessage}\n        />\n      )}\n    />\n  );\n};\n",
      "size_bytes": 1426
    },
    "apps/xmtp.chat/src/components/Conversation/Composer.tsx": {
      "content": "import {\n  ActionIcon,\n  Box,\n  Button,\n  Group,\n  Menu,\n  Stack,\n  Text,\n  TextInput,\n} from \"@mantine/core\";\nimport {\n  ContentTypeRemoteAttachment,\n  type RemoteAttachment,\n} from \"@xmtp/content-type-remote-attachment\";\nimport { ContentTypeReply } from \"@xmtp/content-type-reply\";\nimport { ContentTypeText } from \"@xmtp/content-type-text\";\nimport { useCallback, useRef, useState } from \"react\";\nimport { Modal } from \"@/components/Modal\";\nimport { useConversationContext } from \"@/contexts/ConversationContext\";\nimport { uploadAttachment, validateFile } from \"@/helpers/attachment\";\nimport { useConversation } from \"@/hooks/useConversation\";\nimport { IconPlus } from \"@/icons/IconPlus\";\nimport { AttachmentPreview } from \"./AttachmentPreview\";\nimport { ReplyPreview } from \"./ReplyPreview\";\nimport classes from \"./Composer.module.css\";\n\nexport type ComposerProps = {\n  conversationId: string;\n};\n\nexport const Composer: React.FC<ComposerProps> = ({ conversationId }) => {\n  const { send, sending } = useConversation(conversationId);\n  const { replyTarget, setReplyTarget } = useConversationContext();\n  const [message, setMessage] = useState(\"\");\n  const [error, setError] = useState<string | null>(null);\n  const [attachment, setAttachment] = useState<File | null>(null);\n  const [uploadingAttachment, setUploadingAttachment] = useState(false);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const remoteAttachmentRef = useRef<RemoteAttachment | null>(null);\n  const isSending = sending || uploadingAttachment;\n  const hasContent = message.trim() !== \"\" || attachment;\n\n  const handleFileSelect = useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      const file = event.target.files?.[0];\n      if (file) {\n        const validation = validateFile(file);\n        if (validation.valid) {\n          setAttachment(file);\n        } else {\n          setError(validation.error);\n        }\n      }\n      if (fileInputRef.current) {\n        fileInputRef.current.value = \"\";\n      }\n    },\n    [],\n  );\n\n  const handleSend = useCallback(async () => {\n    if (!hasContent || isSending) return;\n\n    if (attachment) {\n      try {\n        if (!remoteAttachmentRef.current) {\n          setUploadingAttachment(true);\n          remoteAttachmentRef.current = await uploadAttachment(attachment);\n        }\n      } catch {\n        setError(\"Failed to upload attachment\");\n        return;\n      } finally {\n        setUploadingAttachment(false);\n      }\n\n      try {\n        if (replyTarget) {\n          await send(\n            {\n              reference: replyTarget.id,\n              referenceInboxId: replyTarget.senderInboxId,\n              contentType: ContentTypeRemoteAttachment,\n              content: remoteAttachmentRef.current,\n            },\n            ContentTypeReply,\n          );\n        } else {\n          await send(remoteAttachmentRef.current, ContentTypeRemoteAttachment);\n        }\n        setAttachment(null);\n        remoteAttachmentRef.current = null;\n      } catch {\n        setError(\"Failed to send attachment\");\n        return;\n      }\n    }\n\n    if (message) {\n      try {\n        if (replyTarget) {\n          await send(\n            {\n              reference: replyTarget.id,\n              referenceInboxId: replyTarget.senderInboxId,\n              contentType: ContentTypeText,\n              content: message,\n            },\n            ContentTypeReply,\n          );\n        } else {\n          await send(message, ContentTypeText);\n        }\n        setMessage(\"\");\n      } catch {\n        setError(\"Failed to send message\");\n        return;\n      }\n    }\n\n    setReplyTarget(undefined);\n    setTimeout(() => inputRef.current?.focus(), 50);\n  }, [\n    message,\n    attachment,\n    sending,\n    uploadingAttachment,\n    replyTarget,\n    send,\n    setReplyTarget,\n  ]);\n\n  return (\n    <>\n      <Box className={classes.wrapper}>\n        <Stack gap=\"xs\">\n          {replyTarget && (\n            <ReplyPreview\n              message={replyTarget}\n              disabled={isSending}\n              onCancel={() => {\n                setReplyTarget(undefined);\n              }}\n            />\n          )}\n          {attachment && (\n            <AttachmentPreview\n              file={attachment}\n              disabled={isSending}\n              onCancel={() => {\n                setAttachment(null);\n              }}\n            />\n          )}\n          <div className={classes.composer}>\n            <Menu shadow=\"md\" position=\"top-start\">\n              <Menu.Target>\n                <ActionIcon\n                  className={classes.actionButton}\n                  variant=\"subtle\"\n                  size=\"lg\"\n                  radius=\"xl\"\n                  disabled={isSending}>\n                  <IconPlus size={20} />\n                </ActionIcon>\n              </Menu.Target>\n              <Menu.Dropdown>\n                <Menu.Item onClick={() => fileInputRef.current?.click()}>\n                  <Text fw={500}>Attachment</Text>\n                  <Group align=\"center\" justify=\"space-between\" gap=\"xs\">\n                    <Text size=\"sm\" c=\"dimmed\">\n                      Image / Video / Audio\n                    </Text>\n                    <Text size=\"xs\" fw={500}>\n                      ≤ 1MB\n                    </Text>\n                  </Group>\n                </Menu.Item>\n              </Menu.Dropdown>\n            </Menu>\n            <input\n              ref={fileInputRef}\n              type=\"file\"\n              accept=\"image/*,video/*,audio/*\"\n              onChange={handleFileSelect}\n              style={{ display: \"none\" }}\n            />\n            <TextInput\n              ref={inputRef}\n              disabled={isSending}\n              variant=\"unstyled\"\n              placeholder=\"Type a message...\"\n              value={message}\n              onKeyDown={(e) => {\n                if (e.key === \"Enter\") void handleSend();\n              }}\n              onChange={(e) => {\n                setMessage(e.target.value);\n              }}\n              classNames={{ input: classes.input }}\n            />\n            <Button\n              disabled={!hasContent}\n              loading={isSending}\n              size=\"md\"\n              radius=\"xl\"\n              className={classes.sendButton}\n              variant=\"gradient\"\n              gradient={{ from: \"#0afff1\", to: \"#9772fb\" }}\n              onClick={() => void handleSend()}>\n              Send\n            </Button>\n          </div>\n        </Stack>\n      </Box>\n      {error && (\n        <Modal\n          opened\n          centered\n          withCloseButton={false}\n          closeOnEscape={false}\n          closeOnClickOutside={false}\n          size=\"auto\"\n          title=\"Error\"\n          onClose={() => {\n            setError(null);\n          }}>\n          <Text ta=\"center\" size=\"sm\">\n            {error}\n          </Text>\n          <Group mt=\"md\" justify=\"flex-end\">\n            <Button\n              onClick={() => {\n                setError(null);\n              }}>\n              OK\n            </Button>\n          </Group>\n        </Modal>\n      )}\n    </>\n  );\n};\n",
      "size_bytes": 7145
    },
    "sdks/browser-sdk/src/types/actions/conversation.ts": {
      "content": "import type { ConsentState } from \"@xmtp/wasm-bindings\";\nimport type {\n  SafeConversation,\n  SafeConversationDebugInfo,\n  SafeEncodedContent,\n  SafeGroupMember,\n  SafeHmacKey,\n  SafeListMessagesOptions,\n  SafeMessage,\n  SafeMessageDisappearingSettings,\n} from \"@/utils/conversions\";\n\nexport type ConversationAction =\n  | {\n      action: \"conversation.sync\";\n      id: string;\n      result: SafeConversation;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversation.send\";\n      id: string;\n      result: string;\n      data: {\n        id: string;\n        content: SafeEncodedContent;\n      };\n    }\n  | {\n      action: \"conversation.sendOptimistic\";\n      id: string;\n      result: string;\n      data: {\n        id: string;\n        content: SafeEncodedContent;\n      };\n    }\n  | {\n      action: \"conversation.publishMessages\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversation.messages\";\n      id: string;\n      result: SafeMessage[];\n      data: {\n        id: string;\n        options?: SafeListMessagesOptions;\n      };\n    }\n  | {\n      action: \"conversation.members\";\n      id: string;\n      result: SafeGroupMember[];\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversation.messageDisappearingSettings\";\n      id: string;\n      result: SafeMessageDisappearingSettings | undefined;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversation.updateMessageDisappearingSettings\";\n      id: string;\n      result: undefined;\n      data: SafeMessageDisappearingSettings & {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversation.removeMessageDisappearingSettings\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversation.isMessageDisappearingEnabled\";\n      id: string;\n      result: boolean;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversation.stream\";\n      id: string;\n      result: undefined;\n      data: {\n        groupId: string;\n        streamId: string;\n      };\n    }\n  | {\n      action: \"conversation.pausedForVersion\";\n      id: string;\n      result: string | undefined;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversation.getHmacKeys\";\n      id: string;\n      result: Map<string, SafeHmacKey[]>;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversation.debugInfo\";\n      id: string;\n      result: SafeConversationDebugInfo;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversation.consentState\";\n      id: string;\n      result: ConsentState;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversation.updateConsentState\";\n      id: string;\n      result: undefined;\n      data: {\n        id: string;\n        state: ConsentState;\n      };\n    }\n  | {\n      action: \"conversation.lastMessage\";\n      id: string;\n      result: SafeMessage | undefined;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversation.isActive\";\n      id: string;\n      result: boolean;\n      data: {\n        id: string;\n      };\n    };\n",
      "size_bytes": 3217
    },
    "apps/xmtp.chat-api-service/src/api/v1/pinata.router.ts": {
      "content": "import { Router, type Request, type Response } from \"express\";\nimport { PinataSDK } from \"pinata\";\n\nconst pinata = new PinataSDK({\n  pinataJwt: process.env.PINATA_JWT,\n  pinataGateway: process.env.PINATA_GATEWAY,\n});\n\nexport async function getPresignedUrl(req: Request, res: Response) {\n  try {\n    const url = await pinata.upload.public.createSignedURL({\n      expires: 60, // Last for 60 seconds\n      groupId: process.env.PINATA_GROUP_ID,\n    });\n\n    res.json({ url });\n  } catch {\n    throw new Error(\"Failed to generate presigned URL\");\n  }\n}\n\nconst pinataRouter = Router();\n\npinataRouter.get(\"/presigned-url\", getPresignedUrl);\n\nexport default pinataRouter;\n",
      "size_bytes": 665
    },
    "apps/xmtp.chat/src/components/Messages/GroupUpdatedContent.tsx": {
      "content": "import { Group, Stack, Text } from \"@mantine/core\";\nimport { Dm } from \"@xmtp/browser-sdk\";\nimport type { GroupUpdated } from \"@xmtp/content-type-group-updated\";\nimport { useMemo } from \"react\";\nimport { DateLabel } from \"@/components/DateLabel\";\nimport { Identity } from \"@/components/Identity\";\nimport { IdentityBadge } from \"@/components/IdentityBadge\";\nimport { useConversationContext } from \"@/contexts/ConversationContext\";\nimport { nsToDate } from \"@/helpers/date\";\nimport { MEMBER_NO_LONGER_IN_GROUP, shortAddress } from \"@/helpers/strings\";\nimport { getMemberAddress } from \"@/helpers/xmtp\";\nimport { useConversation } from \"@/hooks/useConversation\";\nimport { combineProfiles, useAllProfiles } from \"@/stores/profiles\";\n\ntype GroupMembersAddedContentProps = {\n  type: \"added\" | \"removed\";\n  updatedMembers: string[];\n  initiatedBy: string;\n};\n\nconst GroupMembersUpdatedContent: React.FC<GroupMembersAddedContentProps> = ({\n  type,\n  updatedMembers,\n  initiatedBy,\n}) => {\n  const { conversationId } = useConversationContext();\n  const { members, conversation } = useConversation(conversationId);\n  const profiles = useAllProfiles();\n  const initiatedByMember = members.get(initiatedBy);\n  return (\n    <Group gap=\"4\" wrap=\"wrap\" justify=\"center\">\n      {initiatedByMember ? (\n        <Identity\n          {...combineProfiles(\n            getMemberAddress(initiatedByMember),\n            profiles.get(getMemberAddress(initiatedByMember)) ?? [],\n          )}\n          permissionLevel={initiatedByMember.permissionLevel}\n          conversationId={conversationId}\n          inboxId={initiatedBy}\n          showDm={!(conversation instanceof Dm)}\n          position=\"top\"\n        />\n      ) : (\n        <IdentityBadge\n          address=\"\"\n          displayName={shortAddress(initiatedBy)}\n          tooltip={MEMBER_NO_LONGER_IN_GROUP}\n        />\n      )}\n      <Text size=\"sm\">{type === \"added\" ? \"added\" : \"removed\"}</Text>\n      {updatedMembers.map((member) => {\n        const memberMember = members.get(member);\n        if (!memberMember) {\n          return (\n            <IdentityBadge\n              key={member}\n              address=\"\"\n              displayName={shortAddress(member)}\n              tooltip={MEMBER_NO_LONGER_IN_GROUP}\n            />\n          );\n        }\n        const address = getMemberAddress(memberMember);\n        const profile = combineProfiles(address, profiles.get(address) ?? []);\n        return (\n          <Identity\n            key={member}\n            address={address}\n            avatar={profile.avatar}\n            description={profile.description}\n            displayName={profile.displayName}\n            conversationId={conversationId}\n            permissionLevel={memberMember.permissionLevel}\n            inboxId={member}\n            showDm={!(conversation instanceof Dm)}\n            position=\"top\"\n          />\n        );\n      })}\n      <Text size=\"sm\">{type === \"added\" ? \"to\" : \"from\"} the group</Text>\n    </Group>\n  );\n};\n\ntype GroupMetadataUpdatedContentProps = {\n  metadataFieldChange: GroupUpdated[\"metadataFieldChanges\"][number];\n  initiatedBy: string;\n};\n\nconst GroupMetadataUpdatedContent: React.FC<\n  GroupMetadataUpdatedContentProps\n> = ({ metadataFieldChange, initiatedBy }) => {\n  const { conversationId } = useConversationContext();\n  const { members, conversation } = useConversation(conversationId);\n  const profiles = useAllProfiles();\n  const initiatedByMember = members.get(initiatedBy);\n  const field = useMemo(() => {\n    switch (metadataFieldChange.fieldName) {\n      case \"group_name\":\n        return \"name\";\n      case \"description\":\n        return \"description\";\n      case \"group_image_url_square\":\n        return \"image URL\";\n      case \"_commit_log_signer\":\n        return \"commit log signer\";\n      default:\n        return metadataFieldChange.fieldName;\n    }\n  }, [metadataFieldChange.fieldName]);\n\n  return (\n    <Group gap=\"4\" wrap=\"wrap\" justify=\"center\">\n      {initiatedByMember ? (\n        <Identity\n          {...combineProfiles(\n            getMemberAddress(initiatedByMember),\n            profiles.get(getMemberAddress(initiatedByMember)) ?? [],\n          )}\n          permissionLevel={initiatedByMember.permissionLevel}\n          conversationId={conversationId}\n          inboxId={initiatedBy}\n          showDm={!(conversation instanceof Dm)}\n          position=\"top\"\n        />\n      ) : (\n        <IdentityBadge\n          address=\"\"\n          displayName={shortAddress(initiatedBy)}\n          tooltip={MEMBER_NO_LONGER_IN_GROUP}\n        />\n      )}\n      <Text size=\"sm\">\n        {metadataFieldChange.newValue ? \"changed\" : \"removed\"} the group\n      </Text>\n      <Text size=\"sm\">{field}</Text>\n      {metadataFieldChange.newValue !== \"\" && (\n        <>\n          <Text size=\"sm\">to</Text>\n          <Text size=\"sm\" fw={700} truncate>\n            {metadataFieldChange.newValue}\n          </Text>\n        </>\n      )}\n    </Group>\n  );\n};\n\nexport type GroupUpdatedContentProps = {\n  content: GroupUpdated;\n  sentAtNs: bigint;\n};\n\nexport const GroupUpdatedContent: React.FC<GroupUpdatedContentProps> = ({\n  content,\n  sentAtNs,\n}) => {\n  if (content.addedInboxes.length > 0) {\n    return (\n      <Stack gap=\"xxxs\" align=\"center\">\n        <DateLabel date={nsToDate(sentAtNs)} align=\"center\" padding=\"sm\" />\n        <GroupMembersUpdatedContent\n          type=\"added\"\n          updatedMembers={content.addedInboxes.map((inbox) => inbox.inboxId)}\n          initiatedBy={content.initiatedByInboxId}\n        />\n      </Stack>\n    );\n  }\n\n  if (content.removedInboxes.length > 0) {\n    return (\n      <Stack gap=\"xxxs\" align=\"center\">\n        <DateLabel date={nsToDate(sentAtNs)} align=\"center\" padding=\"sm\" />\n        <GroupMembersUpdatedContent\n          type=\"removed\"\n          updatedMembers={content.removedInboxes.map((inbox) => inbox.inboxId)}\n          initiatedBy={content.initiatedByInboxId}\n        />\n      </Stack>\n    );\n  }\n\n  if (content.metadataFieldChanges.length > 0) {\n    return (\n      <Stack gap=\"xxxs\" align=\"center\">\n        <DateLabel date={nsToDate(sentAtNs)} align=\"center\" padding=\"sm\" />\n        {content.metadataFieldChanges.map((change) => (\n          <GroupMetadataUpdatedContent\n            key={change.fieldName}\n            metadataFieldChange={change}\n            initiatedBy={content.initiatedByInboxId}\n          />\n        ))}\n      </Stack>\n    );\n  }\n\n  return (\n    <Stack gap=\"xxxs\" align=\"center\">\n      <DateLabel date={nsToDate(sentAtNs)} align=\"center\" padding=\"sm\" />\n      <Text>Unknown permissions update</Text>\n    </Stack>\n  );\n};\n",
      "size_bytes": 6570
    },
    "content-types/content-type-markdown/rollup.config.js": {
      "content": "import terser from \"@rollup/plugin-terser\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { defineConfig } from \"rollup\";\nimport { dts } from \"rollup-plugin-dts\";\n\nconst plugins = [\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n];\n\nconst external = [\"@xmtp/content-type-primitives\"];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/browser/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins: [...plugins, terser()],\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.d.ts\",\n      format: \"es\",\n    },\n    plugins: [dts()],\n  },\n]);\n",
      "size_bytes": 832
    },
    "apps/xmtp.chat/src/hooks/useConnectXmtp.ts": {
      "content": "import { useCallback, useEffect } from \"react\";\nimport { useNavigate } from \"react-router\";\nimport { hexToUint8Array } from \"uint8array-extras\";\nimport { useAccount, useSignMessage } from \"wagmi\";\nimport { useXMTP } from \"@/contexts/XMTPContext\";\nimport { createEOASigner, createSCWSigner } from \"@/helpers/createSigner\";\nimport { useEphemeralSigner } from \"@/hooks/useEphemeralSigner\";\nimport { useSettings } from \"@/hooks/useSettings\";\n\nexport const useConnectXmtp = () => {\n  const navigate = useNavigate();\n  const { signer: ephemeralSigner } = useEphemeralSigner();\n  const { initializing, client, initialize } = useXMTP();\n  const account = useAccount();\n  const { signMessageAsync } = useSignMessage();\n  const {\n    encryptionKey,\n    environment,\n    ephemeralAccountEnabled,\n    ephemeralAccountKey,\n    setEphemeralAccountKey,\n    loggingLevel,\n    useSCW,\n    autoConnect,\n    setAutoConnect,\n  } = useSettings();\n\n  const connect = useCallback(() => {\n    // if client is already connected, return\n    if (client) {\n      return;\n    }\n\n    // connect ephemeral account if enabled\n    if (ephemeralAccountEnabled) {\n      void initialize({\n        dbEncryptionKey: encryptionKey\n          ? hexToUint8Array(encryptionKey)\n          : undefined,\n        env: environment,\n        loggingLevel,\n        signer: ephemeralSigner,\n      });\n      setAutoConnect(true);\n      return;\n    }\n\n    // if wallet is not connected or SCW is enabled but chain is not set, return\n    if (!account.address || (useSCW && !account.chainId)) {\n      return;\n    }\n\n    void initialize({\n      dbEncryptionKey: encryptionKey\n        ? hexToUint8Array(encryptionKey)\n        : undefined,\n      env: environment,\n      loggingLevel,\n      signer: useSCW\n        ? createSCWSigner(\n            account.address,\n            (message: string) => signMessageAsync({ message }),\n            account.chainId,\n          )\n        : createEOASigner(account.address, (message: string) =>\n            signMessageAsync({ message }),\n          ),\n    });\n    setAutoConnect(true);\n  }, [\n    client,\n    initialize,\n    setEphemeralAccountKey,\n    ephemeralAccountEnabled,\n    ephemeralAccountKey,\n    encryptionKey,\n    environment,\n    loggingLevel,\n    useSCW,\n    account.address,\n    account.chainId,\n    signMessageAsync,\n    setAutoConnect,\n  ]);\n\n  useEffect(() => {\n    if (client) {\n      void navigate(\"/\");\n    } else if (autoConnect) {\n      connect();\n    }\n  }, [client, navigate, autoConnect, connect]);\n\n  return {\n    client,\n    loading: initializing,\n    connect,\n  };\n};\n",
      "size_bytes": 2572
    },
    "apps/xmtp.chat/src/components/App/ConnectXMTP.tsx": {
      "content": "import { Button, Group, Paper, Stack } from \"@mantine/core\";\nimport { useCallback } from \"react\";\nimport { ConnectedAddress } from \"@/components/App/ConnectedAddress\";\nimport { LoggingSelect } from \"@/components/App/LoggingSelect\";\nimport { NetworkSelect } from \"@/components/App/NetworkSelect\";\nimport { useConnectWallet } from \"@/hooks/useConnectWallet\";\nimport { useConnectXmtp } from \"@/hooks/useConnectXmtp\";\nimport { useEphemeralSigner } from \"@/hooks/useEphemeralSigner\";\nimport { useSettings } from \"@/hooks/useSettings\";\nimport classes from \"./ConnectXMTP.module.css\";\n\nexport type ConnectXMTPProps = {\n  onDisconnectWallet: () => void;\n};\n\nexport const ConnectXMTP = ({ onDisconnectWallet }: ConnectXMTPProps) => {\n  const { isConnected, address } = useConnectWallet();\n  const { address: ephemeralAddress } = useEphemeralSigner();\n  const { connect, loading } = useConnectXmtp();\n  const { ephemeralAccountEnabled } = useSettings();\n\n  const handleConnectClick = useCallback(() => {\n    connect();\n  }, [connect]);\n\n  return (\n    <Paper withBorder radius=\"md\">\n      <Stack gap=\"xs\">\n        <Stack gap=\"md\" p=\"md\">\n          <NetworkSelect />\n          <LoggingSelect />\n        </Stack>\n        <Group\n          justify=\"space-between\"\n          align=\"center\"\n          p=\"md\"\n          className={classes.actions}>\n          <ConnectedAddress\n            size=\"sm\"\n            address={address ?? ephemeralAddress}\n            onClick={onDisconnectWallet}\n          />\n          <Group gap=\"xs\" align=\"center\">\n            <Button\n              disabled={!isConnected && !ephemeralAccountEnabled}\n              onClick={handleConnectClick}\n              loading={loading}>\n              Connect\n            </Button>\n          </Group>\n        </Group>\n      </Stack>\n    </Paper>\n  );\n};\n",
      "size_bytes": 1805
    },
    "CONTRIBUTING.md": {
      "content": "# Contributing\n\nThank you for considering contributing to this repo! Community contributions like yours are key to the development and adoption of XMTP. Your questions, feedback, suggestions, and code contributions are welcome!\n\n## ❔ Questions\n\nHave a question about how to build with XMTP? Ask your question and learn with the community in the [XMTP Community Forums](https://community.xmtp.org/).\n\n## 🐞 Bugs\n\nReport a bug using [GitHub Issues](https://github.com/xmtp/xmtp-js/issues/new/choose).\n\n## ✨ Feature Requests\n\nWe are not accepting feature requests at this time.\n\n## 🔀 Pull Requests\n\nPRs are encouraged, but consider starting with a feature request to temperature-check first. If the PR involves a major change to the protocol, the work should be fleshed out as an [XMTP Improvement Proposal](https://community.xmtp.org/t/xip-0-xip-purpose-process-guidelines/475) before work begins.\n\nAfter a pull request is submitted, a single approval is required to merge it.\n\n### AI-Generated Contributions Policy\n\nWe do not accept pull requests that are generated entirely or primarily by AI/LLM tools (e.g., GitHub Copilot, ChatGPT, Claude). This includes:\n\n- Automated typo fixes or formatting changes\n- Generic code improvements without context\n- Mass automated updates or refactoring\n\nPull requests that appear to be AI-generated without meaningful human oversight will be closed without review. We value human-driven, thoughtful contributions that demonstrate an understanding of the codebase and project goals.\n\n> [!CAUTION]\n> To protect project quality and maintain contributor trust, we will restrict access for users who continue to submit AI-generated pull requests.\n\nIf you use AI tools to assist your development process, please:\n\n1. Thoroughly review and understand all generated code\n2. Provide detailed PR descriptions explaining your changes and reasoning\n3. Be prepared to discuss your implementation decisions and how they align with the project goals\n\n## 🔧 Developing\n\n### Prerequisites\n\n#### Node\n\nPlease make sure you have a compatible version as specified in `package.json`. We recommend using a Node version manager such as [nvm](https://github.com/nvm-sh/nvm) or [nodenv](https://github.com/nodenv/nodenv).\n\n#### Yarn\n\nThis repository uses the [Yarn package manager](https://yarnpkg.com/). To use it, enable [Corepack](https://yarnpkg.com/corepack), if it isn't already, by running `corepack enable`.\n\n### Useful commands\n\n- `yarn`: Installs all dependencies\n- `yarn build`: Builds all packages in the `/packages` folder\n- `yarn clean`: Remove all `node_modules`, `.turbo`, and build folders, clear Yarn cache\n- `yarn format`: Run prettier format and write changes\n- `yarn format:check`: Run prettier format check\n- `yarn test`: Run the unit test suite\n- `yarn test:setup`: Start a local development node using Docker (only needs to be run once)\n- `yarn lint`: Lint with ESLint\n- `yarn typecheck`: Typecheck with `tsc`\n\n### Testing\n\nPlease add unit tests when appropriate and ensure that all unit tests are passing before submitting a pull request. Note that some unit tests require a local XMTP backend environment.\n\n1. Run `yarn test:setup` from the **root directory** to start the required backend services using Docker:\n   - XMTP node\n   - PostgreSQL databases\n   - MLS validation service\n   - Upload service\n   - History server\n\n2. After setup, run `yarn test` in the **project directory** to execute the desired test suite\n\n3. When finished testing, stop all backend services by running this command from the **root directory**:\n\n```bash\nyarn test:teardown\n```\n\n**Important**: If the backend services are not running, tests will likely fail with `transport error` messages.\n\n## 🚢 Publishing\n\nThis repository uses [changesets](https://github.com/changesets/changesets) to publish updates. Pull requests must contain a changeset in order for changes to be published. The [changeset-bot](https://github.com/apps/changeset-bot) will guide you through this process.\n",
      "size_bytes": 4009
    },
    "apps/xmtp.chat/src/components/Messages/MarkdownContent.tsx": {
      "content": "import { Paper } from \"@mantine/core\";\nimport { Markdown } from \"@/components/Markdown\";\nimport classes from \"./MarkdownContent.module.css\";\n\nexport type MarkdownContentProps = {\n  content: string;\n  align?: \"left\" | \"right\";\n};\n\nexport const MarkdownContent: React.FC<MarkdownContentProps> = ({\n  content,\n  align = \"left\",\n}) => {\n  const bubbleClass = align === \"right\" ? classes.outbound : classes.inbound;\n  return (\n    <Paper\n      className={[classes.root, bubbleClass].join(\" \")}\n      onClick={(event) => {\n        event.stopPropagation();\n      }}\n      py=\"xs\"\n      px=\"sm\"\n      radius=\"md\">\n      <Markdown markdown={content} />\n    </Paper>\n  );\n};\n",
      "size_bytes": 665
    },
    "apps/xmtp.chat/src/components/Messages/Message.module.css": {
      "content": ".root {\n  cursor: default;\n}\n\n.root:hover {\n  background-color: transparent;\n}\n\n.root:focus {\n  outline: none;\n}\n",
      "size_bytes": 113
    },
    "sdks/browser-sdk/src/WorkerConversation.ts": {
      "content": "import {\n  MessageDisappearingSettings,\n  SortDirection,\n  type ConsentState,\n  type Conversation,\n  type ConversationDebugInfo,\n  type EncodedContent,\n  type GroupMember,\n  type HmacKey,\n  type Identifier,\n  type Message,\n  type MetadataField,\n  type PermissionPolicy,\n  type PermissionUpdateType,\n} from \"@xmtp/wasm-bindings\";\nimport {\n  fromSafeListMessagesOptions,\n  toSafeGroupMember,\n  type SafeListMessagesOptions,\n} from \"@/utils/conversions\";\nimport type { StreamCallback } from \"@/utils/streams\";\nimport type { WorkerClient } from \"@/WorkerClient\";\n\nexport class WorkerConversation {\n  #client: WorkerClient;\n  #group: Conversation;\n  #isCommitLogForked?: boolean;\n\n  constructor(\n    client: WorkerClient,\n    group: Conversation,\n    isCommitLogForked?: boolean,\n  ) {\n    this.#client = client;\n    this.#group = group;\n    this.#isCommitLogForked = isCommitLogForked;\n  }\n\n  get id() {\n    return this.#group.id();\n  }\n\n  get name() {\n    return this.#group.groupName();\n  }\n\n  async updateName(name: string) {\n    return this.#group.updateGroupName(name);\n  }\n\n  get imageUrl() {\n    return this.#group.groupImageUrlSquare();\n  }\n\n  async updateImageUrl(imageUrl: string) {\n    return this.#group.updateGroupImageUrlSquare(imageUrl);\n  }\n\n  get description() {\n    return this.#group.groupDescription();\n  }\n\n  async updateDescription(description: string) {\n    return this.#group.updateGroupDescription(description);\n  }\n\n  get isActive() {\n    return this.#group.isActive();\n  }\n\n  get isCommitLogForked() {\n    return this.#isCommitLogForked;\n  }\n\n  get addedByInboxId() {\n    return this.#group.addedByInboxId();\n  }\n\n  get createdAtNs() {\n    return this.#group.createdAtNs();\n  }\n\n  async lastMessage() {\n    const messages = await this.messages({\n      limit: 1n,\n      direction: SortDirection.Descending,\n    });\n    if (messages.length > 0) {\n      return messages[0];\n    }\n    return undefined;\n  }\n\n  async metadata() {\n    const metadata = await this.#group.groupMetadata();\n    return {\n      creatorInboxId: metadata.creatorInboxId(),\n      conversationType: metadata.conversationType(),\n    };\n  }\n\n  async members() {\n    const members = (await this.#group.listMembers()) as GroupMember[];\n    return members.map((member) => toSafeGroupMember(member));\n  }\n\n  get admins() {\n    return this.#group.adminList();\n  }\n\n  get superAdmins() {\n    return this.#group.superAdminList();\n  }\n\n  get permissions() {\n    const permissions = this.#group.groupPermissions();\n    return {\n      policyType: permissions.policyType(),\n      policySet: permissions.policySet(),\n    };\n  }\n\n  async updatePermission(\n    permissionType: PermissionUpdateType,\n    policy: PermissionPolicy,\n    metadataField?: MetadataField,\n  ) {\n    return this.#group.updatePermissionPolicy(\n      permissionType,\n      policy,\n      metadataField,\n    );\n  }\n\n  isAdmin(inboxId: string) {\n    return this.#group.isAdmin(inboxId);\n  }\n\n  isSuperAdmin(inboxId: string) {\n    return this.#group.isSuperAdmin(inboxId);\n  }\n\n  async sync() {\n    return this.#group.sync();\n  }\n\n  async addMembersByIdentifiers(identifiers: Identifier[]) {\n    return this.#group.addMembers(identifiers);\n  }\n\n  async addMembers(inboxIds: string[]) {\n    return this.#group.addMembersByInboxId(inboxIds);\n  }\n\n  async removeMembersByIdentifiers(identifiers: Identifier[]) {\n    return this.#group.removeMembers(identifiers);\n  }\n\n  async removeMembers(inboxIds: string[]) {\n    return this.#group.removeMembersByInboxId(inboxIds);\n  }\n\n  async addAdmin(inboxId: string) {\n    return this.#group.addAdmin(inboxId);\n  }\n\n  async removeAdmin(inboxId: string) {\n    return this.#group.removeAdmin(inboxId);\n  }\n\n  async addSuperAdmin(inboxId: string) {\n    return this.#group.addSuperAdmin(inboxId);\n  }\n\n  async removeSuperAdmin(inboxId: string) {\n    return this.#group.removeSuperAdmin(inboxId);\n  }\n\n  async publishMessages() {\n    return this.#group.publishMessages();\n  }\n\n  sendOptimistic(encodedContent: EncodedContent) {\n    return this.#group.sendOptimistic(encodedContent);\n  }\n\n  async send(encodedContent: EncodedContent) {\n    return this.#group.send(encodedContent);\n  }\n\n  async messages(options?: SafeListMessagesOptions) {\n    return this.#group.findMessages(\n      options ? fromSafeListMessagesOptions(options) : undefined,\n    );\n  }\n\n  get consentState() {\n    return this.#group.consentState();\n  }\n\n  updateConsentState(state: ConsentState) {\n    this.#group.updateConsentState(state);\n  }\n\n  dmPeerInboxId() {\n    return this.#group.dmPeerInboxId();\n  }\n\n  messageDisappearingSettings() {\n    return this.#group.messageDisappearingSettings();\n  }\n\n  async updateMessageDisappearingSettings(fromNs: bigint, inNs: bigint) {\n    const settings = new MessageDisappearingSettings(fromNs, inNs);\n    return this.#group.updateMessageDisappearingSettings(settings);\n  }\n\n  async removeMessageDisappearingSettings() {\n    return this.#group.removeMessageDisappearingSettings();\n  }\n\n  isMessageDisappearingEnabled() {\n    return this.#group.isMessageDisappearingEnabled();\n  }\n\n  stream(callback: StreamCallback<Message>, onFail: () => void) {\n    const on_message = (message: Message) => {\n      callback(null, message);\n    };\n    const on_error = (error: Error | null) => {\n      callback(error, undefined);\n    };\n    const on_close = () => {\n      onFail();\n    };\n    return this.#group.stream({ on_message, on_error, on_close });\n  }\n\n  pausedForVersion() {\n    return this.#group.pausedForVersion();\n  }\n\n  getHmacKeys() {\n    return this.#group.getHmacKeys() as Map<string, HmacKey[]>;\n  }\n\n  async debugInfo() {\n    return (await this.#group.getDebugInfo()) as ConversationDebugInfo;\n  }\n\n  async getDuplicateDms() {\n    const dms = await this.#group.findDuplicateDms();\n    return dms.map((dm) => new WorkerConversation(this.#client, dm));\n  }\n}\n",
      "size_bytes": 5847
    },
    "sdks/node-sdk/test/validation.test.ts": {
      "content": "import { describe, expect, it } from \"vitest\";\nimport { isHexString } from \"@/utils/validation\";\n\ndescribe(\"isHexString\", () => {\n  it(\"returns true for valid hex strings\", () => {\n    const valid = [\n      \"0xab\",\n      \"0xabcd\",\n      \"0xABCD\",\n      \"0x0123456789abcdefABCDEF\",\n    ] as const;\n\n    for (const value of valid) {\n      expect(isHexString(value)).toBe(true);\n    }\n  });\n\n  it(\"returns false for invalid hex strings\", () => {\n    const invalid = [\"0x\", \"123\", \"0xg\", \"0X123\", \"0x123\"] as const;\n\n    for (const value of invalid) {\n      expect(isHexString(value)).toBe(false);\n    }\n  });\n\n  it(\"returns false for non-string values\", () => {\n    const invalid = [123, null, undefined, {}, []] as const;\n\n    for (const value of invalid) {\n      expect(isHexString(value)).toBe(false);\n    }\n  });\n});\n",
      "size_bytes": 818
    },
    "apps/xmtp.chat/src/components/Conversation/Member.tsx": {
      "content": "import { Button, Group } from \"@mantine/core\";\nimport {\n  MemberCard,\n  type Member as MemberCardMember,\n} from \"@/components/Conversation/MemberCard\";\nimport classes from \"./Member.module.css\";\n\nexport type MemberProps = MemberCardMember & {\n  onClick?: () => void;\n  buttonLabel?: string;\n};\n\nexport const Member: React.FC<MemberProps> = ({\n  address,\n  displayName,\n  avatar,\n  description,\n  onClick,\n  buttonLabel = \"Remove\",\n}) => {\n  return (\n    <Group\n      justify=\"space-between\"\n      align=\"center\"\n      wrap=\"nowrap\"\n      p=\"xxxs\"\n      className={classes.root}>\n      <MemberCard\n        address={address}\n        displayName={displayName}\n        avatar={avatar}\n        description={description}\n        withClass={false}\n        shortenAddress={false}\n      />\n      {onClick && (\n        <Group className={classes.button} align=\"center\" justify=\"center\">\n          <Button size=\"xs\" onClick={onClick}>\n            {buttonLabel}\n          </Button>\n        </Group>\n      )}\n    </Group>\n  );\n};\n",
      "size_bytes": 1016
    },
    "sdks/node-sdk/src/Conversations.ts": {
      "content": "import {\n  ConversationType,\n  type ConsentState,\n  type Conversation,\n  type CreateDmOptions,\n  type CreateGroupOptions,\n  type Identifier,\n  type ListConversationsOptions,\n  type Message,\n  type Conversations as XmtpConversations,\n} from \"@xmtp/node-bindings\";\nimport type { Client } from \"@/Client\";\nimport { DecodedMessage } from \"@/DecodedMessage\";\nimport { Dm } from \"@/Dm\";\nimport { Group } from \"@/Group\";\nimport {\n  createStream,\n  type StreamCallback,\n  type StreamOptions,\n} from \"@/utils/streams\";\n\n/**\n * Manages conversations\n *\n * This class is not intended to be initialized directly.\n */\nexport class Conversations<ContentTypes = unknown> {\n  #client: Client<ContentTypes>;\n  #conversations: XmtpConversations;\n\n  /**\n   * Creates a new conversations instance\n   *\n   * @param client - The client instance managing the conversations\n   * @param conversations - The underlying conversations instance\n   */\n  constructor(client: Client<ContentTypes>, conversations: XmtpConversations) {\n    this.#client = client;\n    this.#conversations = conversations;\n  }\n\n  /**\n   * Retrieves a conversation by its ID\n   *\n   * @param id - The conversation ID to look up\n   * @returns The conversation if found, undefined otherwise\n   * @see https://docs.xmtp.org/chat-apps/core-messaging/create-conversations#conversation-helper-methods\n   */\n  async getConversationById(id: string) {\n    try {\n      // findGroupById will throw if group is not found\n      const group = this.#conversations.findGroupById(id);\n      const metadata = await group.groupMetadata();\n      return metadata.conversationType() === \"group\"\n        ? new Group(this.#client, group)\n        : new Dm(this.#client, group);\n    } catch {\n      return undefined;\n    }\n  }\n\n  /**\n   * Retrieves a DM by inbox ID\n   *\n   * @param inboxId - The inbox ID to look up\n   * @returns The DM if found, undefined otherwise\n   * @see https://docs.xmtp.org/chat-apps/core-messaging/create-conversations#conversation-helper-methods\n   */\n  getDmByInboxId(inboxId: string) {\n    try {\n      // findDmByTargetInboxId will throw if group is not found\n      const group = this.#conversations.findDmByTargetInboxId(inboxId);\n      return new Dm(this.#client, group);\n    } catch {\n      return undefined;\n    }\n  }\n\n  /**\n   * Retrieves a message by its ID\n   *\n   * @param id - The message ID to look up\n   * @returns The decoded message if found, undefined otherwise\n   * @see https://docs.xmtp.org/chat-apps/core-messaging/create-conversations#conversation-helper-methods\n   */\n  getMessageById(id: string) {\n    try {\n      // findMessageById will throw if message is not found\n      const message = this.#conversations.findMessageById(id);\n      return new DecodedMessage(this.#client, message);\n    } catch {\n      return undefined;\n    }\n  }\n\n  /**\n   * Creates a new group conversation without syncing to the network\n   *\n   * @param options - Optional group creation options\n   * @returns The new group\n   * @see https://docs.xmtp.org/chat-apps/core-messaging/create-conversations#optimistically-create-a-new-group-chat\n   */\n  newGroupOptimistic(options?: CreateGroupOptions) {\n    const group = this.#conversations.createGroupOptimistic(options);\n    return new Group(this.#client, group);\n  }\n\n  /**\n   * Creates a new group conversation with the specified identifiers\n   *\n   * @param identifiers - Array of identifiers for group members\n   * @param options - Optional group creation options\n   * @returns The new group\n   * @see https://docs.xmtp.org/chat-apps/core-messaging/create-conversations#create-a-new-group-chat\n   */\n  async newGroupWithIdentifiers(\n    identifiers: Identifier[],\n    options?: CreateGroupOptions,\n  ) {\n    const group = await this.#conversations.createGroup(identifiers, options);\n    const conversation = new Group(this.#client, group);\n    return conversation;\n  }\n\n  /**\n   * Creates a new group conversation with the specified inbox IDs\n   *\n   * @param inboxIds - Array of inbox IDs for group members\n   * @param options - Optional group creation options\n   * @returns The new group\n   * @see https://docs.xmtp.org/chat-apps/core-messaging/create-conversations#create-a-new-group-chat\n   */\n  async newGroup(inboxIds: string[], options?: CreateGroupOptions) {\n    const group = await this.#conversations.createGroupByInboxId(\n      inboxIds,\n      options,\n    );\n    const conversation = new Group(this.#client, group);\n    return conversation;\n  }\n\n  /**\n   * Creates a new DM conversation with the specified identifier\n   *\n   * @param identifier - Identifier for the DM recipient\n   * @param options - Optional DM creation options\n   * @returns The new DM\n   * @see https://docs.xmtp.org/agents/build-agents/create-conversations#by-ethereum-address-1\n   */\n  async newDmWithIdentifier(identifier: Identifier, options?: CreateDmOptions) {\n    const group = await this.#conversations.createDm(identifier, options);\n    const conversation = new Dm(this.#client, group);\n    return conversation;\n  }\n\n  /**\n   * Creates a new DM conversation with the specified inbox ID\n   *\n   * @param inboxId - Inbox ID for the DM recipient\n   * @param options - Optional DM creation options\n   * @returns The new DM\n   * @see https://docs.xmtp.org/agents/build-agents/create-conversations#by-inbox-id-1\n   */\n  async newDm(inboxId: string, options?: CreateDmOptions) {\n    const group = await this.#conversations.createDmByInboxId(inboxId, options);\n    const conversation = new Dm(this.#client, group);\n    return conversation;\n  }\n\n  /**\n   * Lists all conversations with optional filtering\n   *\n   * @param options - Optional filtering and pagination options\n   * @returns Array of conversations\n   * @see https://docs.xmtp.org/chat-apps/list-stream-sync/list\n   */\n  async list(options?: ListConversationsOptions) {\n    const groups = this.#conversations.list(options);\n    const conversations = await Promise.all(\n      groups.map(async (item) => {\n        const metadata = await item.conversation.groupMetadata();\n        const conversationType = metadata.conversationType();\n        switch (conversationType) {\n          case \"dm\":\n            return new Dm(\n              this.#client,\n              item.conversation,\n              item.isCommitLogForked,\n            );\n          case \"group\":\n            return new Group(\n              this.#client,\n              item.conversation,\n              item.isCommitLogForked,\n            );\n          default:\n            return undefined;\n        }\n      }),\n    );\n    return conversations.filter((conversation) => conversation !== undefined);\n  }\n\n  /**\n   * Lists all groups with optional filtering\n   *\n   * @param options - Optional filtering and pagination options\n   * @returns Array of groups\n   * @see https://docs.xmtp.org/chat-apps/list-stream-sync/list#list-existing-conversations\n   */\n  listGroups(options?: Omit<ListConversationsOptions, \"conversationType\">) {\n    const groups = this.#conversations.list({\n      ...(options ?? {}),\n      conversationType: ConversationType.Group,\n    });\n    return groups.map((item) => {\n      const conversation = new Group(\n        this.#client,\n        item.conversation,\n        item.isCommitLogForked,\n      );\n      return conversation;\n    });\n  }\n\n  /**\n   * Lists all DMs with optional filtering\n   *\n   * @param options - Optional filtering and pagination options\n   * @returns Array of DMs\n   * @see https://docs.xmtp.org/chat-apps/list-stream-sync/list#list-existing-conversations\n   */\n  listDms(options?: Omit<ListConversationsOptions, \"conversationType\">) {\n    const groups = this.#conversations.list({\n      ...(options ?? {}),\n      conversationType: ConversationType.Dm,\n    });\n    return groups.map((item) => {\n      const conversation = new Dm(\n        this.#client,\n        item.conversation,\n        item.isCommitLogForked,\n      );\n      return conversation;\n    });\n  }\n\n  /**\n   * Synchronizes conversations for the current client from the network\n   *\n   * @returns Promise that resolves when sync is complete\n   * @see https://docs.xmtp.org/chat-apps/list-stream-sync/sync-and-syncall\n   */\n  async sync() {\n    return this.#conversations.sync();\n  }\n\n  /**\n   * Synchronizes all conversations and messages from the network with optional\n   * consent state filtering\n   *\n   * @param consentStates - Optional array of consent states to filter by\n   * @returns Promise that resolves when sync is complete\n   * @see https://docs.xmtp.org/chat-apps/list-stream-sync/sync-and-syncall#sync-all-new-welcomes-conversations-messages-and-preferences\n   */\n  async syncAll(consentStates?: ConsentState[]) {\n    return this.#conversations.syncAllConversations(consentStates);\n  }\n\n  /**\n   * Creates a stream for new conversations\n   *\n   * @param options - Optional stream options\n   * @param options.conversationType - Optional conversation type to filter by\n   * @returns Stream instance for new conversations\n   * @see https://docs.xmtp.org/chat-apps/list-stream-sync/stream#stream-new-group-chat-and-dm-conversations\n   */\n  async stream(\n    options?: StreamOptions<\n      Conversation,\n      Group<ContentTypes> | Dm<ContentTypes> | undefined\n    > & {\n      conversationType?: ConversationType;\n    },\n  ) {\n    const stream = async (\n      callback: StreamCallback<Conversation>,\n      onFail: () => void,\n    ) => {\n      await this.sync();\n      return this.#conversations.stream(\n        callback,\n        onFail,\n        options?.conversationType,\n      );\n    };\n    const convertConversation = async (value: Conversation) => {\n      const metadata = await value.groupMetadata();\n      const conversationType = metadata.conversationType();\n      let conversation: Group<ContentTypes> | Dm<ContentTypes> | undefined;\n      switch (conversationType) {\n        case \"dm\":\n          conversation = new Dm(this.#client, value);\n          break;\n        case \"group\":\n          conversation = new Group(this.#client, value);\n          break;\n      }\n      return conversation;\n    };\n\n    return createStream(stream, convertConversation, options);\n  }\n\n  /**\n   * Creates a stream for new group conversations\n   *\n   * @param options - Optional stream options\n   * @returns Stream instance for new group conversations\n   * @see https://docs.xmtp.org/chat-apps/list-stream-sync/stream#stream-new-group-chat-and-dm-conversations\n   */\n  async streamGroups(\n    options?: StreamOptions<Conversation, Group<ContentTypes>>,\n  ) {\n    const stream = async (\n      callback: StreamCallback<Conversation>,\n      onFail: () => void,\n    ) => {\n      await this.sync();\n      return this.#conversations.stream(\n        callback,\n        onFail,\n        ConversationType.Group,\n      );\n    };\n    const convertConversation = (value: Conversation) => {\n      return new Group(this.#client, value);\n    };\n\n    return createStream(stream, convertConversation, options);\n  }\n\n  /**\n   * Creates a stream for new DM conversations\n   *\n   * @param options - Optional stream options\n   * @returns Stream instance for new DM conversations\n   * @see https://docs.xmtp.org/chat-apps/list-stream-sync/stream#stream-new-group-chat-and-dm-conversations\n   */\n  async streamDms(options?: StreamOptions<Conversation, Dm<ContentTypes>>) {\n    const stream = async (\n      callback: StreamCallback<Conversation>,\n      onFail: () => void,\n    ) => {\n      await this.sync();\n      return this.#conversations.stream(callback, onFail, ConversationType.Dm);\n    };\n    const convertConversation = (value: Conversation) => {\n      return new Dm(this.#client, value);\n    };\n\n    return createStream(stream, convertConversation, options);\n  }\n\n  /**\n   * Creates a stream for all new messages\n   *\n   * @param options - Optional stream options\n   * @param options.conversationType - Optional conversation type to filter by\n   * @param options.consentStates - Optional array of consent states to filter by\n   * @returns Stream instance for new messages\n   * @see https://docs.xmtp.org/chat-apps/list-stream-sync/stream#stream-new-group-chat-and-dm-messages\n   */\n  async streamAllMessages(\n    options?: StreamOptions<Message, DecodedMessage<ContentTypes>> & {\n      conversationType?: ConversationType;\n      consentStates?: ConsentState[];\n    },\n  ) {\n    const streamAllMessages = async (\n      callback: StreamCallback<Message>,\n      onFail: () => void,\n    ) => {\n      await this.sync();\n      return this.#conversations.streamAllMessages(\n        callback,\n        onFail,\n        options?.conversationType,\n        options?.consentStates,\n      );\n    };\n    const convertMessage = (value: Message) => {\n      return new DecodedMessage(this.#client, value);\n    };\n\n    return createStream(streamAllMessages, convertMessage, options);\n  }\n\n  /**\n   * Creates a stream for all new group messages\n   *\n   * @param options - Optional stream options\n   * @param options.consentStates - Optional array of consent states to filter by\n   * @returns Stream instance for new group messages\n   * @see https://docs.xmtp.org/chat-apps/list-stream-sync/stream#stream-new-group-chat-and-dm-messages\n   */\n  async streamAllGroupMessages(\n    options?: StreamOptions<Message, DecodedMessage<ContentTypes>> & {\n      consentStates?: ConsentState[];\n    },\n  ) {\n    return this.streamAllMessages({\n      ...(options ?? {}),\n      conversationType: ConversationType.Group,\n      consentStates: options?.consentStates,\n    });\n  }\n\n  /**\n   * Creates a stream for all new DM messages\n   *\n   * @param options - Optional stream options\n   * @param options.consentStates - Optional array of consent states to filter by\n   * @returns Stream instance for new DM messages\n   * @see https://docs.xmtp.org/chat-apps/list-stream-sync/stream#stream-new-group-chat-and-dm-messages\n   */\n  async streamAllDmMessages(\n    options?: StreamOptions<Message, DecodedMessage<ContentTypes>> & {\n      consentStates?: ConsentState[];\n    },\n  ) {\n    return this.streamAllMessages({\n      ...(options ?? {}),\n      conversationType: ConversationType.Dm,\n      consentStates: options?.consentStates,\n    });\n  }\n\n  /**\n   * Retrieves HMAC keys for all conversations\n   *\n   * @returns The HMAC keys for all conversations\n   * @see https://docs.xmtp.org/chat-apps/push-notifs/push-notifs#get-hmac-keys-for-a-conversation\n   */\n  hmacKeys() {\n    return this.#conversations.getHmacKeys();\n  }\n}\n",
      "size_bytes": 14358
    },
    "apps/xmtp.chat/src/components/Messages/MessageProperties.tsx": {
      "content": "import { Stack, Text } from \"@mantine/core\";\nimport { type DecodedMessage } from \"@xmtp/browser-sdk\";\nimport { intlFormat } from \"date-fns\";\nimport { useMemo } from \"react\";\nimport { BadgeWithCopy } from \"@/components/BadgeWithCopy\";\nimport { nsToDate } from \"@/helpers/date\";\n\nexport type MessagePropertiesProps = {\n  message: DecodedMessage;\n};\n\nexport const MessageProperties: React.FC<MessagePropertiesProps> = ({\n  message,\n}) => {\n  const deliveryStatus = useMemo(() => {\n    switch (message.deliveryStatus) {\n      case \"published\":\n        return \"Published\";\n      case \"failed\":\n        return \"Failed\";\n      case \"unpublished\":\n        return \"Unpublished\";\n    }\n  }, [message]);\n\n  const messageKind = useMemo(() => {\n    switch (message.kind) {\n      case \"application\":\n        return \"Application\";\n      case \"membership_change\":\n        return \"Membership Change\";\n    }\n  }, [message]);\n\n  return (\n    <Stack gap=\"xs\" mih=\"30vh\">\n      <Stack gap=\"calc(var(--mantine-spacing-xs) / 2)\">\n        <Text size=\"sm\" ml=\"xs\">\n          Message ID\n        </Text>\n        <BadgeWithCopy value={message.id} />\n      </Stack>\n      <Stack gap=\"calc(var(--mantine-spacing-xs) / 2)\">\n        <Text size=\"sm\" ml=\"xs\">\n          Conversation ID\n        </Text>\n        <BadgeWithCopy value={message.conversationId} />\n      </Stack>\n      <Stack gap=\"calc(var(--mantine-spacing-xs) / 2)\">\n        <Text size=\"sm\" ml=\"xs\">\n          Message kind\n        </Text>\n        <BadgeWithCopy value={messageKind} />\n      </Stack>\n      <Stack gap=\"calc(var(--mantine-spacing-xs) / 2)\">\n        <Text size=\"sm\" ml=\"xs\">\n          Sender inbox ID\n        </Text>\n        <BadgeWithCopy value={message.senderInboxId} />\n      </Stack>\n      <Stack gap=\"calc(var(--mantine-spacing-xs) / 2)\">\n        <Text size=\"sm\" ml=\"xs\">\n          Delivery status\n        </Text>\n        <BadgeWithCopy value={deliveryStatus} />\n      </Stack>\n      <Stack gap=\"calc(var(--mantine-spacing-xs) / 2)\">\n        <Text size=\"sm\" ml=\"xs\">\n          Sent at\n        </Text>\n        <BadgeWithCopy\n          value={intlFormat(nsToDate(message.sentAtNs), {\n            year: \"numeric\",\n            month: \"2-digit\",\n            day: \"2-digit\",\n            hour: \"2-digit\",\n            minute: \"2-digit\",\n            second: \"2-digit\",\n          })}\n        />\n      </Stack>\n    </Stack>\n  );\n};\n",
      "size_bytes": 2369
    },
    "apps/xmtp.chat/src/components/Messages/MarkdownContent.module.css": {
      "content": ".root {\n  cursor: text;\n  max-width: clamp(240px, 68vw, 540px);\n  line-height: 1.55;\n  font-size: 0.96rem;\n  box-shadow: 0 12px 26px rgba(4, 10, 26, 0.28);\n}\n\n.inbound {\n  background: rgba(12, 17, 28, 0.92);\n  color: rgba(226, 232, 240, 0.92);\n  border: 1px solid rgba(148, 163, 184, 0.16);\n}\n\n.outbound {\n  background: linear-gradient(140deg, #0afff1, #9772fb);\n  color: #041019;\n  border: 1px solid rgba(255, 255, 255, 0.18);\n}\n\n@media (max-width: 520px) {\n  .root {\n    max-width: 82vw;\n    font-size: 0.94rem;\n  }\n}\n\n.root > *:first-child {\n  margin-block-start: 0 !important;\n}\n\n.root > *:last-child {\n  margin-block-end: 0 !important;\n}\n\n.root blockquote > p {\n  margin-block: 0 !important;\n}\n",
      "size_bytes": 699
    },
    "content-types/content-type-transaction-reference/vitest.setup.ts": {
      "content": "import { unlink } from \"node:fs/promises\";\nimport { dirname, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { glob } from \"fast-glob\";\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nexport const teardown = async () => {\n  const files = await glob(\"**/*.db3*\", { cwd: __dirname });\n  await Promise.all(files.map((file) => unlink(join(__dirname, file))));\n};\n",
      "size_bytes": 398
    },
    "apps/xmtp.chat/src/content-types/Actions.ts": {
      "content": "import {\n  ContentTypeId,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\nimport { z } from \"zod\";\n\n/**\n * Content Type ID for Actions messages\n * Following XIP-67 specification for inline actions\n */\nexport const ContentTypeActions = new ContentTypeId({\n  authorityId: \"coinbase.com\",\n  typeId: \"actions\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\n/**\n * Zod schema for individual actions\n */\nexport const actionSchema = z.object({\n  /** Unique identifier for this action */\n  id: z.string().min(1, \"Action id is required\"),\n  /** Display text for the button */\n  label: z.string().min(1, \"Action label is required\"),\n  /** Optional image URL */\n  imageUrl: z.url().optional(),\n  /** Optional visual style (primary|secondary|danger) */\n  style: z\n    .union([z.literal(\"primary\"), z.literal(\"secondary\"), z.literal(\"danger\")])\n    .optional(),\n  /** Optional ISO-8601 expiration timestamp */\n  expiresAt: z.iso.datetime({ precision: 3 }).optional(),\n});\n\n/**\n * Zod schema for actions content\n * Agents use this to present interactive button options to users\n */\nexport const actionsSchema = z.object({\n  /** Unique identifier for these actions */\n  id: z.string().min(1, \"Actions id is required\"),\n  /** Descriptive text explaining the actions */\n  description: z.string().min(1, \"Actions description is required\"),\n  /** Array of action definitions */\n  actions: z\n    .array(actionSchema)\n    .min(1, \"Actions must contain at least one action\")\n    .max(10, \"Actions cannot exceed 10 actions for UX reasons\")\n    .refine((actions) => {\n      const ids = actions.map((action) => action.id);\n      return ids.length === new Set(ids).size;\n    }, \"Action ids must be unique within actions array\"),\n  /** Optional ISO-8601 expiration timestamp */\n  expiresAt: z.iso.datetime({ precision: 3 }).optional(),\n});\n\nexport type Action = z.infer<typeof actionSchema>;\nexport type Actions = z.infer<typeof actionsSchema>;\n\n/**\n * Actions codec for encoding/decoding Actions messages\n * Implements XMTP ContentCodec interface for Actions content type\n */\nexport class ActionsCodec implements ContentCodec<Actions> {\n  get contentType(): ContentTypeId {\n    return ContentTypeActions;\n  }\n\n  encode(content: Actions): EncodedContent {\n    this.#validateContent(content);\n\n    return {\n      type: ContentTypeActions,\n      parameters: {},\n      content: new TextEncoder().encode(JSON.stringify(content)),\n    };\n  }\n\n  decode(content: EncodedContent): Actions {\n    const decodedContent = new TextDecoder().decode(content.content);\n    try {\n      const parsed = JSON.parse(decodedContent) as Actions;\n      this.#validateContent(parsed);\n\n      return parsed;\n    } catch (error: unknown) {\n      throw new Error(\n        `Failed to decode Actions content: ${(error as Error).message}`,\n      );\n    }\n  }\n\n  fallback(content: Actions): string {\n    const actionList = content.actions\n      .map((action, index) => `[${index + 1}] ${action.label}`)\n      .join(\"\\n\");\n    return `${content.description}\\n\\n${actionList}\\n\\nReply with the number to select`;\n  }\n\n  shouldPush(): boolean {\n    return true;\n  }\n\n  #validateContent(content: Actions): void {\n    const result = actionsSchema.safeParse(content);\n    if (!result.success) {\n      throw new Error(z.prettifyError(result.error));\n    }\n  }\n}\n",
      "size_bytes": 3329
    },
    "apps/xmtp.chat-api-service/src/middleware/noRoute.ts": {
      "content": "import type { Request, Response } from \"express\";\n\nexport const noRouteMiddleware = (_req: Request, res: Response): void => {\n  res.status(404).send();\n};\n",
      "size_bytes": 155
    },
    "apps/xmtp.chat/src/components/Conversation/ManageMetadataModal.tsx": {
      "content": "import { Button, Group } from \"@mantine/core\";\nimport { Group as XmtpGroup } from \"@xmtp/browser-sdk\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { useNavigate, useOutletContext } from \"react-router\";\nimport type { ConversationOutletContext } from \"@/components/Conversation/ConversationOutletContext\";\nimport { Metadata } from \"@/components/Conversation/Metadata\";\nimport { Modal } from \"@/components/Modal\";\nimport { useClientPermissions } from \"@/hooks/useClientPermissions\";\nimport { useCollapsedMediaQuery } from \"@/hooks/useCollapsedMediaQuery\";\nimport { useConversation } from \"@/hooks/useConversation\";\nimport { ContentLayout } from \"@/layouts/ContentLayout\";\nimport { useActions } from \"@/stores/inbox/hooks\";\n\nexport const ManageMetadataModal: React.FC = () => {\n  const { conversationId } = useOutletContext<ConversationOutletContext>();\n  const { conversation } = useConversation(conversationId);\n  const clientPermissions = useClientPermissions(conversationId);\n  const { addConversation } = useActions();\n  const navigate = useNavigate();\n  const fullScreen = useCollapsedMediaQuery();\n  const [name, setName] = useState(\"\");\n  const [description, setDescription] = useState(\"\");\n  const [imageUrl, setImageUrl] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const contentHeight = fullScreen ? \"auto\" : 500;\n  const initialName = useRef(\"\");\n  const initialDescription = useRef(\"\");\n  const initialImageUrl = useRef(\"\");\n\n  const handleClose = useCallback(() => {\n    void navigate(`/conversations/${conversation.id}`);\n  }, [navigate, conversation.id]);\n\n  const handleUpdate = useCallback(async () => {\n    if (conversation instanceof XmtpGroup) {\n      setIsLoading(true);\n      try {\n        let hasUpdated = false;\n        if (name !== initialName.current) {\n          await conversation.updateName(name);\n          hasUpdated = true;\n        }\n        if (description !== initialDescription.current) {\n          await conversation.updateDescription(description);\n          hasUpdated = true;\n        }\n        if (imageUrl !== initialImageUrl.current) {\n          await conversation.updateImageUrl(imageUrl);\n          hasUpdated = true;\n        }\n\n        if (hasUpdated) {\n          void addConversation(conversation);\n        }\n\n        void navigate(`/conversations/${conversation.id}`);\n      } finally {\n        setIsLoading(false);\n      }\n    }\n  }, [conversation, name, description, imageUrl, navigate]);\n\n  useEffect(() => {\n    if (conversation instanceof XmtpGroup) {\n      initialName.current = conversation.name ?? \"\";\n      initialDescription.current = conversation.description ?? \"\";\n      initialImageUrl.current = conversation.imageUrl ?? \"\";\n    }\n  }, [conversation]);\n\n  const footer = useMemo(() => {\n    return (\n      <Group justify=\"flex-end\" flex={1} p=\"md\">\n        <Button variant=\"default\" onClick={handleClose}>\n          Cancel\n        </Button>\n        <Button\n          variant=\"filled\"\n          disabled={\n            name === initialName.current &&\n            description === initialDescription.current &&\n            imageUrl === initialImageUrl.current\n          }\n          loading={isLoading}\n          onClick={() => void handleUpdate()}>\n          Save\n        </Button>\n      </Group>\n    );\n  }, [isLoading, handleUpdate, handleClose]);\n\n  return (\n    <Modal\n      closeOnClickOutside={false}\n      closeOnEscape={false}\n      withCloseButton={false}\n      opened\n      centered\n      fullScreen={fullScreen}\n      onClose={handleClose}\n      size=\"md\"\n      padding={0}>\n      <ContentLayout\n        title=\"Manage metadata\"\n        maxHeight={contentHeight}\n        footer={footer}\n        withScrollFade={false}\n        withScrollAreaPadding={false}>\n        <Metadata\n          conversation={conversation}\n          clientPermissions={clientPermissions}\n          onNameChange={setName}\n          onDescriptionChange={setDescription}\n          onImageUrlChange={setImageUrl}\n        />\n      </ContentLayout>\n    </Modal>\n  );\n};\n",
      "size_bytes": 4062
    },
    "sdks/browser-sdk/src/utils/streams.ts": {
      "content": "import { AsyncStream, createAsyncStreamProxy } from \"@/AsyncStream\";\nimport { StreamFailedError, StreamInvalidRetryAttemptsError } from \"./errors\";\n\nconst isPromise = <T = unknown>(value: unknown): value is Promise<T> => {\n  return (\n    !!value &&\n    (typeof value === \"object\" || typeof value === \"function\") &&\n    \"then\" in value &&\n    typeof value.then === \"function\"\n  );\n};\n\nconst wait = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\n\nexport const DEFAULT_RETRY_DELAY = 10000; // milliseconds\nexport const DEFAULT_RETRY_ATTEMPTS = 6;\n\nexport type StreamOptions<T = unknown, V = T> = {\n  /**\n   * Called when the stream ends\n   */\n  onEnd?: () => void;\n  /**\n   * Called when a stream error occurs\n   */\n  onError?: (error: Error) => void;\n  /**\n   * Called when the stream fails\n   */\n  onFail?: () => void;\n  /**\n   * Called when the stream is restarted\n   */\n  onRestart?: () => void;\n  /**\n   * Called when the stream is retried\n   */\n  onRetry?: (attempts: number, maxAttempts: number) => void;\n  /**\n   * Called when a value is emitted from the stream\n   */\n  onValue?: (value: V) => void;\n  /**\n   * The number of times to retry the stream\n   * (default: 6)\n   */\n  retryAttempts?: number;\n  /**\n   * The delay between retries (in milliseconds)\n   * (default: 10000)\n   */\n  retryDelay?: number;\n  /**\n   * Whether to retry the stream if it fails\n   * (default: true)\n   */\n  retryOnFail?: boolean;\n};\n\nexport type StreamCallback<T = unknown> = (\n  error: Error | null,\n  value: T | undefined,\n) => void;\n\nexport type StreamFunction<T = unknown> = (\n  callback: StreamCallback<T>,\n  onFail: () => void,\n) => Promise<() => void>;\n\nexport type StreamValueMutator<T = unknown, V = T> = (\n  value: T,\n) => V | Promise<V>;\n\n/**\n * Creates a stream from a stream function\n *\n * If the stream fails, an attempt will be made to restart it.\n *\n * This function is not intended to be used directly.\n *\n * @param streamFunction - The stream function to create a stream from\n * @param streamValueMutator - An optional function to mutate the value emitted from the stream\n * @param options - The options for the stream\n * @param args - Additional arguments to pass to the stream function\n * @returns An async iterable stream proxy\n * @throws {StreamInvalidRetryAttemptsError} if the retryAttempts option is less than 0 and retryOnFail is true\n * @throws {StreamFailedError} if the stream fails and can't be restarted\n */\nexport const createStream = async <T = unknown, V = T>(\n  streamFunction: StreamFunction<T>,\n  streamValueMutator?: StreamValueMutator<T, V>,\n  options?: StreamOptions<T, V>,\n) => {\n  const {\n    onEnd,\n    onError,\n    onFail,\n    onRestart,\n    onRetry,\n    onValue,\n    retryAttempts = DEFAULT_RETRY_ATTEMPTS,\n    retryDelay = DEFAULT_RETRY_DELAY,\n    retryOnFail = true,\n  } = options ?? {};\n  // retry attempts must be greater than 0\n  if (retryOnFail && retryAttempts < 0) {\n    throw new StreamInvalidRetryAttemptsError();\n  }\n\n  const asyncStream = new AsyncStream<V>();\n  const streamCallback: StreamCallback<T> = (error, value) => {\n    // if a stream error occurs, call the onError callback\n    if (error) {\n      onError?.(error);\n      return;\n    }\n    // ensure the value is not undefined\n    if (value !== undefined) {\n      try {\n        // if a streamValueMutator is provided, mutate the value\n        if (streamValueMutator) {\n          const mutatedValue = streamValueMutator(value);\n          if (isPromise(mutatedValue)) {\n            void mutatedValue\n              .then((mutatedValue) => {\n                asyncStream.push(mutatedValue);\n                onValue?.(mutatedValue);\n              })\n              .catch((error: unknown) => {\n                onError?.(error as Error);\n              });\n          } else {\n            asyncStream.push(mutatedValue);\n            onValue?.(mutatedValue);\n          }\n        } else {\n          asyncStream.push(value as unknown as V);\n          onValue?.(value as unknown as V);\n        }\n      } catch (error) {\n        onError?.(error as Error);\n      }\n    }\n  };\n  const retry = async (retries: number = retryAttempts) => {\n    try {\n      // if the stream has been retried the maximum number of times without\n      // success, throw an error\n      if (retries === 0) {\n        void asyncStream.end();\n        throw new StreamFailedError(retryAttempts);\n      }\n\n      // wait for the retry delay before attempting to restart the stream\n      await wait(retryDelay);\n      // call the onRetry callback\n      onRetry?.(retryAttempts - retries + 1, retryAttempts);\n\n      // attempt to restart the stream\n      const streamCloser = await streamFunction(streamCallback, () => {\n        // call the onFail callback\n        onFail?.();\n        void retry();\n      });\n\n      // when the async stream is done, end the stream\n      asyncStream.onDone = () => {\n        streamCloser();\n        onEnd?.();\n      };\n\n      // stream restarted, call the onRestart callback\n      onRestart?.();\n    } catch (error) {\n      onError?.(error as Error);\n      // retry\n      void retry(retries - 1);\n    }\n  };\n  const startRetry = () => {\n    // if the stream should be retried, start the process\n    if (retryOnFail) {\n      void retry();\n    } else {\n      void asyncStream.end();\n      // stream failed and should not be retried, throw an error\n      throw new StreamFailedError(0);\n    }\n  };\n\n  try {\n    // create the stream\n    const streamCloser = await streamFunction(streamCallback, () => {\n      // call the onFail callback\n      onFail?.();\n      startRetry();\n    });\n    // when the async stream is done, end the stream\n    asyncStream.onDone = () => {\n      streamCloser();\n      onEnd?.();\n    };\n  } catch (error) {\n    onError?.(error as Error);\n    startRetry();\n  }\n\n  // return a proxy for the async stream\n  return createAsyncStreamProxy(asyncStream);\n};\n",
      "size_bytes": 5880
    },
    "apps/xmtp.chat/src/stores/inbox/store.ts": {
      "content": "import {\n  Dm,\n  Group,\n  type Conversation,\n  type DecodedMessage,\n  type SafeConversation,\n  type SafeGroupMember,\n} from \"@xmtp/browser-sdk\";\nimport {\n  ContentTypeGroupUpdated,\n  type GroupUpdated,\n} from \"@xmtp/content-type-group-updated\";\nimport { createStore } from \"zustand\";\nimport type { ContentTypes } from \"@/contexts/XMTPContext\";\nimport { getMemberAddress } from \"@/helpers/xmtp\";\nimport {\n  getLastCreatedAt,\n  isLastSentAt,\n  sortConversations,\n  sortMessages,\n} from \"@/stores/inbox/utils\";\nimport { profilesStore } from \"@/stores/profiles\";\n\nexport type ConversationMetadata = {\n  name?: string;\n  description?: string;\n  imageUrl?: string;\n};\n\n// alias types for clarity\ntype InboxId = string;\ntype ConversationId = string;\ntype MessageId = string;\n\nexport type InboxState = {\n  // all conversations\n  conversations: Map<ConversationId, Conversation<ContentTypes>>;\n  // the most recent conversation creation timestamp\n  lastCreatedAt?: bigint;\n  // the last message for each conversation\n  lastMessages: Map<ConversationId, DecodedMessage<ContentTypes> | undefined>;\n  // the last message sent timestamp for each conversation\n  lastSentAt: Map<ConversationId, bigint | undefined>;\n  // the members of each conversation\n  members: Map<ConversationId, Map<InboxId, SafeGroupMember>>;\n  // all conversation messages\n  messages: Map<ConversationId, Map<MessageId, DecodedMessage<ContentTypes>>>;\n  // the metadata for each conversation\n  metadata: Map<ConversationId, ConversationMetadata>;\n  // the permissions for each conversation\n  permissions: Map<ConversationId, SafeConversation[\"permissions\"]>;\n  // sorted conversations by most recent activity\n  sortedConversations: Conversation<ContentTypes>[];\n  // sorted messages by last sent timestamp\n  sortedMessages: Map<ConversationId, DecodedMessage<ContentTypes>[]>;\n  // the last attempted sync timestamp\n  lastSyncedAt?: bigint;\n};\n\nexport type InboxActions = {\n  addConversation: (conversation: Conversation<ContentTypes>) => Promise<void>;\n  addConversations: (\n    conversations: Conversation<ContentTypes>[],\n  ) => Promise<void>;\n  getConversation: (id: string) => Conversation<ContentTypes> | undefined;\n  hasConversation: (id: string) => boolean;\n  addMessage: (\n    conversationId: string,\n    message: DecodedMessage<ContentTypes>,\n  ) => Promise<void>;\n  addMessages: (\n    conversationId: string,\n    messages: DecodedMessage<ContentTypes>[],\n  ) => Promise<void>;\n  getMessage: (\n    conversationId: string,\n    messageId: string,\n  ) => DecodedMessage<ContentTypes> | undefined;\n  getMessages: (conversationId: string) => DecodedMessage<ContentTypes>[];\n  hasMessage: (conversationId: string, messageId: string) => boolean;\n  setLastSyncedAt: (timestamp: bigint) => void;\n  syncPermissions: (conversationId: string) => Promise<void>;\n  syncMembers: (conversationId: string) => Promise<void>;\n  reset: () => void;\n};\n\nexport const inboxStore = createStore<InboxState & InboxActions>()(\n  (set, get, store) => ({\n    conversations: new Map(),\n    lastMessages: new Map(),\n    lastSentAt: new Map(),\n    members: new Map(),\n    messages: new Map(),\n    metadata: new Map(),\n    permissions: new Map(),\n    sortedConversations: [],\n    sortedMessages: new Map(),\n    addConversation: async (conversation: Conversation<ContentTypes>) => {\n      const state = get();\n      // update conversations state\n      const newConversations = new Map(state.conversations);\n      newConversations.set(conversation.id, conversation);\n      // update members state\n      const members = await conversation.members();\n      const newMembers = new Map(state.members);\n      newMembers.set(\n        conversation.id,\n        new Map(members.map((m) => [m.inboxId, m])),\n      );\n      const newPermissions = new Map(state.permissions);\n      const newMetadata = new Map(state.metadata);\n      if (conversation instanceof Group) {\n        // update permissions state\n        newPermissions.set(conversation.id, await conversation.permissions());\n        // update metadata state\n        newMetadata.set(conversation.id, {\n          name: conversation.name,\n          description: conversation.description,\n          imageUrl: conversation.imageUrl,\n        });\n      } else if (conversation instanceof Dm) {\n        const member = members.find(\n          (m) => m.inboxId !== conversation.addedByInboxId,\n        );\n        if (member) {\n          const profiles = profilesStore\n            .getState()\n            .getProfiles(getMemberAddress(member));\n          let displayName = member.inboxId;\n          if (profiles.length > 0) {\n            displayName = profiles[0].displayName ?? displayName;\n          }\n          // update metadata state\n          newMetadata.set(conversation.id, {\n            name: displayName,\n          });\n        }\n      }\n      // update last message state\n      const lastMessage = await conversation.lastMessage();\n      const newLastMessages = new Map(state.lastMessages);\n      newLastMessages.set(conversation.id, lastMessage);\n      set({\n        conversations: newConversations,\n        lastCreatedAt: getLastCreatedAt(conversation, state.lastCreatedAt),\n        lastMessages: newLastMessages,\n        members: newMembers,\n        metadata: newMetadata,\n        permissions: newPermissions,\n        sortedConversations: sortConversations(\n          newConversations,\n          newLastMessages,\n        ),\n      });\n    },\n    addConversations: async (conversations: Conversation<ContentTypes>[]) => {\n      if (conversations.length === 0) {\n        return;\n      }\n      const state = get();\n      // get conversation members in parallel\n      const allMembers = new Map<string, SafeGroupMember[]>(\n        await Promise.all(\n          conversations.map(\n            async (conversation): Promise<[string, SafeGroupMember[]]> => [\n              conversation.id,\n              await conversation.members(),\n            ],\n          ),\n        ),\n      );\n      // get conversation last messages in parallel\n      const allLastMessages = new Map<\n        string,\n        DecodedMessage<ContentTypes> | undefined\n      >(\n        await Promise.all(\n          conversations.map(\n            async (\n              conversation,\n            ): Promise<[string, DecodedMessage<ContentTypes> | undefined]> => [\n              conversation.id,\n              await conversation.lastMessage(),\n            ],\n          ),\n        ),\n      );\n\n      // update conversations, members, and last message states\n      const newConversations = new Map(state.conversations);\n      const newMembers = new Map(state.members);\n      const newPermissions = new Map(state.permissions);\n      const newMetadata = new Map(state.metadata);\n      const newLastMessages = new Map(state.lastMessages);\n      let lastCreatedAt = state.lastCreatedAt;\n      for (const conversation of conversations) {\n        newConversations.set(conversation.id, conversation);\n        lastCreatedAt = getLastCreatedAt(conversation, lastCreatedAt);\n        const members = allMembers.get(conversation.id) ?? [];\n        newMembers.set(\n          conversation.id,\n          new Map(members.map((m) => [m.inboxId, m])),\n        );\n        if (conversation instanceof Group) {\n          // update permissions state\n          newPermissions.set(conversation.id, await conversation.permissions());\n          // update metadata state\n          newMetadata.set(conversation.id, {\n            name: conversation.name,\n            description: conversation.description,\n            imageUrl: conversation.imageUrl,\n          });\n        } else if (conversation instanceof Dm) {\n          const member = members.find(\n            (m) => m.inboxId !== conversation.addedByInboxId,\n          );\n          if (member) {\n            const profiles = profilesStore\n              .getState()\n              .getProfiles(getMemberAddress(member));\n            let displayName = member.inboxId;\n            if (profiles.length > 0) {\n              displayName = profiles[0].displayName ?? displayName;\n            }\n            // update metadata state\n            newMetadata.set(conversation.id, {\n              name: displayName,\n            });\n          }\n        }\n        const lastMessage = allLastMessages.get(conversation.id);\n        newLastMessages.set(conversation.id, lastMessage);\n      }\n\n      set({\n        conversations: newConversations,\n        lastCreatedAt,\n        lastMessages: newLastMessages,\n        members: newMembers,\n        metadata: newMetadata,\n        permissions: newPermissions,\n        sortedConversations: sortConversations(\n          newConversations,\n          newLastMessages,\n        ),\n      });\n    },\n    getConversation: (id: string) => {\n      return get().conversations.get(id);\n    },\n    hasConversation: (id: string) => {\n      return get().conversations.has(id);\n    },\n    addMessage: async (\n      conversationId: string,\n      message: DecodedMessage<ContentTypes>,\n    ) => {\n      const state = get();\n      const conversation = state.conversations.get(conversationId);\n      // update messages state\n      const newMessagesState = new Map(state.messages);\n      const conversationMessages =\n        newMessagesState.get(conversationId) ||\n        new Map<string, DecodedMessage<ContentTypes>>();\n      const newMessages = new Map(conversationMessages);\n      newMessages.set(message.id, message);\n      newMessagesState.set(conversationId, newMessages);\n\n      // update last sent at and last message states\n      const newLastSentAt = new Map(state.lastSentAt);\n      const newLastMessages = new Map(state.lastMessages);\n      if (isLastSentAt(message, state.lastSentAt.get(conversationId))) {\n        newLastSentAt.set(conversationId, message.sentAtNs);\n        newLastMessages.set(conversationId, message);\n      }\n\n      // update sorted messages state\n      const newSortedMessages = new Map(state.sortedMessages);\n      newSortedMessages.set(conversationId, sortMessages(newMessages));\n\n      const newMembers = new Map(state.members);\n      const newMetadata = new Map(state.metadata);\n\n      // check for updated members and metadata\n      if (message.contentType.sameAs(ContentTypeGroupUpdated)) {\n        const groupUpdated = message.content as GroupUpdated;\n\n        // member updates\n        if (conversation) {\n          const isActive = await conversation.isActive();\n          // ensure group is active before syncing\n          if (isActive) {\n            await conversation.sync();\n          }\n          const members = await conversation.members();\n          const updatedMembers = new Map(members.map((m) => [m.inboxId, m]));\n          newMembers.set(message.conversationId, updatedMembers);\n        }\n\n        // update metadata state\n        const metadataUpdates: ConversationMetadata = {};\n        groupUpdated.metadataFieldChanges.forEach((change) => {\n          switch (change.fieldName) {\n            case \"group_name\":\n              metadataUpdates.name = change.newValue;\n              break;\n            case \"description\":\n              metadataUpdates.description = change.newValue;\n              break;\n            case \"group_image_url_square\":\n              metadataUpdates.imageUrl = change.newValue;\n              break;\n          }\n        });\n        if (Object.keys(metadataUpdates).length > 0) {\n          const existingMetadata = newMetadata.get(message.conversationId);\n          newMetadata.set(message.conversationId, {\n            ...existingMetadata,\n            ...metadataUpdates,\n          });\n        }\n      }\n\n      set({\n        lastMessages: newLastMessages,\n        lastSentAt: newLastSentAt,\n        members: newMembers,\n        messages: newMessagesState,\n        metadata: newMetadata,\n        sortedConversations: sortConversations(\n          state.conversations,\n          newLastMessages,\n        ),\n        sortedMessages: newSortedMessages,\n      });\n    },\n    addMessages: async (\n      conversationId: string,\n      messages: DecodedMessage<ContentTypes>[],\n    ) => {\n      const state = get();\n      const newMessagesByConversation = new Map(state.messages);\n      const conversationMessages =\n        newMessagesByConversation.get(conversationId) ||\n        new Map<string, DecodedMessage<ContentTypes>>();\n      const newMessages = new Map(conversationMessages);\n      let lastSentAt = state.lastSentAt.get(conversationId);\n      let lastMessage = state.lastMessages.get(conversationId);\n\n      const newMetadata = new Map(state.metadata);\n      const newMembers = new Map(state.members);\n\n      for (const message of messages) {\n        newMessages.set(message.id, message);\n        if (isLastSentAt(message, lastSentAt)) {\n          lastSentAt = message.sentAtNs;\n          lastMessage = message;\n        }\n\n        // check for updated members and metadata\n        if (message.contentType.sameAs(ContentTypeGroupUpdated)) {\n          const groupUpdated = message.content as GroupUpdated;\n\n          // member updates\n          const conversation = state.conversations.get(message.conversationId);\n          if (conversation) {\n            const isActive = await conversation.isActive();\n            // ensure group is active before syncing\n            if (isActive) {\n              await conversation.sync();\n            }\n            const members = await conversation.members();\n            const updatedMembers = new Map(members.map((m) => [m.inboxId, m]));\n            newMembers.set(message.conversationId, updatedMembers);\n          }\n\n          // metadata updates\n          const metadataUpdates: ConversationMetadata = {};\n          groupUpdated.metadataFieldChanges.forEach((change) => {\n            switch (change.fieldName) {\n              case \"group_name\":\n                metadataUpdates.name = change.newValue;\n                break;\n              case \"description\":\n                metadataUpdates.description = change.newValue;\n                break;\n              case \"group_image_url_square\":\n                metadataUpdates.imageUrl = change.newValue;\n                break;\n            }\n          });\n          if (Object.keys(metadataUpdates).length > 0) {\n            const existingMetadata = newMetadata.get(message.conversationId);\n            newMetadata.set(message.conversationId, {\n              ...existingMetadata,\n              ...metadataUpdates,\n            });\n          }\n        }\n      }\n\n      // update messages state\n      newMessagesByConversation.set(conversationId, newMessages);\n\n      // update last sent at state\n      const newLastSentAt = new Map(state.lastSentAt);\n      newLastSentAt.set(conversationId, lastSentAt);\n\n      // update last message state\n      const newLastMessages = new Map(state.lastMessages);\n      newLastMessages.set(conversationId, lastMessage);\n\n      // update sorted messages state\n      const newSortedMessages = new Map(state.sortedMessages);\n      newSortedMessages.set(conversationId, sortMessages(newMessages));\n\n      set({\n        lastMessages: newLastMessages,\n        lastSentAt: newLastSentAt,\n        members: newMembers,\n        messages: newMessagesByConversation,\n        metadata: newMetadata,\n        sortedConversations: sortConversations(\n          state.conversations,\n          newLastMessages,\n        ),\n        sortedMessages: newSortedMessages,\n      });\n    },\n    getMessage: (conversationId: string, messageId: string) => {\n      const messages = get().messages.get(conversationId);\n      return messages?.get(messageId);\n    },\n    getMessages: (conversationId: string) => {\n      const messages = get().messages.get(conversationId);\n      return messages ? Array.from(messages.values()) : [];\n    },\n    hasMessage: (conversationId: string, messageId: string) => {\n      const conversationMessages = get().messages.get(conversationId);\n      return conversationMessages?.has(messageId) ?? false;\n    },\n    setLastSyncedAt: (timestamp: bigint) => {\n      set({ lastSyncedAt: timestamp });\n    },\n    syncPermissions: async (conversationId: string) => {\n      const state = get();\n      const conversation = state.conversations.get(conversationId);\n      if (conversation instanceof Group) {\n        const newPermissions = new Map(state.permissions);\n        newPermissions.set(conversationId, await conversation.permissions());\n        set({\n          permissions: newPermissions,\n        });\n      }\n    },\n    syncMembers: async (conversationId: string) => {\n      const state = get();\n      const conversation = state.conversations.get(conversationId);\n      if (conversation instanceof Group) {\n        const newMembers = new Map(state.members);\n        const members = await conversation.members();\n        newMembers.set(\n          conversationId,\n          new Map(members.map((m) => [m.inboxId, m])),\n        );\n        set({ members: newMembers });\n      }\n    },\n    reset: () => {\n      set(store.getInitialState());\n    },\n  }),\n);\n",
      "size_bytes": 16922
    },
    "content-types/content-type-primitives/src/index.ts": {
      "content": "import type { content } from \"@xmtp/proto\";\n\nexport class ContentTypeId {\n  authorityId: string;\n\n  typeId: string;\n\n  versionMajor: number;\n\n  versionMinor: number;\n\n  constructor(obj: content.ContentTypeId) {\n    this.authorityId = obj.authorityId;\n    this.typeId = obj.typeId;\n    this.versionMajor = obj.versionMajor;\n    this.versionMinor = obj.versionMinor;\n  }\n\n  toString(): string {\n    return `${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`;\n  }\n\n  static fromString(contentTypeString: string): ContentTypeId {\n    const [idString, versionString] = contentTypeString.split(\":\");\n    const [authorityId, typeId] = idString.split(\"/\");\n    const [major, minor] = versionString.split(\".\");\n    return new ContentTypeId({\n      authorityId,\n      typeId,\n      versionMajor: Number(major),\n      versionMinor: Number(minor),\n    });\n  }\n\n  sameAs(id: ContentTypeId): boolean {\n    return this.authorityId === id.authorityId && this.typeId === id.typeId;\n  }\n}\n\nexport type EncodedContent<Parameters = Record<string, string>> = {\n  type: ContentTypeId;\n  parameters: Parameters;\n  fallback?: string;\n  compression?: number;\n  content: Uint8Array;\n};\n\nexport type ContentCodec<\n  ContentType = unknown,\n  Parameters = Record<string, string>,\n> = {\n  contentType: ContentTypeId;\n  encode(\n    content: ContentType,\n    registry: CodecRegistry,\n  ): EncodedContent<Parameters>;\n  decode(\n    content: EncodedContent<Parameters>,\n    registry: CodecRegistry,\n  ): ContentType;\n  fallback(content: ContentType): string | undefined;\n  shouldPush: (content: ContentType) => boolean;\n};\n\n/**\n * An interface implemented for accessing codecs by content type.\n */\nexport interface CodecRegistry<T = unknown> {\n  codecFor(contentType: ContentTypeId): ContentCodec<T> | undefined;\n}\n\nexport type CodecMap<T = unknown> = Map<string, ContentCodec<T>>;\n",
      "size_bytes": 1875
    },
    "apps/xmtp.chat/src/components/Conversation/AddMembers.tsx": {
      "content": "import { Badge, Button, Group, Stack, Text, TextInput } from \"@mantine/core\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport { Member } from \"@/components/Conversation/Member\";\nimport type { Member as MemberCardMember } from \"@/components/Conversation/MemberCard\";\nimport { useMemberId } from \"@/hooks/useMemberId\";\nimport type { MemberProfile } from \"@/hooks/useMemberProfiles\";\n\nconst hasInboxId = (\n  members: MemberProfile[] | PendingMember[],\n  inboxId: string,\n) => {\n  return members.some((member) => member.inboxId === inboxId);\n};\n\nexport type PendingMember = MemberCardMember & {\n  inboxId: string;\n};\n\nexport type AddMembersProps = {\n  existingMembers: MemberProfile[];\n  addedMembers: PendingMember[];\n  onMembersAdded?: (members: PendingMember[]) => void;\n};\n\nexport const AddMembers: React.FC<AddMembersProps> = ({\n  existingMembers,\n  addedMembers,\n  onMembersAdded,\n}) => {\n  const {\n    loading,\n    memberId,\n    setMemberId,\n    displayName: memberIdDisplayName,\n    error: memberIdError,\n    inboxId: memberIdInboxId,\n    address: memberIdAddress,\n    description: memberIdDescription,\n    avatar: memberIdAvatar,\n  } = useMemberId();\n  const [error, setError] = useState<string | null>(null);\n\n  const handleAddMember = useCallback(() => {\n    if (hasInboxId(addedMembers, memberIdInboxId)) return;\n    const member = {\n      inboxId: memberIdInboxId,\n      address: memberIdAddress,\n      displayName: memberIdDisplayName,\n      avatar: memberIdAvatar,\n      description: memberIdDescription,\n    };\n    setMemberId(\"\");\n    onMembersAdded?.([...addedMembers, member]);\n  }, [\n    addedMembers,\n    memberIdInboxId,\n    memberIdAddress,\n    memberIdDisplayName,\n    memberIdDescription,\n    memberIdAvatar,\n    onMembersAdded,\n  ]);\n\n  const handleRemoveAddedMember = useCallback(\n    (inboxId: string) => {\n      const newAddedMembers = addedMembers.filter((m) => m.inboxId !== inboxId);\n      onMembersAdded?.(newAddedMembers);\n    },\n    [addedMembers, onMembersAdded],\n  );\n\n  useEffect(() => {\n    if (\n      memberIdInboxId &&\n      (hasInboxId(existingMembers, memberIdInboxId) ||\n        hasInboxId(addedMembers, memberIdInboxId))\n    ) {\n      setError(\"Duplicate address or inbox ID\");\n    } else {\n      setError(null);\n    }\n  }, [existingMembers, memberIdInboxId, addedMembers]);\n\n  return (\n    <>\n      <Group gap=\"xs\" align=\"flex-start\">\n        <TextInput\n          flex={1}\n          size=\"sm\"\n          label=\"Address, inbox ID, ENS name, or Base name\"\n          styles={{\n            label: {\n              marginBottom: \"var(--mantine-spacing-xxs)\",\n            },\n          }}\n          error={memberIdError || error}\n          value={memberId}\n          onChange={(event) => {\n            setMemberId(event.target.value);\n          }}\n          onKeyDown={(event) => {\n            if (\n              event.key === \"Enter\" &&\n              memberIdError === null &&\n              error === null &&\n              !loading &&\n              memberIdInboxId\n            ) {\n              handleAddMember();\n            }\n          }}\n        />\n        <Button\n          size=\"sm\"\n          mt=\"32px\"\n          disabled={\n            memberIdError !== null ||\n            loading ||\n            !memberIdInboxId ||\n            error !== null\n          }\n          loading={loading}\n          onClick={handleAddMember}>\n          Add\n        </Button>\n      </Group>\n      <Stack gap=\"xs\">\n        <Group gap=\"xs\" justify=\"space-between\" align=\"center\">\n          <Text fw={700}>Added members</Text>\n          <Badge color=\"gray\" size=\"lg\">\n            {addedMembers.length}\n          </Badge>\n        </Group>\n        {addedMembers.length > 0 && (\n          <Stack gap=\"4px\">\n            {addedMembers.map((member) => (\n              <Member\n                key={member.inboxId}\n                displayName={member.displayName}\n                address={member.address}\n                avatar={member.avatar}\n                description={member.description}\n                onClick={() => {\n                  handleRemoveAddedMember(member.inboxId);\n                }}\n              />\n            ))}\n          </Stack>\n        )}\n      </Stack>\n    </>\n  );\n};\n",
      "size_bytes": 4220
    },
    "apps/xmtp.chat/src/components/Messages/MessageList.module.css": {
      "content": ".root {\n  display: flex;\n  flex-direction: column;\n  gap: var(--mantine-spacing-sm);\n  padding: 0 var(--mantine-spacing-sm) var(--mantine-spacing-lg);\n}\n\n.root > * {\n  padding-top: var(--mantine-spacing-sm);\n}\n\n.root > *:last-child {\n  padding-bottom: var(--mantine-spacing-sm);\n}\n\n@media (max-width: 520px) {\n  .root {\n    gap: var(--mantine-spacing-xs);\n    padding: 0 var(--mantine-spacing-xs) var(--mantine-spacing-lg);\n  }\n}\n",
      "size_bytes": 430
    },
    "sdks/agent-sdk/src/debug/index.ts": {
      "content": "export * from \"./log.js\";\n",
      "size_bytes": 26
    },
    "sdks/browser-sdk/test/Conversation.test.ts": {
      "content": "import {\n  ConsentState,\n  ContentType,\n  GroupPermissionsOptions,\n  MetadataField,\n  PermissionPolicy,\n  PermissionUpdateType,\n} from \"@xmtp/wasm-bindings\";\nimport { describe, expect, it } from \"vitest\";\nimport type { SafeMessageDisappearingSettings } from \"@/utils/conversions\";\nimport {\n  ContentTypeTest,\n  createRegisteredClient,\n  createSigner,\n  createUser,\n  sleep,\n  TestCodec,\n} from \"@test/helpers\";\n\ndescribe(\"Conversation\", () => {\n  it(\"should update conversation name\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n    const newName = \"foo\";\n    await conversation.updateName(newName);\n    expect(conversation.name).toBe(newName);\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(2);\n\n    await client2.conversations.sync();\n    const conversations = await client2.conversations.listGroups();\n    expect(conversations.length).toBe(1);\n\n    const conversation2 = conversations[0];\n    expect(conversation2).toBeDefined();\n    await conversation2.sync();\n    expect(conversation2.id).toBe(conversation.id);\n    expect(conversation2.name).toBe(newName);\n  });\n\n  it(\"should update conversation image URL\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n    const imageUrl = \"https://foo/bar.jpg\";\n    await conversation.updateImageUrl(imageUrl);\n    expect(conversation.imageUrl).toBe(imageUrl);\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(2);\n\n    await client2.conversations.sync();\n    const conversations = await client2.conversations.listGroups();\n    expect(conversations.length).toBe(1);\n\n    const conversation2 = conversations[0];\n    expect(conversation2).toBeDefined();\n    await conversation2.sync();\n    expect(conversation2.id).toBe(conversation.id);\n    expect(conversation2.imageUrl).toBe(imageUrl);\n  });\n\n  it(\"should update conversation description\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n    const newDescription = \"foo\";\n    await conversation.updateDescription(newDescription);\n    expect(conversation.description).toBe(newDescription);\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(2);\n\n    await client2.conversations.sync();\n    const conversations = await client2.conversations.listGroups();\n    expect(conversations.length).toBe(1);\n\n    const conversation2 = conversations[0];\n    expect(conversation2).toBeDefined();\n    await conversation2.sync();\n    expect(conversation2.id).toBe(conversation.id);\n    expect(conversation2.description).toBe(newDescription);\n  });\n\n  it(\"should add and remove members\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    const members = await conversation.members();\n\n    const memberInboxIds = members.map((member) => member.inboxId);\n    expect(memberInboxIds).toContain(client1.inboxId);\n    expect(memberInboxIds).toContain(client2.inboxId);\n    expect(memberInboxIds).not.toContain(client3.inboxId);\n\n    await conversation.addMembers([client3.inboxId!]);\n\n    const members2 = await conversation.members();\n    expect(members2.length).toBe(3);\n\n    const memberInboxIds2 = members2.map((member) => member.inboxId);\n    expect(memberInboxIds2).toContain(client1.inboxId);\n    expect(memberInboxIds2).toContain(client2.inboxId);\n    expect(memberInboxIds2).toContain(client3.inboxId);\n\n    await conversation.removeMembers([client2.inboxId!]);\n\n    const members3 = await conversation.members();\n    expect(members3.length).toBe(2);\n\n    const memberInboxIds3 = members3.map((member) => member.inboxId);\n    expect(memberInboxIds3).toContain(client1.inboxId);\n    expect(memberInboxIds3).not.toContain(client2.inboxId);\n    expect(memberInboxIds3).toContain(client3.inboxId);\n  });\n\n  it(\"should add and remove members by inbox id\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    const members = await conversation.members();\n    const memberInboxIds = members.map((member) => member.inboxId);\n    expect(memberInboxIds).toContain(client1.inboxId);\n    expect(memberInboxIds).toContain(client2.inboxId);\n    expect(memberInboxIds).not.toContain(client3.inboxId);\n\n    await conversation.addMembers([client3.inboxId!]);\n\n    await client2.conversations.sync();\n    const conversation2 = await client2.conversations.getConversationById(\n      conversation.id,\n    );\n\n    await client3.conversations.sync();\n    const conversation3 = await client3.conversations.getConversationById(\n      conversation.id,\n    );\n\n    const members2 = await conversation.members();\n    expect(members2.length).toBe(3);\n\n    const memberInboxIds2 = members2.map((member) => member.inboxId);\n    expect(memberInboxIds2).toContain(client1.inboxId);\n    expect(memberInboxIds2).toContain(client2.inboxId);\n    expect(memberInboxIds2).toContain(client3.inboxId);\n\n    await conversation.removeMembers([client2.inboxId!]);\n\n    await conversation2!.sync();\n    await conversation3!.sync();\n\n    expect(await conversation.isActive()).toBe(true);\n    expect(await conversation2!.isActive()).toBe(false);\n    expect(await conversation3!.isActive()).toBe(true);\n\n    const members3 = await conversation.members();\n    expect(members3.length).toBe(2);\n\n    const memberInboxIds3 = members3.map((member) => member.inboxId);\n    expect(memberInboxIds3).toContain(client1.inboxId);\n    expect(memberInboxIds3).not.toContain(client2.inboxId);\n    expect(memberInboxIds3).toContain(client3.inboxId);\n  });\n\n  it(\"should send and list messages\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    expect(await conversation.lastMessage()).toBeDefined();\n\n    const text = \"gm\";\n    await conversation.send(text);\n\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(2);\n    expect(messages[1].content).toBe(text);\n\n    const lastMessage = await conversation.lastMessage();\n    expect(lastMessage).toBeDefined();\n    expect(lastMessage?.id).toBe(messages[1].id);\n    expect(lastMessage?.content).toBe(text);\n\n    await client2.conversations.sync();\n    const conversations = await client2.conversations.list();\n    expect(conversations.length).toBe(1);\n\n    const conversation2 = conversations[0];\n    expect(conversation2).toBeDefined();\n    await conversation2.sync();\n    expect(conversation2.id).toBe(conversation.id);\n\n    const messages2 = await conversation2.messages();\n    expect(messages2.length).toBe(2);\n    expect(messages2[1].content).toBe(text);\n\n    const lastMessage2 = await conversation2.lastMessage();\n    expect(lastMessage2).toBeDefined();\n    expect(lastMessage2?.id).toBe(messages2[1].id);\n    expect(lastMessage2?.content).toBe(text);\n  });\n\n  it(\"should require content type when sending non-string content\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1, {\n      codecs: [new TestCodec()],\n    });\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    // @ts-expect-error - testing invalid content type\n    await expect(() => conversation.send(1)).rejects.toThrow();\n    await expect(() => conversation.send({ foo: \"bar\" })).rejects.toThrow();\n    await expect(\n      conversation.send({ foo: \"bar\" }, ContentTypeTest),\n    ).resolves.not.toThrow();\n  });\n\n  it(\"should optimistically send and list messages\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    const text = \"gm\";\n    await conversation.sendOptimistic(text);\n\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(2);\n    expect(messages[1].content).toBe(text);\n\n    await client2.conversations.sync();\n    const conversations = await client2.conversations.list();\n    expect(conversations.length).toBe(1);\n\n    const conversation2 = conversations[0];\n    expect(conversation2).toBeDefined();\n\n    await conversation2.sync();\n    expect(conversation2.id).toBe(conversation.id);\n\n    const messages2 = await conversation2.messages();\n    expect(messages2.length).toBe(1);\n\n    await conversation.publishMessages();\n    await conversation2.sync();\n\n    const messages4 = await conversation2.messages();\n    expect(messages4.length).toBe(2);\n    expect(messages4[1].content).toBe(text);\n  });\n\n  it(\"should require content type when optimistically sending non-string content\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1, {\n      codecs: [new TestCodec()],\n    });\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    // @ts-expect-error - testing invalid content type\n    await expect(() => conversation.sendOptimistic(1)).rejects.toThrow();\n    await expect(() =>\n      conversation.sendOptimistic({ foo: \"bar\" }),\n    ).rejects.toThrow();\n    await expect(\n      conversation.sendOptimistic({ foo: \"bar\" }, ContentTypeTest),\n    ).resolves.not.toThrow();\n  });\n\n  it(\"should optimistically create a group\", async () => {\n    const user1 = createUser();\n    const signer1 = createSigner(user1);\n    const client1 = await createRegisteredClient(signer1);\n    const conversation = await client1.conversations.newGroupOptimistic({\n      name: \"foo\",\n      description: \"bar\",\n    });\n\n    expect(conversation.id).toBeDefined();\n    expect(conversation.name).toBe(\"foo\");\n    expect(conversation.description).toBe(\"bar\");\n    expect(conversation.imageUrl).toBe(\"\");\n    expect(conversation.addedByInboxId).toBe(client1.inboxId);\n\n    const text = \"gm\";\n    await conversation.sendOptimistic(text);\n\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(1);\n    expect(messages[0].content).toBe(text);\n    expect(messages[0].deliveryStatus).toBe(\"unpublished\");\n\n    await conversation.publishMessages();\n\n    const messages2 = await conversation.messages();\n    expect(messages2.length).toBe(1);\n    expect(messages2[0].content).toBe(text);\n    expect(messages2[0].deliveryStatus).toBe(\"published\");\n  });\n\n  it(\"should optimistically create a group with members\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroupOptimistic({\n      name: \"foo\",\n      description: \"bar\",\n    });\n\n    expect(conversation.id).toBeDefined();\n    expect(conversation.name).toBe(\"foo\");\n    expect(conversation.description).toBe(\"bar\");\n    expect(conversation.imageUrl).toBe(\"\");\n    expect(conversation.addedByInboxId).toBe(client1.inboxId);\n\n    const text = \"gm\";\n    await conversation.sendOptimistic(text);\n\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(1);\n    expect(messages[0].content).toBe(text);\n    expect(messages[0].deliveryStatus).toBe(\"unpublished\");\n\n    await conversation.addMembers([client2.inboxId!]);\n\n    const members = await conversation.members();\n    const memberInboxIds = members.map((member) => member.inboxId);\n    expect(memberInboxIds.length).toBe(2);\n    expect(memberInboxIds).toContain(client1.inboxId);\n    expect(memberInboxIds).toContain(client2.inboxId);\n\n    const messages3 = await conversation.messages();\n    expect(messages3.length).toBe(2);\n    expect(messages3[0].content).toBe(text);\n    expect(messages3[0].deliveryStatus).toBe(\"published\");\n    expect(messages3[1].deliveryStatus).toBe(\"published\");\n  });\n\n  it(\"should throw when sending content without a codec\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    await expect(\n      // @ts-expect-error - testing invalid content type\n      conversation.send({ foo: \"bar\" }, ContentTypeTest),\n    ).rejects.toThrow();\n  });\n\n  it(\"should add and remove admins\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    expect(await conversation.isSuperAdmin(client1.inboxId!)).toBe(true);\n    await conversation.listSuperAdmins();\n    expect(conversation.superAdmins.length).toBe(1);\n    expect(conversation.superAdmins).toContain(client1.inboxId);\n    expect(await conversation.isAdmin(client1.inboxId!)).toBe(false);\n    expect(await conversation.isAdmin(client2.inboxId!)).toBe(false);\n    await conversation.listAdmins();\n    expect(conversation.admins.length).toBe(0);\n\n    await conversation.addAdmin(client2.inboxId!);\n    expect(await conversation.isAdmin(client2.inboxId!)).toBe(true);\n    await conversation.listAdmins();\n    expect(conversation.admins.length).toBe(1);\n    expect(conversation.admins).toContain(client2.inboxId);\n\n    await conversation.removeAdmin(client2.inboxId!);\n    expect(await conversation.isAdmin(client2.inboxId!)).toBe(false);\n    await conversation.listAdmins();\n    expect(conversation.admins.length).toBe(0);\n  });\n\n  it(\"should add and remove super admins\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    expect(await conversation.isSuperAdmin(client1.inboxId!)).toBe(true);\n    expect(await conversation.isSuperAdmin(client2.inboxId!)).toBe(false);\n\n    await conversation.listSuperAdmins();\n    expect(conversation.superAdmins.length).toBe(1);\n    expect(conversation.superAdmins).toContain(client1.inboxId);\n\n    await conversation.addSuperAdmin(client2.inboxId!);\n    expect(await conversation.isSuperAdmin(client2.inboxId!)).toBe(true);\n\n    await conversation.listSuperAdmins();\n    expect(conversation.superAdmins.length).toBe(2);\n    expect(conversation.superAdmins).toContain(client1.inboxId);\n    expect(conversation.superAdmins).toContain(client2.inboxId);\n\n    await conversation.removeSuperAdmin(client2.inboxId!);\n    expect(await conversation.isSuperAdmin(client2.inboxId!)).toBe(false);\n\n    await conversation.listSuperAdmins();\n    expect(conversation.superAdmins.length).toBe(1);\n    expect(conversation.superAdmins).toContain(client1.inboxId);\n  });\n\n  it(\"should manage group consent state\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const group = await client1.conversations.newGroup([client2.inboxId!]);\n    expect(group).toBeDefined();\n    const dmGroup = await client1.conversations.newDm(client3.inboxId!);\n    expect(dmGroup).toBeDefined();\n\n    await client2.conversations.sync();\n    const group2 = await client2.conversations.getConversationById(group.id);\n    expect(group2).toBeDefined();\n\n    expect(await group2!.consentState()).toBe(ConsentState.Unknown);\n    await group2!.send(\"gm!\");\n    expect(await group2!.consentState()).toBe(ConsentState.Allowed);\n\n    await client3.conversations.sync();\n    const dmGroup2 = await client3.conversations.getConversationById(\n      dmGroup.id,\n    );\n    expect(dmGroup2).toBeDefined();\n\n    expect(await dmGroup2!.consentState()).toBe(ConsentState.Unknown);\n    await dmGroup2!.send(\"gm!\");\n    expect(await dmGroup2!.consentState()).toBe(ConsentState.Allowed);\n  });\n\n  it(\"should update group permission policy\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    const permissions = await conversation.permissions();\n    expect(permissions.policySet).toEqual({\n      addMemberPolicy: 0,\n      removeMemberPolicy: 2,\n      addAdminPolicy: 3,\n      removeAdminPolicy: 3,\n      updateGroupNamePolicy: 0,\n      updateGroupDescriptionPolicy: 0,\n      updateGroupImageUrlSquarePolicy: 0,\n      updateMessageDisappearingPolicy: 2,\n    });\n\n    await conversation.updatePermission(\n      PermissionUpdateType.AddMember,\n      PermissionPolicy.Admin,\n    );\n\n    await conversation.updatePermission(\n      PermissionUpdateType.RemoveMember,\n      PermissionPolicy.SuperAdmin,\n    );\n\n    await conversation.updatePermission(\n      PermissionUpdateType.AddAdmin,\n      PermissionPolicy.Admin,\n    );\n\n    await conversation.updatePermission(\n      PermissionUpdateType.RemoveAdmin,\n      PermissionPolicy.Admin,\n    );\n\n    await conversation.updatePermission(\n      PermissionUpdateType.UpdateMetadata,\n      PermissionPolicy.Admin,\n      MetadataField.GroupName,\n    );\n\n    await conversation.updatePermission(\n      PermissionUpdateType.UpdateMetadata,\n      PermissionPolicy.Admin,\n      MetadataField.Description,\n    );\n\n    await conversation.updatePermission(\n      PermissionUpdateType.UpdateMetadata,\n      PermissionPolicy.Admin,\n      MetadataField.ImageUrlSquare,\n    );\n\n    const permissions2 = await conversation.permissions();\n    expect(permissions2.policySet).toEqual({\n      addMemberPolicy: 2,\n      removeMemberPolicy: 3,\n      addAdminPolicy: 2,\n      removeAdminPolicy: 2,\n      updateGroupNamePolicy: 2,\n      updateGroupDescriptionPolicy: 2,\n      updateGroupImageUrlSquarePolicy: 2,\n      updateMessageDisappearingPolicy: 2,\n    });\n\n    const conversation2 = await client1.conversations.newGroup([], {\n      permissions: GroupPermissionsOptions.AdminOnly,\n    });\n\n    const permissions3 = await conversation2.permissions();\n    expect(permissions3.policySet).toEqual({\n      addMemberPolicy: 2,\n      removeMemberPolicy: 2,\n      addAdminPolicy: 3,\n      removeAdminPolicy: 3,\n      updateGroupNamePolicy: 2,\n      updateGroupDescriptionPolicy: 2,\n      updateGroupImageUrlSquarePolicy: 2,\n      updateMessageDisappearingPolicy: 2,\n    });\n\n    // required when group has no members\n    await conversation2.sync();\n\n    await conversation2.updatePermission(\n      PermissionUpdateType.AddMember,\n      PermissionPolicy.Allow,\n    );\n\n    const permissions4 = await conversation2.permissions();\n    expect(permissions4.policySet).toEqual({\n      addMemberPolicy: 0,\n      removeMemberPolicy: 2,\n      addAdminPolicy: 3,\n      removeAdminPolicy: 3,\n      updateGroupNamePolicy: 2,\n      updateGroupDescriptionPolicy: 2,\n      updateGroupImageUrlSquarePolicy: 2,\n      updateMessageDisappearingPolicy: 2,\n    });\n  });\n\n  it(\"should handle disappearing messages in a group\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n\n    // create message disappearing settings so that messages are deleted after 1 second\n    const messageDisappearingSettings: SafeMessageDisappearingSettings = {\n      fromNs: 5_000_000n,\n      inNs: 5_000_000n,\n    };\n\n    // create a group with message disappearing settings\n    const conversation = await client1.conversations.newGroup(\n      [client2.inboxId!],\n      {\n        messageDisappearingSettings,\n      },\n    );\n\n    // verify that the message disappearing settings are set and enabled\n    expect(await conversation.messageDisappearingSettings()).toEqual({\n      fromNs: 5_000_000n,\n      inNs: 5_000_000n,\n    });\n    expect(await conversation.isMessageDisappearingEnabled()).toBe(true);\n\n    // send messages to the group\n    await conversation.send(\"gm\");\n    await conversation.send(\"gm2\");\n\n    // verify that the messages are sent\n    expect((await conversation.messages()).length).toBe(3);\n\n    // sync the messages to the other client\n    await client2.conversations.sync();\n    const conversation2 = await client2.conversations.getConversationById(\n      conversation.id,\n    );\n    await conversation2!.sync();\n\n    // verify that the message disappearing settings are set and enabled\n    expect(await conversation2!.messageDisappearingSettings()).toEqual({\n      fromNs: 5_000_000n,\n      inNs: 5_000_000n,\n    });\n    expect(await conversation2!.isMessageDisappearingEnabled()).toBe(true);\n\n    // wait for the messages to be deleted\n    await sleep(5000);\n\n    // verify that the messages are deleted\n    expect((await conversation.messages()).length).toBe(1);\n\n    // verify that the messages are deleted on the other client\n    expect((await conversation2!.messages()).length).toBe(1);\n\n    // remove the message disappearing settings\n    await conversation.removeMessageDisappearingSettings();\n\n    // verify that the message disappearing settings are removed\n    expect(await conversation.messageDisappearingSettings()).toEqual({\n      fromNs: 0n,\n      inNs: 0n,\n    });\n\n    expect(await conversation.isMessageDisappearingEnabled()).toBe(false);\n\n    // sync other group\n    await conversation2!.sync();\n\n    // verify that the message disappearing settings are set and disabled\n    expect(await conversation2!.messageDisappearingSettings()).toEqual({\n      fromNs: 0n,\n      inNs: 0n,\n    });\n    expect(await conversation2!.isMessageDisappearingEnabled()).toBe(false);\n\n    // send messages to the group\n    await conversation2!.send(\"gm\");\n    await conversation2!.send(\"gm2\");\n\n    // verify that the messages are sent\n    expect((await conversation2!.messages()).length).toBe(5);\n\n    // sync original group\n    await conversation.sync();\n\n    // verify that the messages are not deleted\n    expect((await conversation.messages()).length).toBe(5);\n  });\n\n  it(\"should handle disappearing messages in a DM group\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n\n    // create message disappearing settings so that messages are deleted after 1 second\n    const messageDisappearingSettings: SafeMessageDisappearingSettings = {\n      fromNs: 5_000_000n,\n      inNs: 5_000_000n,\n    };\n\n    // create a group with message disappearing settings\n    const conversation = await client1.conversations.newDm(client2.inboxId!, {\n      messageDisappearingSettings,\n    });\n\n    // verify that the message disappearing settings are set and enabled\n    expect(await conversation.messageDisappearingSettings()).toEqual({\n      fromNs: 5_000_000n,\n      inNs: 5_000_000n,\n    });\n    expect(await conversation.isMessageDisappearingEnabled()).toBe(true);\n\n    // send messages to the group\n    await conversation.send(\"gm\");\n    await conversation.send(\"gm2\");\n\n    // verify that the messages are sent\n    expect((await conversation.messages()).length).toBe(3);\n\n    // sync the messages to the other client\n    await client2.conversations.sync();\n    const conversation2 = await client2.conversations.getConversationById(\n      conversation.id,\n    );\n    await conversation2!.sync();\n\n    // verify that the message disappearing settings are set and enabled\n    expect(await conversation2!.messageDisappearingSettings()).toEqual({\n      fromNs: 5_000_000n,\n      inNs: 5_000_000n,\n    });\n    expect(await conversation2!.isMessageDisappearingEnabled()).toBe(true);\n\n    // wait for the messages to be deleted\n    await sleep(5000);\n\n    // verify that the messages are deleted\n    expect((await conversation.messages()).length).toBe(1);\n\n    // verify that the messages are deleted on the other client\n    expect((await conversation2!.messages()).length).toBe(1);\n\n    // remove the message disappearing settings\n    await conversation.removeMessageDisappearingSettings();\n\n    // verify that the message disappearing settings are removed\n    expect(await conversation.messageDisappearingSettings()).toEqual({\n      fromNs: 0n,\n      inNs: 0n,\n    });\n\n    expect(await conversation.isMessageDisappearingEnabled()).toBe(false);\n\n    // sync other group\n    await conversation2!.sync();\n\n    // verify that the message disappearing settings are set and disabled\n    expect(await conversation2!.messageDisappearingSettings()).toEqual({\n      fromNs: 0n,\n      inNs: 0n,\n    });\n    expect(await conversation2!.isMessageDisappearingEnabled()).toBe(false);\n\n    // send messages to the group\n    await conversation2!.send(\"gm\");\n    await conversation2!.send(\"gm2\");\n\n    // verify that the messages are sent\n    expect((await conversation2!.messages()).length).toBe(3);\n\n    // sync original group\n    await conversation.sync();\n\n    // verify that the messages are not deleted\n    expect((await conversation.messages()).length).toBe(3);\n  });\n\n  it(\"should stream messages\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    await client2.conversations.sync();\n\n    const conversation2 = await client2.conversations.list();\n    expect(conversation2.length).toBe(1);\n    expect(conversation2[0].id).toBe(conversation.id);\n\n    const streamedMessages: string[] = [];\n    const stream = await conversation2[0].stream({\n      onValue: (message) => {\n        streamedMessages.push(message.content as string);\n      },\n    });\n\n    await conversation.send(\"gm\");\n    await conversation.send(\"gm2\");\n\n    setTimeout(() => {\n      void stream.end();\n    }, 100);\n\n    let count = 0;\n    for await (const message of stream) {\n      count++;\n      expect(message).toBeDefined();\n      if (count === 1) {\n        expect(message.content).toBe(\"gm\");\n      }\n      if (count === 2) {\n        expect(message.content).toBe(\"gm2\");\n      }\n    }\n\n    expect(streamedMessages).toEqual([\"gm\", \"gm2\"]);\n  });\n\n  it(\"should get hmac keys\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    const hmacKeys = await conversation.getHmacKeys();\n    const groupIds = Array.from(hmacKeys.keys());\n    for (const groupId of groupIds) {\n      expect(hmacKeys.get(groupId)?.length).toBe(3);\n      expect(hmacKeys.get(groupId)?.[0].key).toBeDefined();\n      expect(hmacKeys.get(groupId)?.[0].epoch).toBeDefined();\n      expect(hmacKeys.get(groupId)?.[1].key).toBeDefined();\n      expect(hmacKeys.get(groupId)?.[1].epoch).toBeDefined();\n      expect(hmacKeys.get(groupId)?.[2].key).toBeDefined();\n      expect(hmacKeys.get(groupId)?.[2].epoch).toBeDefined();\n    }\n  });\n\n  it(\"should get conversation debug info\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n    const debugInfo = await conversation.debugInfo();\n    console.log(debugInfo);\n    expect(debugInfo).toBeDefined();\n    expect(debugInfo.epoch).toBeDefined();\n    expect(debugInfo.maybeForked).toBe(false);\n    expect(debugInfo.forkDetails).toBe(\"\");\n    expect(debugInfo.isCommitLogForked).toBeUndefined();\n    expect(debugInfo.localCommitLog).toBeDefined();\n    expect(debugInfo.remoteCommitLog).toBeDefined();\n    expect(debugInfo.cursor).toBeGreaterThan(0n);\n  });\n\n  it(\"should filter messages by content type\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n\n    await conversation.send(\"gm\");\n\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(2);\n\n    const filteredMessages = await conversation.messages({\n      contentTypes: [ContentType.Text],\n    });\n    expect(filteredMessages.length).toBe(1);\n  });\n});\n",
      "size_bytes": 32312
    },
    "sdks/browser-sdk/src/types/actions.ts": {
      "content": "import type { ClientAction } from \"@/types/actions/client\";\nimport type { ConversationAction } from \"@/types/actions/conversation\";\nimport type { ConversationsAction } from \"@/types/actions/conversations\";\nimport type { DebugInformationAction } from \"@/types/actions/debugInformation\";\nimport type { DmAction } from \"@/types/actions/dm\";\nimport type { GroupAction } from \"@/types/actions/group\";\nimport type { PreferencesAction } from \"@/types/actions/preferences\";\n\ntype UnknownAction = {\n  action: string;\n  id: string;\n  result: unknown;\n  data: unknown;\n};\n\nexport type ClientWorkerAction =\n  | {\n      action: \"endStream\";\n      id: string;\n      result: undefined;\n      data: {\n        streamId: string;\n      };\n    }\n  | ClientAction\n  | ConversationAction\n  | ConversationsAction\n  | DmAction\n  | GroupAction\n  | PreferencesAction\n  | DebugInformationAction;\n\nexport type ActionName<T extends UnknownAction> = T[\"action\"];\n\nexport type ExtractAction<\n  T extends UnknownAction,\n  A extends ActionName<T>,\n> = Extract<T, { action: A }>;\n\nexport type ExtractActionWithoutData<\n  T extends UnknownAction,\n  A extends ActionName<T>,\n> = Omit<ExtractAction<T, A>, \"data\">;\n\nexport type ExtractActionWithoutResult<\n  T extends UnknownAction,\n  A extends ActionName<T>,\n> = Omit<ExtractAction<T, A>, \"result\">;\n\nexport type ExtractActionData<\n  T extends UnknownAction,\n  A extends ActionName<T>,\n> = ExtractAction<T, A>[\"data\"];\n\nexport type ExtractActionResult<\n  T extends UnknownAction,\n  A extends ActionName<T>,\n> = ExtractAction<T, A>[\"result\"];\n\nexport type ActionWithoutData<T extends UnknownAction> = {\n  [A in T[\"action\"]]: Omit<Extract<T, { action: A }>, \"data\">;\n}[T[\"action\"]];\n\nexport type ActionWithoutResult<T extends UnknownAction> = {\n  [A in T[\"action\"]]: Omit<Extract<T, { action: A }>, \"result\">;\n}[T[\"action\"]];\n\nexport type ActionErrorData<T extends UnknownAction> = {\n  id: string;\n  action: ActionName<T>;\n  error: Error;\n};\n\nexport type ExtractActionGroup<\n  T extends UnknownAction,\n  U extends string,\n> = Extract<T, { action: `${U}.${string}` }>;\n",
      "size_bytes": 2080
    },
    "sdks/browser-sdk/src/workers/utils.ts": {
      "content": "import init, {\n  applySignatureRequest,\n  generateInboxId,\n  getInboxIdForIdentifier as get_inbox_id_for_identifier,\n  inboxStateFromInboxIds,\n  revokeInstallationsSignatureRequest,\n  type Identifier,\n  type SignatureRequestHandle,\n} from \"@xmtp/wasm-bindings\";\nimport { ApiUrls } from \"@/constants\";\nimport type {\n  ActionErrorData,\n  ActionName,\n  ActionWithoutResult,\n  ExtractActionWithoutData,\n} from \"@/types/actions\";\nimport type { UtilsWorkerAction } from \"@/types/actions/utils\";\nimport type { XmtpEnv } from \"@/types/options\";\nimport { toSafeInboxState } from \"@/utils/conversions\";\n\nconst signatureRequests = new Map<string, SignatureRequestHandle>();\n\n/**\n * Type-safe postMessage\n */\nconst postMessage = <A extends ActionName<UtilsWorkerAction>>(\n  data: ExtractActionWithoutData<UtilsWorkerAction, A>,\n) => {\n  self.postMessage(data);\n};\n\n/**\n * Type-safe postMessage for errors\n */\nconst postMessageError = (data: ActionErrorData<UtilsWorkerAction>) => {\n  self.postMessage(data);\n};\n\nconst getInboxIdForIdentifier = async (\n  identifier: Identifier,\n  env?: XmtpEnv,\n) => {\n  const host = env ? ApiUrls[env] : ApiUrls.dev;\n  return get_inbox_id_for_identifier(host, identifier);\n};\n\nlet enableLogging = false;\n\nself.onmessage = async (\n  event: MessageEvent<ActionWithoutResult<UtilsWorkerAction>>,\n) => {\n  const { action, id, data } = event.data;\n\n  if (enableLogging) {\n    console.log(\"utils worker received event data\", event.data);\n  }\n\n  // initialize WASM module\n  await init();\n\n  try {\n    switch (action) {\n      case \"utils.init\": {\n        enableLogging = data.enableLogging;\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"utils.generateInboxId\": {\n        const result = generateInboxId(data.identifier);\n        postMessage({\n          id,\n          action,\n          result,\n        });\n        break;\n      }\n      case \"utils.getInboxIdForIdentifier\": {\n        const result = await getInboxIdForIdentifier(data.identifier, data.env);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"utils.revokeInstallationsSignatureText\": {\n        const host = ApiUrls[data.env ?? \"dev\"];\n        const signatureRequest = await revokeInstallationsSignatureRequest(\n          host,\n          data.identifier,\n          data.inboxId,\n          data.installationIds,\n        );\n        const signatureText = await signatureRequest.signatureText();\n        signatureRequests.set(data.signatureRequestId, signatureRequest);\n        const result = {\n          signatureText,\n          signatureRequestId: data.signatureRequestId,\n        };\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"utils.revokeInstallations\": {\n        const host = ApiUrls[data.env ?? \"dev\"];\n        const signatureRequest = signatureRequests.get(data.signatureRequestId);\n        if (!signatureRequest) {\n          throw new Error(\"Signature request not found\");\n        }\n        switch (data.signer.type) {\n          case \"EOA\":\n            await signatureRequest.addEcdsaSignature(data.signer.signature);\n            break;\n          case \"SCW\":\n            await signatureRequest.addScwSignature(\n              data.signer.identifier,\n              data.signer.signature,\n              data.signer.chainId,\n              data.signer.blockNumber,\n            );\n            break;\n        }\n        await applySignatureRequest(host, signatureRequest);\n        signatureRequests.delete(data.signatureRequestId);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"utils.inboxStateFromInboxIds\": {\n        const host = ApiUrls[data.env ?? \"dev\"];\n        try {\n          const inboxStates = await inboxStateFromInboxIds(host, data.inboxIds);\n          const result = inboxStates.map((inboxState) =>\n            toSafeInboxState(inboxState),\n          );\n          postMessage({ id, action, result });\n        } catch (e) {\n          console.error(\"utils received error\", e);\n        }\n        break;\n      }\n    }\n  } catch (e) {\n    postMessageError({ id, action, error: e as Error });\n  }\n};\n",
      "size_bytes": 4133
    },
    "apps/xmtp.chat/src/components/Messages/MessageContentWithWrapper.tsx": {
      "content": "import type { DecodedMessage } from \"@xmtp/browser-sdk\";\nimport {\n  ContentTypeGroupUpdated,\n  type GroupUpdated,\n} from \"@xmtp/content-type-group-updated\";\nimport { GroupUpdatedContent } from \"@/components/Messages/GroupUpdatedContent\";\nimport { IntentContent } from \"@/components/Messages/IntentContent\";\nimport { MessageContent } from \"@/components/Messages/MessageContent\";\nimport {\n  MessageContentWrapper,\n  type MessageContentAlign,\n} from \"@/components/Messages/MessageContentWrapper\";\nimport { ContentTypeIntent, type Intent } from \"@/content-types/Intent\";\n\nexport type MessageContentWithWrapperProps = {\n  align: MessageContentAlign;\n  senderInboxId: string;\n  message: DecodedMessage;\n  scrollToMessage: (id: string) => void;\n};\n\nexport const MessageContentWithWrapper: React.FC<\n  MessageContentWithWrapperProps\n> = ({ message, align, senderInboxId, scrollToMessage }) => {\n  if (message.contentType.sameAs(ContentTypeGroupUpdated)) {\n    return (\n      <GroupUpdatedContent\n        content={message.content as GroupUpdated}\n        sentAtNs={message.sentAtNs}\n      />\n    );\n  }\n\n  if (message.contentType.sameAs(ContentTypeIntent)) {\n    return (\n      <IntentContent\n        content={message.content as Intent}\n        sentAtNs={message.sentAtNs}\n        senderInboxId={senderInboxId}\n      />\n    );\n  }\n\n  return (\n    <MessageContentWrapper\n      align={align}\n      senderInboxId={senderInboxId}\n      sentAtNs={message.sentAtNs}>\n      <MessageContent\n        contentType={message.contentType}\n        content={message.content}\n        conversationId={message.conversationId}\n        fallback={message.fallback}\n        align={align}\n        scrollToMessage={scrollToMessage}\n      />\n    </MessageContentWrapper>\n  );\n};\n",
      "size_bytes": 1744
    },
    "sdks/agent-sdk/src/core/filter.test.ts": {
      "content": "import {\n  ContentTypeReaction,\n  type Reaction,\n} from \"@xmtp/content-type-reaction\";\nimport { ContentTypeReply, type Reply } from \"@xmtp/content-type-reply\";\nimport { ContentTypeText } from \"@xmtp/content-type-text\";\nimport { Dm, Group, type Client, type DecodedMessage } from \"@xmtp/node-sdk\";\nimport { describe, expect, it, vi } from \"vitest\";\nimport { filter } from \"@/core/filter.js\";\n\nconst mockClient = {\n  inboxId: \"test-client-inbox-id\",\n} as unknown as Client;\n\nconst dmConversation = {\n  id: \"direct-message\",\n  metadata: () =>\n    Promise.resolve({\n      creatorInboxId: \"test-client-inbox-id\",\n      conversationType: \"dm\",\n    }),\n} as unknown as Dm;\n\nObject.setPrototypeOf(dmConversation, Dm.prototype);\n\nconst createMockGroup = (\n  adminInboxIds: string[] = [],\n  superAdminInboxIds: string[] = [],\n) => {\n  const mockGroup = {\n    id: \"group-conversation\",\n    metadata: () =>\n      Promise.resolve({\n        creatorInboxId: \"test-client-inbox-id\",\n        conversationType: \"group\",\n      }),\n    isAdmin: vi.fn((inboxId: string) => adminInboxIds.includes(inboxId)),\n    isSuperAdmin: vi.fn((inboxId: string) =>\n      superAdminInboxIds.includes(inboxId),\n    ),\n  };\n\n  Object.setPrototypeOf(mockGroup, Group.prototype);\n\n  return mockGroup as unknown as Group;\n};\n\nconst createMockMessage = (overrides: Partial<DecodedMessage> = {}) =>\n  ({\n    senderInboxId: \"my-inbox-id\",\n    contentType: ContentTypeText,\n    content: \"Test message\",\n    ...overrides,\n  }) as DecodedMessage;\n\ndescribe(\"Filters\", () => {\n  describe(\"fromSelf\", () => {\n    it(\"should return false for messages not from self\", () => {\n      const message = createMockMessage({ senderInboxId: \"other-inbox-id\" });\n      const result = filter.fromSelf(message, mockClient);\n      expect(result).toBe(false);\n    });\n\n    it(\"should return true for messages from self\", () => {\n      const message = createMockMessage({\n        senderInboxId: \"test-client-inbox-id\",\n      });\n      const result = filter.fromSelf(message, mockClient);\n      expect(result).toBe(true);\n    });\n  });\n\n  describe(\"hasContent\", () => {\n    it(\"should return true for messages with defined content\", () => {\n      const message = createMockMessage({ content: \"Hello world\" });\n      const result = filter.hasContent(message);\n      expect(result).toBe(true);\n    });\n\n    it(\"should return false for messages with null content\", () => {\n      const message = createMockMessage({ content: null });\n      const result = filter.hasContent(message);\n      expect(result).toBe(false);\n    });\n\n    it(\"should return false for messages with undefined content\", () => {\n      const message = createMockMessage({ content: undefined });\n      const result = filter.hasContent(message);\n      expect(result).toBe(false);\n    });\n  });\n\n  describe(\"isDM\", () => {\n    it(\"should return true for DM conversations\", () => {\n      const result = filter.isDM(dmConversation);\n      expect(result).toBe(true);\n    });\n\n    it(\"should return false for group conversations\", () => {\n      const groupConversation = createMockGroup();\n      const result = filter.isDM(groupConversation);\n      expect(result).toBe(false);\n    });\n  });\n\n  describe(\"isGroup\", () => {\n    it(\"should return true for group conversations\", () => {\n      const groupConversation = createMockGroup();\n      const result = filter.isGroup(groupConversation);\n      expect(result).toBe(true);\n    });\n\n    it(\"should return false for DM conversations\", () => {\n      const result = filter.isGroup(dmConversation);\n      expect(result).toBe(false);\n    });\n  });\n\n  describe(\"isGroupAdmin\", () => {\n    it(\"should return true when sender is a group admin\", () => {\n      const adminInboxId = \"admin-inbox-id\";\n      const message = createMockMessage({ senderInboxId: adminInboxId });\n      const mockGroup = createMockGroup([adminInboxId], []);\n\n      const result = filter.isGroupAdmin(mockGroup, message);\n      expect(result).toBe(true);\n    });\n\n    it(\"should return false when sender is not a group admin\", () => {\n      const nonAdminInboxId = \"non-admin-inbox-id\";\n      const adminInboxId = \"admin-inbox-id\";\n      const message = createMockMessage({ senderInboxId: nonAdminInboxId });\n      const mockGroup = createMockGroup([adminInboxId], []);\n\n      const result = filter.isGroupAdmin(mockGroup, message);\n      expect(result).toBe(false);\n    });\n\n    it(\"should return false when conversation is not a group\", () => {\n      const message = createMockMessage({ senderInboxId: \"any-inbox-id\" });\n      const result = filter.isGroupAdmin(dmConversation, message);\n      expect(result).toBe(false);\n    });\n  });\n\n  describe(\"isGroupSuperAdmin\", () => {\n    it(\"should return true when sender is a group super admin\", () => {\n      const superAdminInboxId = \"super-admin-inbox-id\";\n      const message = createMockMessage({ senderInboxId: superAdminInboxId });\n      const mockGroup = createMockGroup([], [superAdminInboxId]);\n\n      const result = filter.isGroupSuperAdmin(mockGroup, message);\n      expect(result).toBe(true);\n    });\n\n    it(\"should return false when sender is not a group super admin\", () => {\n      const nonSuperAdminInboxId = \"non-super-admin-inbox-id\";\n      const superAdminInboxId = \"super-admin-inbox-id\";\n      const message = createMockMessage({\n        senderInboxId: nonSuperAdminInboxId,\n      });\n      const mockGroup = createMockGroup([], [superAdminInboxId]);\n\n      const result = filter.isGroupSuperAdmin(mockGroup, message);\n      expect(result).toBe(false);\n    });\n\n    it(\"should return false when conversation is not a group\", () => {\n      const message = createMockMessage({ senderInboxId: \"any-inbox-id\" });\n      const result = filter.isGroupSuperAdmin(dmConversation, message);\n      expect(result).toBe(false);\n    });\n\n    it(\"should return false when sender is regular admin but not super admin\", () => {\n      const adminInboxId = \"admin-inbox-id\";\n      const superAdminInboxId = \"super-admin-inbox-id\";\n      const message = createMockMessage({ senderInboxId: adminInboxId });\n      const mockGroup = createMockGroup([adminInboxId], [superAdminInboxId]);\n\n      const result = filter.isGroupSuperAdmin(mockGroup, message);\n      expect(result).toBe(false);\n    });\n  });\n\n  describe(\"isReaction\", () => {\n    it(\"should return true for reaction messages\", () => {\n      const reaction: Reaction = {\n        action: \"added\",\n        reference: \"message-id\",\n        referenceInboxId: \"sender-inbox-id\",\n        schema: \"unicode\",\n        content: \"👍\",\n      };\n\n      const message = createMockMessage({\n        content: reaction,\n        contentType: ContentTypeReaction,\n      });\n\n      const result = filter.isReaction(message);\n      expect(result).toBe(true);\n    });\n\n    it(\"should return false for non-reaction messages\", () => {\n      const message = createMockMessage({ contentType: ContentTypeText });\n      const result = filter.isReaction(message);\n      expect(result).toBe(false);\n    });\n  });\n\n  describe(\"isReply\", () => {\n    it(\"should return true for reply messages\", () => {\n      const reply: Reply = {\n        reference: \"message-id\",\n        referenceInboxId: \"sender-inbox-id\",\n        contentType: ContentTypeText,\n        content: \"This is a reply\",\n      };\n\n      const message = createMockMessage({\n        content: reply,\n        contentType: ContentTypeReply,\n      });\n\n      const result = filter.isReply(message);\n      expect(result).toBe(true);\n    });\n\n    it(\"should return false for non-reply messages\", () => {\n      const message = createMockMessage({ contentType: ContentTypeText });\n      const result = filter.isReply(message);\n      expect(result).toBe(false);\n    });\n  });\n\n  describe(\"isText\", () => {\n    it(\"should return true for text messages\", () => {\n      const message = createMockMessage({ contentType: ContentTypeText });\n      const result = filter.isText(message);\n      expect(result).toBe(true);\n    });\n\n    it(\"should return false for non-text messages\", () => {\n      const message = createMockMessage({ contentType: ContentTypeReply });\n      const result = filter.isText(message);\n      expect(result).toBe(false);\n    });\n  });\n\n  describe(\"isTextReply\", () => {\n    it(\"should return true for text reply messages\", () => {\n      const reply: Reply = {\n        reference: \"message-id\",\n        referenceInboxId: \"sender-inbox-id\",\n        contentType: ContentTypeText,\n        content: \"string\",\n      };\n\n      const message = createMockMessage({\n        content: reply,\n        contentType: ContentTypeReply,\n      });\n\n      const result = filter.isTextReply(message);\n      expect(result).toBe(true);\n    });\n\n    it(\"should return false for non-reply messages\", () => {\n      const message = createMockMessage({ contentType: ContentTypeText });\n      const result = filter.isTextReply(message);\n      expect(result).toBe(false);\n    });\n\n    it(\"should return false for non-text reply messages\", () => {\n      const reply: Reply = {\n        reference: \"message-id\",\n        referenceInboxId: \"sender-inbox-id\",\n        contentType: ContentTypeReaction,\n        content: {\n          action: \"added\",\n          reference: \"ref\",\n          referenceInboxId: \"id\",\n          schema: \"unicode\",\n          content: \"👍\",\n        },\n      };\n\n      const message = createMockMessage({\n        content: reply,\n        contentType: ContentTypeReply,\n      });\n\n      const result = filter.isTextReply(message);\n      expect(result).toBe(false);\n    });\n  });\n});\n",
      "size_bytes": 9522
    },
    "sdks/node-sdk/src/Preferences.ts": {
      "content": "import type {\n  Client,\n  Consent,\n  ConsentEntityType,\n  Conversations,\n} from \"@xmtp/node-bindings\";\nimport {\n  createStream,\n  type StreamCallback,\n  type StreamOptions,\n} from \"@/utils/streams\";\n\nexport type PreferenceUpdate = {\n  type: string;\n  HmacKeyUpdate?: {\n    key: Uint8Array;\n  };\n};\n\n/**\n * Manages user preferences and consent states\n *\n * This class is not intended to be initialized directly.\n */\nexport class Preferences {\n  #client: Client;\n  #conversations: Conversations;\n\n  /**\n   * Creates a new preferences instance\n   *\n   * @param client - The client instance managing preferences\n   * @param conversations - The underlying conversations instance\n   */\n  constructor(client: Client, conversations: Conversations) {\n    this.#client = client;\n    this.#conversations = conversations;\n  }\n\n  sync() {\n    return this.#client.syncPreferences();\n  }\n\n  /**\n   * Retrieves the current inbox state\n   *\n   * @param refreshFromNetwork - Optional flag to force refresh from network\n   * @returns Promise that resolves with the inbox state\n   */\n  async inboxState(refreshFromNetwork: boolean = false) {\n    return this.#client.inboxState(refreshFromNetwork);\n  }\n\n  /**\n   * Gets the latest inbox state for a specific inbox\n   *\n   * @param inboxId - The inbox ID to get state for\n   * @returns Promise that resolves with the latest inbox state\n   */\n  async getLatestInboxState(inboxId: string) {\n    return this.#client.getLatestInboxState(inboxId);\n  }\n\n  /**\n   * Retrieves inbox state for specific inbox IDs\n   *\n   * @param inboxIds - Array of inbox IDs to get state for\n   * @param refreshFromNetwork - Optional flag to force refresh from network\n   * @returns Promise that resolves with the inbox state for the inbox IDs\n   */\n  async inboxStateFromInboxIds(\n    inboxIds: string[],\n    refreshFromNetwork?: boolean,\n  ) {\n    return this.#client.addressesFromInboxId(\n      refreshFromNetwork ?? false,\n      inboxIds,\n    );\n  }\n\n  /**\n   * Updates consent states for multiple records\n   *\n   * @param consentStates - Array of consent records to update\n   * @returns Promise that resolves when consent states are updated\n   */\n  async setConsentStates(consentStates: Consent[]) {\n    return this.#client.setConsentStates(consentStates);\n  }\n\n  /**\n   * Retrieves consent state for a specific entity\n   *\n   * @param entityType - Type of entity to get consent for\n   * @param entity - Entity identifier\n   * @returns Promise that resolves with the consent state\n   */\n  async getConsentState(entityType: ConsentEntityType, entity: string) {\n    return this.#client.getConsentState(entityType, entity);\n  }\n\n  /**\n   * Creates a stream of consent state updates\n   *\n   * @param options - Optional stream options\n   * @returns Stream instance for consent updates\n   */\n  streamConsent(options?: StreamOptions<Consent[]>) {\n    const streamConsent = async (\n      callback: StreamCallback<Consent[]>,\n      onFail: () => void,\n    ) => {\n      await this.sync();\n      return this.#conversations.streamConsent(callback, onFail);\n    };\n    return createStream(streamConsent, undefined, options);\n  }\n\n  /**\n   * Creates a stream of user preference updates\n   *\n   * @param options - Optional stream options\n   * @returns Stream instance for preference updates\n   */\n  streamPreferences(options?: StreamOptions<PreferenceUpdate>) {\n    const streamPreferences = async (\n      callback: StreamCallback<PreferenceUpdate>,\n      onFail: () => void,\n    ) => {\n      await this.sync();\n      return this.#conversations.streamPreferences(callback, onFail);\n    };\n    return createStream(streamPreferences, undefined, options);\n  }\n}\n",
      "size_bytes": 3653
    },
    "apps/xmtp.chat/src/icons/EphemeralWallet.tsx": {
      "content": "export const EphemeralWallet = () => {\n  return (\n    <svg\n      stroke=\"currentColor\"\n      fill=\"currentColor\"\n      strokeWidth=\"0\"\n      viewBox=\"0 0 256 256\"\n      height=\"28\"\n      width=\"28\"\n      xmlns=\"http://www.w3.org/2000/svg\">\n      <path d=\"M128,40a96,96,0,1,0,96,96A96.11,96.11,0,0,0,128,40Zm45.66,61.66-40,40a8,8,0,0,1-11.32-11.32l40-40a8,8,0,0,1,11.32,11.32ZM96,16a8,8,0,0,1,8-8h48a8,8,0,0,1,0,16H104A8,8,0,0,1,96,16Z\"></path>\n    </svg>\n  );\n};\n",
      "size_bytes": 463
    },
    "apps/xmtp.chat-api-service/src/api/index.ts": {
      "content": "import { Router } from \"express\";\nimport v1Router from \"./v1/index.js\";\nimport v2Router from \"./v2/index.js\";\n\nconst apiRouter = Router();\n\napiRouter.use(\"/v1\", v1Router);\napiRouter.use(\"/v2\", v2Router);\n\nexport default apiRouter;\n",
      "size_bytes": 231
    },
    "content-types/content-type-text/README.md": {
      "content": "# Text content type\n\nThis package provides an XMTP content type to support text messages.\n\n> [!NOTE]\n> This content type is included by default in official XMTP SDKs.\n\n## Install the package\n\n```bash\n# npm\nnpm i @xmtp/content-type-text\n\n# yarn\nyarn add @xmtp/content-type-text\n\n# pnpm\npnpm i @xmtp/content-type-text\n```\n\n## Send a text message\n\nUse a string to send a text message. It's not required to specify a content type in the send options for text messages.\n\n```tsx\nawait conversation.send(\"gm\");\n```\n\n## Developing\n\nRun `yarn dev` to build the content type and watch for changes, which will trigger a rebuild.\n\nFor more information on contributing to this repository, see our [contributing guidelines](../../CONTRIBUTING.md).\n",
      "size_bytes": 734
    },
    "apps/xmtp.chat/src/components/Landing/MumbleLanding.module.css": {
      "content": "/* Ramestta Info Section */\n.ramesttaInfo {\n  margin: 64px auto 0 auto;\n  max-width: 1120px;\n  padding: 0 20px 60px 20px;\n}\n\n.ramesttaGrid {\n  display: grid;\n  gap: 28px;\n  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));\n  margin-top: 32px;\n}\n\n.ramesttaCard {\n  background: rgba(12, 17, 28, 0.88);\n  border: 1px solid rgba(151, 114, 251, 0.18);\n  border-radius: 22px;\n  box-shadow: 0 4px 24px rgba(7, 11, 24, 0.18);\n  padding: 32px 28px;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n  min-height: 180px;\n}\n\n.ramesttaCardTitle {\n  font-size: 1.12rem;\n  font-weight: 700;\n  color: #cbb6ff;\n  margin-bottom: 12px;\n}\n\n.ramesttaCardDesc {\n  color: rgba(203, 213, 225, 0.78);\n  font-size: 0.98rem;\n  line-height: 1.6;\n}\n.page {\n  position: relative;\n  min-height: 100vh;\n  background:\n    radial-gradient(circle at top left, #11213b, transparent 45%),\n    radial-gradient(\n      circle at bottom right,\n      rgba(21, 94, 117, 0.25),\n      transparent 60%\n    ),\n    #05060f;\n  color: #eef2ff;\n  font-family:\n    \"Inter\",\n    -apple-system,\n    BlinkMacSystemFont,\n    \"Segoe UI\",\n    sans-serif;\n  overflow-x: hidden;\n}\n\n.background {\n  position: fixed;\n  inset: 0;\n  z-index: 0;\n  pointer-events: none;\n}\n\n.background::before,\n.background::after {\n  content: \"\";\n  position: absolute;\n  width: 620px;\n  height: 620px;\n  border-radius: 50%;\n  filter: blur(140px);\n  opacity: 0.4;\n}\n\n.background::before {\n  top: -180px;\n  left: -100px;\n  background: radial-gradient(\n    circle,\n    rgba(10, 255, 241, 0.45),\n    transparent 65%\n  );\n}\n\n.background::after {\n  bottom: -220px;\n  right: -160px;\n  background: radial-gradient(\n    circle,\n    rgba(151, 114, 251, 0.35),\n    transparent 70%\n  );\n}\n\n.navbar {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  z-index: 20;\n  transition:\n    background 180ms ease,\n    box-shadow 180ms ease;\n  background: transparent;\n}\n\n.navbarScrolled {\n  background: rgba(7, 10, 19, 0.88);\n  box-shadow: 0 16px 38px rgba(3, 7, 18, 0.45);\n  backdrop-filter: blur(14px);\n}\n\n.navContainer {\n  max-width: 1120px;\n  margin: 0 auto;\n  padding: 18px 20px;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.brand {\n  display: inline-flex;\n  align-items: center;\n  gap: 12px;\n  text-decoration: none;\n  color: inherit;\n}\n\n.brandIcon {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  width: 42px;\n  height: 42px;\n  border-radius: 50%;\n  background: rgba(10, 255, 241, 0.12);\n  font-weight: 700;\n  color: #0afff1;\n  letter-spacing: 0.05em;\n  font-size: 0.85rem;\n}\n\n.brandLabel {\n  font-size: 1.125rem;\n  font-weight: 700;\n  letter-spacing: 0.02em;\n}\n\n.navLinks {\n  display: flex;\n  gap: 28px;\n}\n\n.navLink {\n  font-size: 0.95rem;\n  color: rgba(226, 232, 240, 0.78);\n  text-decoration: none;\n  transition: color 150ms ease;\n}\n\n.navLink:hover {\n  color: #0afff1;\n}\n\n.navActions {\n  display: flex;\n  align-items: center;\n  gap: 18px;\n}\n\n.menuButton {\n  display: none;\n  width: 44px;\n  height: 44px;\n  border: 1px solid rgba(148, 163, 184, 0.35);\n  border-radius: 12px;\n  background: rgba(10, 12, 22, 0.8);\n  cursor: pointer;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  gap: 6px;\n  transition: border-color 150ms ease;\n}\n\n.menuButton span {\n  display: block;\n  width: 18px;\n  height: 2px;\n  background: #e2e8f0;\n  border-radius: 999px;\n}\n\n.menuButton:hover {\n  border-color: rgba(10, 255, 241, 0.55);\n}\n\n.mobileNav {\n  background: rgba(10, 12, 22, 0.95);\n  border-top: 1px solid rgba(148, 163, 184, 0.16);\n  display: grid;\n  gap: 16px;\n  padding: 20px;\n}\n\n.mobileNavLink {\n  color: rgba(226, 232, 240, 0.86);\n  text-decoration: none;\n  font-size: 0.95rem;\n}\n\n.mobilePrimaryButton {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  padding: 12px 18px;\n  border-radius: 999px;\n  background: linear-gradient(120deg, #0afff1, #9772fb);\n  color: #041016;\n  font-weight: 600;\n  text-decoration: none;\n}\n\n.content {\n  position: relative;\n  z-index: 1;\n  padding-top: 140px;\n}\n\n.content section {\n  scroll-margin-top: 110px;\n}\n\n.hero {\n  padding: 160px 20px 120px;\n  text-align: center;\n  max-width: 760px;\n  margin: 0 auto;\n}\n\n.heroBadge {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  padding: 10px 18px;\n  border-radius: 999px;\n  background: rgba(10, 255, 241, 0.14);\n  border: 1px solid rgba(10, 255, 241, 0.25);\n  font-size: 0.85rem;\n  font-weight: 600;\n  letter-spacing: 0.06em;\n  text-transform: uppercase;\n  color: #0afff1;\n  margin-bottom: 20px;\n}\n\n.heroTitle {\n  font-size: clamp(2.6rem, 6vw, 3.9rem);\n  line-height: 1.05;\n  font-weight: 800;\n  margin-bottom: 24px;\n  background: linear-gradient(120deg, #0afff1, #9772fb);\n  -webkit-background-clip: text;\n  background-clip: text;\n  color: transparent;\n}\n\n.heroCopy {\n  font-size: 1.2rem;\n  color: rgba(226, 232, 240, 0.75);\n  line-height: 1.7;\n  margin-bottom: 32px;\n}\n\n.heroActions {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 16px;\n  justify-content: center;\n  margin-bottom: 20px;\n}\n\n.primaryButton,\n.secondaryButton {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 999px;\n  padding: 14px 24px;\n  font-weight: 600;\n  font-size: 0.98rem;\n  text-decoration: none;\n  transition:\n    transform 160ms ease,\n    box-shadow 160ms ease,\n    background 160ms ease;\n}\n\n.primaryButton {\n  background: linear-gradient(120deg, #0afff1, #8a71f6);\n  color: #040915;\n  box-shadow: 0 18px 40px rgba(10, 255, 241, 0.25);\n}\n\n.primaryButton:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 26px 48px rgba(10, 255, 241, 0.3);\n}\n\n.secondaryButton {\n  border: 1px solid rgba(148, 163, 184, 0.35);\n  background: rgba(15, 23, 42, 0.5);\n  color: rgba(226, 232, 240, 0.85);\n}\n\n.secondaryButton:hover {\n  transform: translateY(-2px);\n  border-color: rgba(10, 255, 241, 0.4);\n  color: #0afff1;\n}\n\n.heroNote {\n  color: rgba(148, 163, 184, 0.75);\n  font-size: 0.95rem;\n}\n\n.heroList {\n  list-style: none;\n  padding: 0;\n  margin: 24px auto 36px;\n  display: grid;\n  gap: 12px;\n  text-align: left;\n  max-width: 680px;\n}\n\n.heroList li {\n  background: rgba(12, 17, 28, 0.65);\n  border: 1px solid rgba(148, 163, 184, 0.16);\n  border-radius: 16px;\n  padding: 12px 18px;\n  color: rgba(226, 232, 240, 0.82);\n  font-size: 1rem;\n  line-height: 1.55;\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);\n}\n\n.mockupSection {\n  padding: 40px 20px 120px;\n}\n\n.sectionVisuallyHidden {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  border: 0;\n}\n\n.mockupContainer {\n  max-width: 1120px;\n  margin: 0 auto;\n  border-radius: 28px;\n  border: 1px solid rgba(148, 163, 184, 0.16);\n  background: linear-gradient(\n    160deg,\n    rgba(17, 19, 33, 0.85),\n    rgba(9, 11, 21, 0.92)\n  );\n  box-shadow: 0 40px 80px rgba(3, 6, 17, 0.65);\n  padding: 24px;\n}\n\n.mockupTopBar {\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  margin-bottom: 18px;\n}\n\n.windowControls {\n  display: inline-flex;\n  gap: 8px;\n}\n\n.windowControls span {\n  display: block;\n  width: 10px;\n  height: 10px;\n  border-radius: 50%;\n}\n\n.windowControls span:nth-child(1) {\n  background: #ff5f56;\n}\n\n.windowControls span:nth-child(2) {\n  background: #ffbd2e;\n}\n\n.windowControls span:nth-child(3) {\n  background: #27c93f;\n}\n\n.addressBar {\n  flex: 1;\n  background: rgba(5, 8, 16, 0.85);\n  border-radius: 12px;\n  padding: 10px 16px;\n  font-size: 0.82rem;\n  color: rgba(226, 232, 240, 0.6);\n  text-align: center;\n}\n\n.mockupBody {\n  display: flex;\n  gap: 24px;\n}\n\n.channelColumn {\n  width: 240px;\n  border-right: 1px solid rgba(148, 163, 184, 0.14);\n  padding-right: 18px;\n  display: flex;\n  flex-direction: column;\n  gap: 18px;\n}\n\n.channelHeader {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  font-weight: 600;\n  color: #0afff1;\n}\n\n.channelMenu {\n  font-size: 1.2rem;\n  color: rgba(226, 232, 240, 0.55);\n}\n\n.channelSearch {\n  padding: 10px 12px;\n  border-radius: 12px;\n  background: rgba(12, 17, 28, 0.9);\n  font-size: 0.85rem;\n  color: rgba(148, 163, 184, 0.6);\n}\n\n.channelList {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  display: grid;\n  gap: 8px;\n}\n\n.channelItem {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  padding: 10px 12px;\n  border-radius: 14px;\n  background: transparent;\n  transition:\n    background 150ms ease,\n    color 150ms ease;\n  cursor: default;\n}\n\n.channelItem:hover {\n  background: rgba(148, 163, 184, 0.08);\n}\n\n.channelItemActive {\n  background: rgba(10, 255, 241, 0.12);\n  border: 1px solid rgba(10, 255, 241, 0.26);\n}\n\n.channelAvatar {\n  width: 32px;\n  height: 32px;\n  border-radius: 12px;\n  background: linear-gradient(140deg, #9772fb, #0afff1);\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 0.75rem;\n  font-weight: 600;\n  color: #05060f;\n}\n\n.channelLabel {\n  font-size: 0.85rem;\n  color: rgba(226, 232, 240, 0.85);\n}\n\n.threadColumn {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  background: rgba(9, 12, 22, 0.72);\n  border-radius: 20px;\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  padding: 20px;\n}\n\n.threadHeader {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding-bottom: 18px;\n  border-bottom: 1px solid rgba(148, 163, 184, 0.12);\n  margin-bottom: 18px;\n}\n\n.threadTitle {\n  font-size: 1.05rem;\n  font-weight: 600;\n}\n\n.threadStatus {\n  font-size: 0.8rem;\n  color: #0afff1;\n  margin-top: 4px;\n}\n\n.threadActions {\n  display: inline-flex;\n  gap: 12px;\n}\n\n.threadActions span {\n  width: 26px;\n  height: 26px;\n  border-radius: 10px;\n  background: rgba(148, 163, 184, 0.12);\n}\n\n.threadMessages {\n  flex: 1;\n  display: grid;\n  gap: 14px;\n  padding-right: 6px;\n}\n\n.messageRow {\n  display: flex;\n  justify-content: flex-start;\n}\n\n.messageRowOwn {\n  justify-content: flex-end;\n}\n\n.messageBubble {\n  max-width: 70%;\n  padding: 12px 16px;\n  border-radius: 14px;\n  background: rgba(148, 163, 184, 0.14);\n  font-size: 0.92rem;\n  line-height: 1.45;\n  color: rgba(226, 232, 240, 0.9);\n}\n\n.messageRowOwn .messageBubble {\n  background: rgba(10, 255, 241, 0.16);\n  color: #c8fff9;\n}\n\n.threadComposer {\n  margin-top: 18px;\n  border-radius: 14px;\n  padding: 12px 16px;\n  background: rgba(12, 17, 28, 0.85);\n  color: rgba(148, 163, 184, 0.6);\n  font-size: 0.85rem;\n}\n\n.powered,\n.features,\n.roadmap,\n.tokenomics,\n.faqs,\n.cta {\n  padding: 120px 20px;\n  max-width: 1120px;\n  margin: 0 auto;\n}\n\n.sectionHeading {\n  text-align: center;\n  margin-bottom: 56px;\n  max-width: 780px;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.sectionEyebrow {\n  display: inline-flex;\n  padding: 8px 16px;\n  border-radius: 999px;\n  background: rgba(10, 255, 241, 0.12);\n  border: 1px solid rgba(10, 255, 241, 0.2);\n  color: #0afff1;\n  font-size: 0.82rem;\n  letter-spacing: 0.05em;\n  text-transform: uppercase;\n  margin-bottom: 18px;\n}\n\n.sectionHeading h2 {\n  font-size: clamp(2rem, 4vw, 2.9rem);\n  margin-bottom: 16px;\n  font-weight: 700;\n}\n\n.sectionHeading p {\n  color: rgba(226, 232, 240, 0.72);\n  line-height: 1.7;\n  font-size: 1.05rem;\n}\n\n.poweredGrid {\n  display: grid;\n  gap: 24px;\n  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));\n}\n\n.poweredCard {\n  background: rgba(15, 18, 30, 0.75);\n  border: 1px solid rgba(148, 163, 184, 0.14);\n  border-radius: 22px;\n  padding: 26px;\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);\n}\n\n.poweredCard h3 {\n  font-size: 1.12rem;\n  margin-bottom: 12px;\n}\n\n.poweredCard p {\n  color: rgba(203, 213, 225, 0.75);\n  line-height: 1.6;\n  font-size: 0.96rem;\n}\n\n.featureGrid {\n  display: grid;\n  gap: 24px;\n  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));\n}\n\n.featureCard {\n  padding: 28px;\n  border-radius: 22px;\n  background: rgba(12, 17, 28, 0.82);\n  border: 1px solid rgba(10, 255, 241, 0.12);\n  transition:\n    transform 160ms ease,\n    border-color 160ms ease;\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);\n}\n\n.featureCard:hover {\n  transform: translateY(-6px);\n  border-color: rgba(10, 255, 241, 0.28);\n}\n\n.featureCard h3 {\n  font-size: 1.2rem;\n  margin-bottom: 12px;\n}\n\n.featureCard p {\n  color: rgba(203, 213, 225, 0.78);\n  line-height: 1.6;\n  font-size: 0.96rem;\n}\n\n.roadmapTimeline {\n  display: grid;\n  gap: 24px;\n  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));\n}\n\n.roadmapItem {\n  padding: 30px;\n  border-radius: 24px;\n  background: rgba(12, 17, 28, 0.78);\n  border: 1px solid rgba(148, 163, 184, 0.14);\n  position: relative;\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);\n}\n\n.roadmapBadge {\n  display: inline-flex;\n  align-items: center;\n  padding: 6px 14px;\n  border-radius: 999px;\n  background: rgba(151, 114, 251, 0.18);\n  border: 1px solid rgba(151, 114, 251, 0.3);\n  color: #cbb6ff;\n  font-size: 0.8rem;\n  margin-bottom: 18px;\n}\n\n.roadmapItem h3 {\n  font-size: 1.12rem;\n  margin-bottom: 12px;\n}\n\n.roadmapItem p {\n  color: rgba(203, 213, 225, 0.72);\n  line-height: 1.6;\n  margin-bottom: 18px;\n  font-size: 0.95rem;\n}\n\n.roadmapStatus {\n  font-size: 0.9rem;\n  color: rgba(148, 255, 231, 0.85);\n}\n\n.tokenomicGrid {\n  display: grid;\n  gap: 24px;\n  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));\n}\n\n.tokenomicCard {\n  padding: 28px;\n  border-radius: 24px;\n  border: 1px solid rgba(10, 255, 241, 0.16);\n  background: rgba(9, 14, 25, 0.9);\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);\n}\n\n.tokenomicPercent {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  padding: 10px 18px;\n  border-radius: 999px;\n  background: rgba(10, 255, 241, 0.12);\n  color: #0afff1;\n  font-weight: 700;\n  margin-bottom: 16px;\n}\n\n.tokenomicCard h3 {\n  font-size: 1.1rem;\n  margin-bottom: 12px;\n}\n\n.tokenomicCard p {\n  color: rgba(203, 213, 225, 0.75);\n  line-height: 1.6;\n  font-size: 0.95rem;\n}\n\n.faqList {\n  display: grid;\n  gap: 18px;\n  max-width: 820px;\n  margin: 0 auto;\n}\n\n.faqItem {\n  background: rgba(12, 17, 28, 0.82);\n  border: 1px solid rgba(148, 163, 184, 0.16);\n  border-radius: 18px;\n  padding: 22px 26px;\n}\n\n.faqItem h3 {\n  font-size: 1.05rem;\n  margin-bottom: 10px;\n}\n\n.faqItem p {\n  color: rgba(203, 213, 225, 0.78);\n  line-height: 1.65;\n  font-size: 0.96rem;\n}\n\n.cta {\n  text-align: center;\n  border-radius: 28px;\n  padding: 64px 20px;\n  background: linear-gradient(\n    135deg,\n    rgba(10, 255, 241, 0.16),\n    rgba(151, 114, 251, 0.22)\n  );\n  border: 1px solid rgba(10, 255, 241, 0.28);\n  box-shadow: 0 32px 60px rgba(7, 11, 24, 0.6);\n}\n\n.cta h2 {\n  font-size: clamp(2rem, 3.5vw, 2.6rem);\n  margin-bottom: 20px;\n}\n\n.cta p {\n  color: rgba(7, 10, 18, 0.82);\n  font-weight: 500;\n  font-size: 1.05rem;\n  margin-bottom: 28px;\n}\n\n.ctaActions {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 16px;\n  justify-content: center;\n}\n\n.footer {\n  padding: 80px 20px 40px;\n  border-top: 1px solid rgba(148, 163, 184, 0.16);\n  background: rgba(7, 10, 18, 0.5);\n}\n\n.footerBrand {\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  margin-bottom: 32px;\n}\n\n.footerCopy {\n  color: rgba(226, 232, 240, 0.72);\n  margin-top: 4px;\n  font-size: 0.95rem;\n}\n\n.footerLinks {\n  display: grid;\n  gap: 24px;\n  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));\n  margin-bottom: 36px;\n}\n\n.footerLinks h3 {\n  font-size: 1rem;\n  margin-bottom: 14px;\n}\n\n.footerLinks a {\n  display: block;\n  font-size: 0.92rem;\n  color: rgba(226, 232, 240, 0.72);\n  text-decoration: none;\n  margin-bottom: 10px;\n  transition: color 150ms ease;\n}\n\n.footerLinks a:hover {\n  color: #0afff1;\n}\n\n.footerMeta {\n  border-top: 1px solid rgba(148, 163, 184, 0.16);\n  padding-top: 24px;\n  display: flex;\n  flex-wrap: wrap;\n  align-items: center;\n  justify-content: space-between;\n  gap: 16px;\n  font-size: 0.85rem;\n  color: rgba(148, 163, 184, 0.7);\n}\n\n.footerMeta div {\n  display: flex;\n  gap: 18px;\n}\n\n.footerMeta a {\n  color: inherit;\n  text-decoration: none;\n  transition: color 150ms ease;\n}\n\n.footerMeta a:hover {\n  color: #0afff1;\n}\n\n@media (max-width: 960px) {\n  .navLinks {\n    display: none;\n  }\n\n  .menuButton {\n    display: inline-flex;\n  }\n\n  .navActions {\n    gap: 12px;\n  }\n\n  .primaryButton {\n    padding: 12px 20px;\n  }\n\n  .mockupBody {\n    flex-direction: column;\n  }\n\n  .channelColumn {\n    width: 100%;\n    border-right: 0;\n    padding-right: 0;\n    border-bottom: 1px solid rgba(148, 163, 184, 0.14);\n    padding-bottom: 20px;\n  }\n}\n\n@media (max-width: 768px) {\n  .navContainer {\n    padding: 16px 16px;\n  }\n\n  .content {\n    padding-top: 120px;\n  }\n\n  .hero {\n    padding: 140px 16px 88px;\n  }\n\n  .heroCopy {\n    font-size: 1.05rem;\n  }\n\n  .mockupContainer {\n    padding: 18px;\n  }\n\n  .powered,\n  .features,\n  .roadmap,\n  .tokenomics,\n  .faqs,\n  .cta {\n    padding: 90px 16px;\n  }\n\n  .cta {\n    padding: 56px 24px;\n  }\n\n  .footer {\n    padding: 64px 16px 36px;\n  }\n\n  .footerMeta {\n    flex-direction: column;\n    align-items: flex-start;\n  }\n}\n\n@media (max-width: 640px) {\n  .hero {\n    padding: 120px 14px 72px;\n  }\n\n  .heroBadge {\n    font-size: 0.8rem;\n    padding: 8px 16px;\n  }\n\n  .heroTitle {\n    font-size: clamp(2.2rem, 9vw, 3.2rem);\n  }\n\n  .heroCopy {\n    font-size: 0.98rem;\n    line-height: 1.6;\n  }\n\n  .heroList {\n    gap: 10px;\n    margin-bottom: 28px;\n  }\n\n  .heroList li {\n    font-size: 0.95rem;\n    padding: 12px 14px;\n  }\n\n  .heroActions {\n    flex-direction: column;\n    width: 100%;\n  }\n\n  .primaryButton,\n  .secondaryButton {\n    width: 100%;\n  }\n\n  .mockupContainer {\n    padding: 16px;\n    border-radius: 22px;\n  }\n\n  .mockupBody {\n    gap: 16px;\n  }\n\n  .threadColumn {\n    padding: 16px;\n  }\n\n  .sectionHeading {\n    text-align: left;\n  }\n\n  .sectionHeading h2 {\n    font-size: 1.85rem;\n  }\n\n  .sectionHeading p {\n    font-size: 0.98rem;\n  }\n\n  .featureCard,\n  .roadmapItem,\n  .tokenomicCard,\n  .faqItem {\n    padding: 22px 18px;\n  }\n\n  .footerBrand {\n    flex-direction: column;\n    align-items: flex-start;\n    gap: 12px;\n  }\n}\n\n@media (max-width: 480px) {\n  .navContainer {\n    padding: 14px;\n  }\n\n  .brandLabel {\n    font-size: 1rem;\n  }\n\n  .hero {\n    padding: 108px 14px 60px;\n  }\n\n  .heroTitle {\n    font-size: clamp(1.9rem, 10vw, 2.4rem);\n  }\n\n  .heroCopy {\n    font-size: 0.94rem;\n  }\n\n  .mockupContainer {\n    padding: 14px;\n  }\n\n  .channelHeader,\n  .threadHeader {\n    flex-direction: column;\n    align-items: flex-start;\n    gap: 8px;\n  }\n\n  .threadMessages {\n    gap: 10px;\n  }\n\n  .messageBubble {\n    font-size: 0.92rem;\n  }\n\n  .sectionHeading h2 {\n    font-size: 1.65rem;\n  }\n\n  .sectionHeading p {\n    font-size: 0.94rem;\n  }\n\n  .cta h2 {\n    font-size: 1.8rem;\n  }\n\n  .cta p {\n    font-size: 0.98rem;\n  }\n\n  .footerBrand {\n    align-items: center;\n    text-align: center;\n  }\n\n  .footerBrand .footerCopy {\n    text-align: center;\n  }\n\n  .footerMeta {\n    font-size: 0.82rem;\n    align-items: flex-start;\n  }\n\n  .footerMeta div {\n    flex-wrap: wrap;\n    gap: 12px;\n  }\n}\n",
      "size_bytes": 18752
    },
    "sdks/node-sdk/README.md": {
      "content": "# XMTP client SDK for Node\n\nThis package provides the XMTP client SDK for Node.\n\nTo keep up with the latest SDK developments, see the [Issues tab](https://github.com/xmtp/xmtp-js/issues) in this repo.\n\n> [!CAUTION]\n> This SDK is in beta status and ready for you to build with in production. Software in this status may change based on feedback.\n\n## Documentation\n\nTo learn how to use the XMTP client SDK for Node, see [Get started with the XMTP Node SDK](https://docs.xmtp.org/sdks/node).\n\n## Requirements\n\n- Node.js 20+\n- `glibc` 3.28+ (i.e. Ubuntu 24.04 or later)\n\n## Install\n\n**NPM**\n\n```bash\nnpm install @xmtp/node-sdk\n```\n\n**PNPM**\n\n```bash\npnpm install @xmtp/node-sdk\n```\n\n**Yarn**\n\n```bash\nyarn add @xmtp/node-sdk\n```\n\n## Developing\n\nRun `yarn dev` to build the SDK and watch for changes, which will trigger a rebuild.\n\n## Testing\n\nFor testing setup instructions, see our [testing guidelines](https://github.com/xmtp/xmtp-js/blob/main/CONTRIBUTING.md#testing) in the main repository.\n\n### Useful commands\n\n- `yarn build`: Builds the SDK\n- `yarn clean`: Removes `node_modules`, `dist`, and `.turbo` folders\n- `yarn test`: Runs all tests\n- `yarn typecheck`: Runs `tsc`\n\n## Breaking revisions\n\nBecause this SDK is in active development, you should expect breaking revisions that might require you to adopt the latest SDK release to enable your app to continue working as expected.\n\nBreaking revisions in a Node SDK release are described on the [Releases page](https://github.com/xmtp/xmtp-js/releases).\n\n## Deprecation\n\nOlder versions of the SDK will eventually be deprecated, which means:\n\n1. The network will not support and eventually actively reject connections from clients using deprecated versions.\n2. Bugs will not be fixed in deprecated versions.\n\nThe following table provides the deprecation schedule.\n\n| Announced                   | Effective   | Minimum Version | Rationale                                                                                                                                                                                                                                                                                                                                                                                                                |\n| --------------------------- | ----------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| No more support for XMTP V2 | May 1, 2025 | >=1.0.5         | In a move toward better security with MLS and the ability to decentralize, we will be shutting down XMTP V2 and moving entirely to XMTP V3. To learn more about V2 deprecation, see [XIP-53: XMTP V2 deprecation plan](https://community.xmtp.org/t/xip-53-xmtp-v2-deprecation-plan/867). To learn how to upgrade, see [@xmtp/node-sdk v1.0.5](https://github.com/xmtp/xmtp-js/releases/tag/%40xmtp%2Fnode-sdk%401.0.5). |\n\nBug reports, feature requests, and PRs are welcome in accordance with these [contribution guidelines](https://github.com/xmtp/xmtp-js/blob/main/CONTRIBUTING.md).\n",
      "size_bytes": 3415
    },
    "content-types/content-type-remote-attachment/src/RemoteAttachment.test.ts": {
      "content": "import { Client, IdentifierKind, type Signer } from \"@xmtp/node-sdk\";\nimport { createWalletClient, http, toBytes } from \"viem\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { sepolia } from \"viem/chains\";\nimport { AttachmentCodec, type Attachment } from \"./Attachment\";\nimport {\n  ContentTypeRemoteAttachment,\n  RemoteAttachmentCodec,\n  type RemoteAttachment,\n} from \"./RemoteAttachment\";\n\nexport const createSigner = (): Signer => {\n  const account = privateKeyToAccount(generatePrivateKey());\n  const wallet = createWalletClient({\n    account,\n    chain: sepolia,\n    transport: http(),\n  });\n  return {\n    type: \"EOA\",\n    getIdentifier: () => ({\n      identifierKind: IdentifierKind.Ethereum,\n      identifier: account.address.toLowerCase(),\n    }),\n    signMessage: async (message: string) => {\n      const signature = await wallet.signMessage({\n        message,\n      });\n      return toBytes(signature);\n    },\n  };\n};\n\ntest(\"content type exists\", () => {\n  expect(ContentTypeRemoteAttachment.authorityId).toBe(\"xmtp.org\");\n  expect(ContentTypeRemoteAttachment.typeId).toBe(\"remoteStaticAttachment\");\n  expect(ContentTypeRemoteAttachment.versionMajor).toBe(1);\n  expect(ContentTypeRemoteAttachment.versionMinor).toBe(0);\n});\n\ntest(\"can create a remote attachment\", async () => {\n  const signer1 = createSigner();\n  const client1 = await Client.create(signer1, {\n    codecs: [new AttachmentCodec(), new RemoteAttachmentCodec()],\n    env: \"local\",\n  });\n\n  const signer2 = createSigner();\n  const client2 = await Client.create(signer2, {\n    codecs: [new AttachmentCodec(), new RemoteAttachmentCodec()],\n    env: \"local\",\n  });\n\n  const dm = await client1.conversations.newDm(client2.inboxId);\n\n  const attachment: Attachment = {\n    filename: \"test.txt\",\n    mimeType: \"text/plain\",\n    data: new TextEncoder().encode(\"hello world\"),\n  };\n  const encryptedEncodedContent = await RemoteAttachmentCodec.encodeEncrypted(\n    attachment,\n    new AttachmentCodec(),\n  );\n\n  try {\n    await fetch(\"https://localhost:3000/test\", {\n      method: \"POST\",\n      body: encryptedEncodedContent.payload as Uint8Array<ArrayBuffer>,\n      headers: {\n        \"Content-Type\": \"application/octet-stream\",\n      },\n    });\n  } catch (e) {\n    console.error(\"error fetch\", e);\n  }\n\n  const remoteAttachment: RemoteAttachment = {\n    url: \"https://localhost:3000/test\",\n    contentDigest: encryptedEncodedContent.digest,\n    salt: encryptedEncodedContent.salt,\n    nonce: encryptedEncodedContent.nonce,\n    secret: encryptedEncodedContent.secret,\n    scheme: \"https\",\n    contentLength: encryptedEncodedContent.payload.length,\n    filename: \"test.txt\",\n  };\n\n  await dm.send(remoteAttachment, ContentTypeRemoteAttachment);\n\n  await client2.conversations.sync();\n  const dms = client2.conversations.listDms();\n\n  expect(dms.length).toBe(1);\n\n  await dms[0].sync();\n  const messages = await dms[0].messages();\n  expect(messages.length).toBe(2);\n\n  const message = messages[1];\n  const messageContent = message.content as RemoteAttachment;\n  expect(messageContent.url).toBe(\"https://localhost:3000/test\");\n  expect(messageContent.filename).toBe(\"test.txt\");\n  expect(messageContent.contentDigest).toBe(encryptedEncodedContent.digest);\n\n  const content = await RemoteAttachmentCodec.load<Attachment>(\n    messageContent,\n    client2,\n  );\n  expect(content.filename).toBe(\"test.txt\");\n  expect(content.mimeType).toBe(\"text/plain\");\n  expect(content.data).toStrictEqual(new TextEncoder().encode(\"hello world\"));\n});\n\ntest(\"fails if url is not https\", async () => {\n  const signer1 = createSigner();\n  const client1 = await Client.create(signer1, {\n    codecs: [new AttachmentCodec(), new RemoteAttachmentCodec()],\n    env: \"local\",\n  });\n\n  const signer2 = createSigner();\n  const client2 = await Client.create(signer2, {\n    codecs: [new AttachmentCodec(), new RemoteAttachmentCodec()],\n    env: \"local\",\n  });\n\n  const dm = await client1.conversations.newDm(client2.inboxId);\n\n  const attachment: Attachment = {\n    filename: \"test.txt\",\n    mimeType: \"text/plain\",\n    data: new TextEncoder().encode(\"hello world\"),\n  };\n  const encryptedEncodedContent = await RemoteAttachmentCodec.encodeEncrypted(\n    attachment,\n    new AttachmentCodec(),\n  );\n\n  const remoteAttachment: RemoteAttachment = {\n    url: \"http://localhost/test\", // We didn't upload this, but it doesn't matter\n    contentDigest: encryptedEncodedContent.digest,\n    salt: encryptedEncodedContent.salt,\n    nonce: encryptedEncodedContent.nonce,\n    secret: encryptedEncodedContent.secret,\n    scheme: \"https\",\n    contentLength: encryptedEncodedContent.payload.length,\n    filename: \"test.txt\",\n  };\n\n  await expect(\n    dm.send(remoteAttachment, ContentTypeRemoteAttachment),\n  ).rejects.toThrow(\"scheme must be https\");\n});\n\ntest(\"fails if content digest does not match\", async () => {\n  const signer1 = createSigner();\n  const client1 = await Client.create(signer1, {\n    codecs: [new AttachmentCodec(), new RemoteAttachmentCodec()],\n    env: \"local\",\n  });\n\n  const signer2 = createSigner();\n  const client2 = await Client.create(signer2, {\n    codecs: [new AttachmentCodec(), new RemoteAttachmentCodec()],\n    env: \"local\",\n  });\n\n  const dm = await client1.conversations.newDm(client2.inboxId);\n\n  const attachment: Attachment = {\n    filename: \"test.txt\",\n    mimeType: \"text/plain\",\n    data: new TextEncoder().encode(\"hello world\"),\n  };\n  const encryptedEncodedContent = await RemoteAttachmentCodec.encodeEncrypted(\n    attachment,\n    new AttachmentCodec(),\n  );\n\n  try {\n    await fetch(\"https://localhost:3000/test\", {\n      method: \"POST\",\n      body: encryptedEncodedContent.payload as Uint8Array<ArrayBuffer>,\n      headers: {\n        \"Content-Type\": \"application/octet-stream\",\n      },\n    });\n  } catch (e) {\n    console.error(\"error fetch\", e);\n  }\n\n  const remoteAttachment: RemoteAttachment = {\n    url: \"https://localhost:3000/test\",\n    contentDigest: encryptedEncodedContent.digest,\n    salt: encryptedEncodedContent.salt,\n    nonce: encryptedEncodedContent.nonce,\n    secret: encryptedEncodedContent.secret,\n    scheme: \"https\",\n    contentLength: encryptedEncodedContent.payload.length,\n    filename: \"test.txt\",\n  };\n\n  await dm.send(remoteAttachment, ContentTypeRemoteAttachment);\n\n  await client2.conversations.sync();\n  const dms = client2.conversations.listDms();\n\n  expect(dms.length).toBe(1);\n\n  await dms[0].sync();\n  const messages = await dms[0].messages();\n  expect(messages.length).toBe(2);\n\n  const message = messages[1];\n\n  const encryptedEncoded2 = await RemoteAttachmentCodec.encodeEncrypted(\n    attachment,\n    new AttachmentCodec(),\n  );\n  await fetch(\"https://localhost:3000/test\", {\n    method: \"POST\",\n    body: encryptedEncoded2.payload as Uint8Array<ArrayBuffer>,\n    headers: {\n      \"Content-Type\": \"application/octet-stream\",\n    },\n  });\n\n  await expect(\n    RemoteAttachmentCodec.load(message.content as RemoteAttachment, client2),\n  ).rejects.toThrow(\"content digest does not match\");\n});\n\ntest(\"has a proper shouldPush value\", () => {\n  const codec = new RemoteAttachmentCodec();\n  expect(codec.shouldPush()).toBe(true);\n});\n",
      "size_bytes": 7167
    },
    "apps/xmtp.chat-api-service/prisma/migrations/migration_lock.toml": {
      "content": "# Please do not edit this file manually\n# It should be added in your version-control system (e.g., Git)\nprovider = \"postgresql\"\n",
      "size_bytes": 128
    },
    "apps/xmtp.chat/src/hooks/useSettings.ts": {
      "content": "import { useLocalStorage } from \"@mantine/hooks\";\nimport { type ClientOptions, type XmtpEnv } from \"@xmtp/browser-sdk\";\nimport type { Hex } from \"viem\";\nimport type { ConnectorString } from \"@/hooks/useConnectWallet\";\n\nexport const useSettings = () => {\n  const [environment, setEnvironment] = useLocalStorage<XmtpEnv>({\n    key: \"XMTP_NETWORK\",\n    defaultValue: \"dev\",\n    getInitialValueInEffect: false,\n  });\n  const [ephemeralAccountKey, setEphemeralAccountKey] =\n    useLocalStorage<Hex | null>({\n      key: \"XMTP_EPHEMERAL_ACCOUNT_KEY\",\n      defaultValue: null,\n      getInitialValueInEffect: false,\n    });\n  const [encryptionKey, setEncryptionKey] = useLocalStorage({\n    key: \"XMTP_ENCRYPTION_KEY\",\n    defaultValue: \"\",\n    getInitialValueInEffect: false,\n  });\n  const [ephemeralAccountEnabled, setEphemeralAccountEnabled] = useLocalStorage(\n    {\n      key: \"XMTP_USE_EPHEMERAL_ACCOUNT\",\n      defaultValue: false,\n      getInitialValueInEffect: false,\n    },\n  );\n  const [loggingLevel, setLoggingLevel] = useLocalStorage<\n    ClientOptions[\"loggingLevel\"]\n  >({\n    key: \"XMTP_LOGGING_LEVEL\",\n    defaultValue: \"warn\",\n    getInitialValueInEffect: false,\n  });\n  const [forceSCW, setForceSCW] = useLocalStorage<boolean>({\n    key: \"XMTP_FORCE_SCW\",\n    defaultValue: false,\n    getInitialValueInEffect: false,\n  });\n  const [useSCW, setUseSCW] = useLocalStorage<boolean>({\n    key: \"XMTP_USE_SCW\",\n    defaultValue: false,\n    getInitialValueInEffect: false,\n  });\n  const [blockchain, setBlockchain] = useLocalStorage<number>({\n    key: \"XMTP_BLOCKCHAIN\",\n    defaultValue: 1,\n    getInitialValueInEffect: false,\n  });\n  const [connector, setConnector] = useLocalStorage<ConnectorString>({\n    key: \"XMTP_CONNECTOR\",\n    defaultValue: \"Injected\",\n    getInitialValueInEffect: false,\n  });\n  const [autoConnect, setAutoConnect] = useLocalStorage<boolean>({\n    key: \"XMTP_AUTO_CONNECT\",\n    defaultValue: false,\n    getInitialValueInEffect: false,\n  });\n\n  return {\n    autoConnect,\n    blockchain,\n    connector,\n    encryptionKey,\n    environment,\n    ephemeralAccountEnabled,\n    ephemeralAccountKey,\n    forceSCW,\n    loggingLevel,\n    useSCW,\n    setAutoConnect,\n    setBlockchain,\n    setConnector,\n    setEncryptionKey,\n    setEnvironment,\n    setEphemeralAccountEnabled,\n    setEphemeralAccountKey,\n    setForceSCW,\n    setLoggingLevel,\n    setUseSCW,\n  };\n};\n",
      "size_bytes": 2384
    },
    "apps/xmtp.chat/src/components/App/UseSCW.tsx": {
      "content": "import { Group, Switch, Text, Tooltip } from \"@mantine/core\";\nimport React from \"react\";\nimport { useConnectWallet } from \"@/hooks/useConnectWallet\";\nimport { useSettings } from \"@/hooks/useSettings\";\n\nexport const UseSCW: React.FC = () => {\n  const { isConnected } = useConnectWallet();\n  const { useSCW, setUseSCW, ephemeralAccountEnabled, connector } =\n    useSettings();\n\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setUseSCW(event.currentTarget.checked);\n  };\n\n  return (\n    <Group gap=\"sm\" align=\"center\" wrap=\"nowrap\">\n      <Text size=\"sm\" fw=\"bold\" style={{ display: \"none\" }}>\n        Smart contract wallet\n      </Text>\n      <Tooltip\n        label=\"Enable this option if you're connecting with a smart contract wallet\"\n        refProp=\"rootRef\">\n        <Switch\n          size=\"md\"\n          disabled={\n            ephemeralAccountEnabled || connector === \"MetaMask\" || isConnected\n          }\n          checked={useSCW}\n          onChange={handleChange}\n          withThumbIndicator={false}\n        />\n      </Tooltip>\n    </Group>\n  );\n};\n",
      "size_bytes": 1087
    },
    "sdks/browser-sdk/src/types/actions/debugInformation.ts": {
      "content": "import type { SafeApiStats, SafeIdentityStats } from \"@/utils/conversions\";\n\nexport type DebugInformationAction =\n  | {\n      action: \"debugInformation.apiStatistics\";\n      id: string;\n      result: SafeApiStats;\n      data: undefined;\n    }\n  | {\n      action: \"debugInformation.apiIdentityStatistics\";\n      id: string;\n      result: SafeIdentityStats;\n      data: undefined;\n    }\n  | {\n      action: \"debugInformation.apiAggregateStatistics\";\n      id: string;\n      result: string;\n      data: undefined;\n    }\n  | {\n      action: \"debugInformation.clearAllStatistics\";\n      id: string;\n      result: undefined;\n      data: undefined;\n    }\n  | {\n      action: \"debugInformation.uploadDebugArchive\";\n      id: string;\n      result: string;\n      data: {\n        serverUrl?: string;\n      };\n    };\n",
      "size_bytes": 805
    },
    "content-types/content-type-reply/src/index.ts": {
      "content": "export * from \"./Reply\";\n",
      "size_bytes": 25
    },
    "sdks/browser-sdk/src/types/actions/streams.ts": {
      "content": "import type { UserPreference } from \"@xmtp/wasm-bindings\";\nimport type {\n  SafeConsent,\n  SafeConversation,\n  SafeMessage,\n} from \"@/utils/conversions\";\n\nexport type StreamAction =\n  | {\n      action: \"stream.message\";\n      streamId: string;\n      result: SafeMessage | undefined;\n    }\n  | {\n      action: \"stream.conversation\";\n      streamId: string;\n      result: SafeConversation | undefined;\n    }\n  | {\n      action: \"stream.consent\";\n      streamId: string;\n      result: SafeConsent[] | undefined;\n    }\n  | {\n      action: \"stream.preferences\";\n      streamId: string;\n      result: UserPreference[] | undefined;\n    }\n  | {\n      action: \"stream.fail\";\n      streamId: string;\n      result: undefined;\n    };\n\nexport type StreamActionName = StreamAction[\"action\"];\n\nexport type ExtractStreamAction<A extends StreamActionName> = Extract<\n  StreamAction,\n  { action: A }\n>;\n\nexport type StreamActionResult<A extends StreamActionName> =\n  ExtractStreamAction<A>[\"result\"];\n\nexport type StreamActionErrorData = {\n  action: StreamActionName;\n  error: Error;\n  streamId: string;\n};\n",
      "size_bytes": 1088
    },
    "sdks/browser-sdk/test/Preferences.test.ts": {
      "content": "import { ConsentEntityType, ConsentState } from \"@xmtp/wasm-bindings\";\nimport { v4 } from \"uuid\";\nimport { describe, expect, it } from \"vitest\";\nimport {\n  createClient,\n  createRegisteredClient,\n  createSigner,\n  createUser,\n  sleep,\n} from \"@test/helpers\";\n\ndescribe(\"Preferences\", () => {\n  it(\"should return the correct inbox state\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const inboxState = await client.preferences.inboxState(false);\n    expect(inboxState.inboxId).toBe(client.inboxId);\n    expect(inboxState.installations.map((install) => install.id)).toEqual([\n      client.installationId,\n    ]);\n    expect(inboxState.identifiers).toEqual([await signer.getIdentifier()]);\n    expect(inboxState.recoveryIdentifier).toEqual(await signer.getIdentifier());\n\n    const user2 = createUser();\n    const signer2 = createSigner(user2);\n    const client2 = await createClient(signer2);\n    const inboxState2 = await client2.preferences.getLatestInboxState(\n      client.inboxId!,\n    );\n    expect(inboxState2.inboxId).toBe(client.inboxId);\n    expect(inboxState.installations.length).toBe(1);\n    expect(inboxState.installations[0].id).toBe(client.installationId);\n    expect(inboxState.installations[0].bytes).toEqual(\n      client.installationIdBytes,\n    );\n    expect(inboxState2.identifiers).toEqual([await signer.getIdentifier()]);\n    expect(inboxState2.recoveryIdentifier).toEqual(\n      await signer.getIdentifier(),\n    );\n  });\n\n  it(\"should get inbox state from inbox ids\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const inboxState = await client1.preferences.inboxStateFromInboxIds(\n      [client1.inboxId!, client2.inboxId!],\n      true,\n    );\n    expect(inboxState.length).toBe(2);\n    const inboxIds = inboxState.map((state) => state.inboxId);\n    expect(inboxIds).toContain(client1.inboxId!);\n    expect(inboxIds).toContain(client2.inboxId!);\n  });\n\n  it(\"should manage consent states\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const group = await client1.conversations.newGroup([client2.inboxId!]);\n\n    await client2.conversations.sync();\n    const group2 = await client2.conversations.getConversationById(group.id);\n\n    expect(group2).not.toBeNull();\n\n    expect(\n      await client2.preferences.getConsentState(\n        ConsentEntityType.GroupId,\n        group2!.id,\n      ),\n    ).toBe(ConsentState.Unknown);\n\n    await client2.preferences.setConsentStates([\n      {\n        entityType: ConsentEntityType.GroupId,\n        entity: group2!.id,\n        state: ConsentState.Allowed,\n      },\n    ]);\n\n    expect(\n      await client2.preferences.getConsentState(\n        ConsentEntityType.GroupId,\n        group2!.id,\n      ),\n    ).toBe(ConsentState.Allowed);\n\n    expect(await group2!.consentState()).toBe(ConsentState.Allowed);\n\n    await group2!.updateConsentState(ConsentState.Denied);\n\n    expect(\n      await client2.preferences.getConsentState(\n        ConsentEntityType.GroupId,\n        group2!.id,\n      ),\n    ).toBe(ConsentState.Denied);\n  });\n\n  describe(\"Streaming\", () => {\n    it(\"should stream consent updates\", async () => {\n      const user = createUser();\n      const user2 = createUser();\n      const signer1 = createSigner(user);\n      const signer2 = createSigner(user2);\n      const client = await createRegisteredClient(signer1);\n      const client2 = await createRegisteredClient(signer2);\n      const group = await client.conversations.newGroup([client2.inboxId!]);\n      const stream = await client.preferences.streamConsent();\n\n      await group.updateConsentState(ConsentState.Denied);\n\n      await sleep(1000);\n\n      await client.preferences.setConsentStates([\n        {\n          entity: group.id,\n          entityType: ConsentEntityType.GroupId,\n          state: ConsentState.Allowed,\n        },\n      ]);\n\n      await sleep(1000);\n      await client.preferences.setConsentStates([\n        {\n          entity: group.id,\n          entityType: ConsentEntityType.GroupId,\n          state: ConsentState.Denied,\n        },\n        {\n          entity: client2.inboxId!,\n          entityType: ConsentEntityType.InboxId,\n          state: ConsentState.Allowed,\n        },\n      ]);\n\n      setTimeout(() => {\n        void stream.end();\n      }, 2000);\n\n      let count = 0;\n      for await (const updates of stream) {\n        count++;\n        if (count === 1) {\n          expect(updates.length).toBe(1);\n          expect(updates[0].entity).toBe(group.id);\n          expect(updates[0].entityType).toBe(ConsentEntityType.GroupId);\n          expect(updates[0].state).toBe(ConsentState.Denied);\n        }\n        if (count === 2) {\n          expect(updates.length).toBe(1);\n          expect(updates[0].entity).toBe(group.id);\n          expect(updates[0].entityType).toBe(ConsentEntityType.GroupId);\n          expect(updates[0].state).toBe(ConsentState.Allowed);\n        }\n        if (count === 3) {\n          expect(updates.length).toBe(2);\n          expect(updates[0].entity).toBe(group.id);\n          expect(updates[0].entityType).toBe(ConsentEntityType.GroupId);\n          expect(updates[0].state).toBe(ConsentState.Denied);\n          expect(updates[1].entity).toBe(client2.inboxId!);\n          expect(updates[1].entityType).toBe(ConsentEntityType.InboxId);\n          expect(updates[1].state).toBe(ConsentState.Allowed);\n        }\n      }\n      expect(count).toBe(3);\n    });\n\n    it(\"should stream preferences\", async () => {\n      const user = createUser();\n      const signer = createSigner(user);\n      const client = await createRegisteredClient(signer);\n      const stream = await client.preferences.streamPreferences();\n\n      await sleep(2000);\n\n      const client2 = await createRegisteredClient(signer, {\n        dbPath: `./test-${v4()}.db3`,\n      });\n      const client3 = await createRegisteredClient(signer, {\n        dbPath: `./test-${v4()}.db3`,\n      });\n\n      await client3.conversations.syncAll();\n      await sleep(2000);\n      await client.conversations.syncAll();\n      await sleep(2000);\n      await client2.conversations.syncAll();\n      await sleep(2000);\n\n      setTimeout(() => {\n        void stream.end();\n      }, 2000);\n\n      let count = 0;\n      for await (const preferences of stream) {\n        count++;\n        expect(preferences).toBeDefined();\n        expect(preferences.length).toBe(1);\n        if (preferences[0].type === \"HmacKeyUpdate\") {\n          expect(preferences[0].key).toBeDefined();\n        }\n      }\n      expect(count).toBe(2);\n    });\n  });\n});\n",
      "size_bytes": 7028
    },
    "sdks/agent-sdk/src/core/AgentError.ts": {
      "content": "export class AgentError extends Error {\n  #code: number;\n\n  constructor(code: number, message: string, cause?: unknown) {\n    super(message, { cause });\n    this.#code = code;\n  }\n\n  get code() {\n    return this.#code;\n  }\n}\n",
      "size_bytes": 225
    },
    "apps/xmtp.chat/src/main.tsx": {
      "content": "import \"@mantine/core/styles.css\";\nimport \"./tailwind.css\";\nimport { createTheme, MantineProvider } from \"@mantine/core\";\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport pkg from \"@xmtp/browser-sdk/package.json\";\nimport { createRoot } from \"react-dom/client\";\nimport { BrowserRouter } from \"react-router\";\nimport { createConfig, http, WagmiProvider } from \"wagmi\";\nimport {\n  arbitrum,\n  arbitrumSepolia,\n  base,\n  baseSepolia,\n  lens,\n  lensTestnet,\n  linea,\n  lineaSepolia,\n  mainnet,\n  optimism,\n  optimismSepolia,\n  polygon,\n  polygonAmoy,\n  sepolia,\n  worldchain,\n  worldchainSepolia,\n  zksync,\n  zksyncSepoliaTestnet,\n} from \"wagmi/chains\";\nimport {\n  coinbaseWallet,\n  injected,\n  metaMask,\n  walletConnect,\n} from \"wagmi/connectors\";\nimport { App } from \"@/components/App/App\";\nimport { XMTPProvider } from \"@/contexts/XMTPContext\";\nimport { queryClient } from \"@/helpers/queries\";\n\nexport const config = createConfig({\n  connectors: [\n    injected(),\n    coinbaseWallet({\n      appName: \"xmtp.chat\",\n    }),\n    metaMask(),\n    walletConnect({ projectId: import.meta.env.VITE_PROJECT_ID }),\n  ],\n  chains: [\n    arbitrum,\n    arbitrumSepolia,\n    base,\n    baseSepolia,\n    linea,\n    lineaSepolia,\n    mainnet,\n    optimism,\n    optimismSepolia,\n    polygon,\n    polygonAmoy,\n    sepolia,\n    worldchain,\n    worldchainSepolia,\n    zksync,\n    zksyncSepoliaTestnet,\n    lens,\n    lensTestnet,\n  ],\n  transports: {\n    [arbitrum.id]: http(),\n    [arbitrumSepolia.id]: http(),\n    [base.id]: http(),\n    [baseSepolia.id]: http(),\n    [linea.id]: http(),\n    [lineaSepolia.id]: http(),\n    [mainnet.id]: http(),\n    [optimism.id]: http(),\n    [optimismSepolia.id]: http(),\n    [polygon.id]: http(),\n    [polygonAmoy.id]: http(),\n    [sepolia.id]: http(),\n    [worldchain.id]: http(),\n    [worldchainSepolia.id]: http(),\n    [zksync.id]: http(),\n    [zksyncSepoliaTestnet.id]: http(),\n    [lens.id]: http(),\n    [lensTestnet.id]: http(),\n  },\n});\n\nconst theme = createTheme({\n  fontSizes: {\n    xxs: \"calc(0.6875rem * var(--mantine-scale))\",\n  },\n  lineHeights: {\n    xxs: \"1.2\",\n  },\n  spacing: {\n    xxs: \"calc(0.5rem * var(--mantine-scale))\",\n    xxxs: \"calc(0.25rem * var(--mantine-scale))\",\n  },\n});\n\ncreateRoot(document.getElementById(\"root\") as HTMLElement).render(\n  <WagmiProvider config={config}>\n    <QueryClientProvider client={queryClient}>\n      <MantineProvider defaultColorScheme=\"auto\" theme={theme}>\n        <XMTPProvider>\n          <BrowserRouter>\n            <App />\n          </BrowserRouter>\n        </XMTPProvider>\n      </MantineProvider>\n    </QueryClientProvider>\n  </WagmiProvider>,\n);\n\nconsole.log(\"[xmtp.chat] XMTP Browser SDK version:\", pkg.version);\n\nif (\"serviceWorker\" in navigator && import.meta.env.PROD) {\n  window.addEventListener(\"load\", () => {\n    navigator.serviceWorker\n      .register(\"/sw.js\")\n      .then((registration) => {\n        console.log(\"[xmtp.chat] Service worker registered:\", registration.scope);\n      })\n      .catch((error) => {\n        console.error(\"[xmtp.chat] Service worker registration failed:\", error);\n      });\n  });\n}\n",
      "size_bytes": 3113
    },
    "apps/xmtp.chat/src/components/Messages/ReplyContent.module.css": {
      "content": ".text {\n  text-decoration: underline;\n  cursor: pointer;\n}\n",
      "size_bytes": 59
    },
    "content-types/content-type-remote-attachment/README.md": {
      "content": "# Remote attachment content type\n\nThis package provides an XMTP content type to support sending file attachments that are stored off-network. Use it to enable your app to send and receive message attachments.\n\n## What’s an attachment?\n\nAttachments are files. More specifically, attachments are objects that have:\n\n- `filename` Most files have names, at least the most common file types.\n- `mimeType` What kind of file is it? You can often assume this from the file extension, but it's nice to have a specific field for it. [Here's a list of common mime types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types).\n- `data` What is this file's data? Most files have data. If the file doesn't have data, then it's probably not the most interesting thing to send.\n\n## Why remote attachments?\n\nBecause XMTP messages can only be up to 1MB in size, we need to store the attachment somewhere other than the XMTP network. In other words, we need to store it in a remote location.\n\n## What about encryption?\n\nEnd-to-end encryption must apply not only to XMTP messages, but to message attachments as well. For this reason, we need to encrypt the attachment before we store it.\n\n## Install the package\n\n```bash\n# npm\nnpm i @xmtp/content-type-remote-attachment\n\n# yarn\nyarn add @xmtp/content-type-remote-attachment\n\n# pnpm\npnpm i @xmtp/content-type-remote-attachment\n```\n\n## Developing\n\nRun `yarn dev` to build the content type and watch for changes, which will trigger a rebuild.\n\nFor more information on contributing to this repository, see our [contributing guidelines](../../CONTRIBUTING.md).\n",
      "size_bytes": 1628
    },
    "apps/xmtp.chat/src/components/AddressBadge.tsx": {
      "content": "import { Badge, Flex, Text, Tooltip } from \"@mantine/core\";\nimport { useClipboard } from \"@mantine/hooks\";\nimport { useCallback } from \"react\";\nimport { shortAddress } from \"@/helpers/strings\";\n\nexport type AddressTooltipLabelProps = {\n  address: string;\n};\n\nexport const AddressTooltipLabel: React.FC<AddressTooltipLabelProps> = ({\n  address,\n}) => {\n  return (\n    <Flex direction=\"column\">\n      <Text size=\"sm\">{address}</Text>\n      <Text size=\"xs\" c=\"dimmed\" ta=\"center\">\n        click to copy\n      </Text>\n    </Flex>\n  );\n};\n\nexport type AddressBadgeProps = {\n  address: string;\n  size?: \"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\";\n};\n\nexport const AddressBadge: React.FC<AddressBadgeProps> = ({\n  address,\n  size = \"lg\",\n}) => {\n  const clipboard = useClipboard({ timeout: 1000 });\n\n  const handleCopy = useCallback(\n    (\n      event:\n        | React.MouseEvent<HTMLDivElement>\n        | React.KeyboardEvent<HTMLDivElement>,\n    ) => {\n      event.stopPropagation();\n      clipboard.copy(address);\n    },\n    [clipboard, address],\n  );\n\n  const handleKeyboardCopy = useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (event.key === \"Enter\" || event.key === \" \") {\n        handleCopy(event);\n      }\n    },\n    [handleCopy],\n  );\n\n  return (\n    <Tooltip\n      label={\n        clipboard.copied ? (\n          <Text size=\"xs\">Copied!</Text>\n        ) : (\n          <AddressTooltipLabel address={address} />\n        )\n      }\n      withArrow\n      events={{ hover: true, focus: true, touch: true }}>\n      <Badge\n        variant=\"default\"\n        size={size}\n        radius=\"md\"\n        onKeyDown={handleKeyboardCopy}\n        onClick={handleCopy}\n        miw={100}\n        tabIndex={0}\n        styles={{\n          label: {\n            textTransform: \"none\",\n          },\n        }}>\n        {shortAddress(address)}\n      </Badge>\n    </Tooltip>\n  );\n};\n",
      "size_bytes": 1875
    },
    "apps/xmtp.chat/src/components/CopyButton.module.css": {
      "content": ".button {\n  color: light-dark(var(--mantine-color-light-4), var(--mantine-color-dark-1));\n}\n",
      "size_bytes": 92
    },
    "sdks/browser-sdk/CHANGELOG.md": {
      "content": "# @xmtp/browser-sdk\n\n## 5.0.1\n\n### Patch Changes\n\n- 61c19c9:\n  - Fixed an issue where duplicate welcome errors were fired erroneously\n  - Fixed a bug where building a client did a network request when not needed\n\n## 5.0.0\n\n### BREAKING CHANGES\n\n- 90089b0: Refactored `Conversation.isActive` to async method for more accurate value\n\n## 4.3.0\n\n### Minor Changes\n\n- b7a860e: Added `lastMessage()` method to `Conversation`\n\n## 4.2.1\n\n### Patch Changes\n\n- 0abcb05: Fixed initial group membership validation\n\n## 4.2.0\n\n- Improved performance of syncing new groups\n- Added support for Lens chain Smart Contract Wallet verifier\n- Fixed OpenMLS issue for persistence during message processing\n- Fixed lifetime validation gaps\n\n## 4.1.0\n\nThis release introduces improved fork detection. If you've been building on a previous release, this one should be a **drop-in replacement**. Update as soon as possible to take advantage of this enhancement.\n\n### Improved fork detection\n\nThe `isCommitLogForked` field provides definitive fork detection without false positives. To minimize the negative effects of spam, fork detection is active only for groups that a user has actively consented to.\n\nImportant: The `maybeForked` field has been deprecated. You can now use `isCommitLogForked` instead to get definitive fork detection without false positives.\n\nTo learn more, see [Forked group debugging tool](https://docs.xmtp.org/inboxes/debug-your-app#forked-group-debugging-tool).\n\n## 4.0.2\n\n### Patch Changes\n\n- ed36644: Reverted performance improvement for large inboxes that caused message streaming issues\n\n## 4.0.1\n\n### Patch Changes\n\n- ffec6e0:\n  - Improved performance for large inboxes\n  - Improved key package errors\n  - Added `appVersion` client option\n  - Added `debugEventsEnabled` client option\n  - Fixed DM stitching bug\n  - Added expiration to messages for disappearing messages\n\n## 4.0.0\n\nThis release introduces several enhancements to improve stream reliability. It contains breaking changes.\n\n### Stream reliability improvements\n\nWhen streams fail, an attempt to reconnect will be made automatically. By default, a stream will be retried 6 times with a 10 second delay between each retry. Maximum retries and retry delay can be configured with the `retryAttempts` and `retryDelay` options, respectively. To disable this feature, set the `retryOnFail` option to `false`.\n\nDuring the retry process, the `onRetry` and `onRestart` callbacks can be used to monitor progress.\n\n### BREAKING CHANGES\n\n#### All streaming methods now accept a single options argument\n\nThe new argument defines streaming options:\n\n```ts\ntype StreamOptions<T = unknown, V = T> = {\n  /**\n   * Called when the stream ends\n   */\n  onEnd?: () => void;\n  /**\n   * Called when a stream error occurs\n   */\n  onError?: (error: Error) => void;\n  /**\n   * Called when the stream fails\n   */\n  onFail?: () => void;\n  /**\n   * Called when the stream is restarted\n   */\n  onRestart?: () => void;\n  /**\n   * Called when the stream is retried\n   */\n  onRetry?: (attempts: number, maxAttempts: number) => void;\n  /**\n   * Called when a value is emitted from the stream\n   */\n  onValue?: (value: V) => void;\n  /**\n   * The number of times to retry the stream\n   * (default: 6)\n   */\n  retryAttempts?: number;\n  /**\n   * The delay between retries (in milliseconds)\n   * (default: 10000)\n   */\n  retryDelay?: number;\n  /**\n   * Whether to retry the stream if it fails\n   * (default: true)\n   */\n  retryOnFail?: boolean;\n};\n```\n\nIn addition to these options, some streaming methods have more options. See their respective types for more details.\n\nUpdate your calls to each streaming method as follows:\n\n```ts\n// OLD\nconst conversationStream = await client.conversations.stream(callback, onFail);\nconst groupStream = await client.conversations.streamGroups(callback, onFail);\nconst dmStream = await client.conversations.streamDms(callback, onFail);\nconst allMessagesStream = await client.conversations.streamAllMessages(\n  callback,\n  conversationType,\n  consentStates,\n  onFail,\n);\nconst allGroupMessagesStream = await client.conversations.streamAllGroupMessages(\n  callback,\n  consentStates,\n  onFail,\n);\nconst allDmMessagesStream = await client.conversations.streamAllDmMessages(\n  callback,\n  consentStates,\n  onFail,\n);\n\nconst consentStream = await client.preferences.streamConsent(callback, onFail);\nconst preferencesStream = await client.preferences.streamPreferences(callback, onFail);\n\nconst messagesStream = await conversation.stream(callback, onFail);\n\n// NEW\nconst conversationStream = await client.conversations.stream({\n  onError,\n  onValue,\n  onFail\n});\nconst groupStream = await client.conversations.streamGroups({\n  onError,\n  onValue,\n  onFail\n});\nconst dmStream = await client.conversations.streamDms({\n  onError,\n  onValue,\n  onFail\n});\nconst allMessageStream = await client.conversations.streamAllMessages({\n  consentStates,\n  conversationType\n  onError,\n  onValue,\n  onFail\n});\nconst allGroupMessagesStream = await client.conversations.streamAllGroupMessages({\n  consentStates,\n  onError,\n  onValue,\n  onFail,\n});\nconst allDmMessagesStream = await client.conversations.streamAllDmMessages({\n  consentStates,\n  onError,\n  onValue,\n  onFail,\n});\n\nconst consentStream = await client.preferences.streamConsent({\n  onError,\n  onValue,\n  onFail,\n});\nconst preferencesStream = await client.preferences.streamPreferences({\n  onError,\n  onValue,\n  onFail,\n});\n\nconst messagesStream = await conversation.stream({\n  onError,\n  onValue,\n  onFail\n});\n```\n\n#### Streams no longer end on error\n\nWhen a stream error occurs, it's passed to the `onError` callback only. The stream will remain active.\n\n#### Stream types have changed\n\nWhen using the `for await..of` loop, the value will never be `undefined`.\n\n```ts\nconst stream = await client.conversations.streamAllMessages();\n\nfor await (const message of stream) {\n  // message will always be an instance of DecodedMessage\n}\n```\n\n## 3.1.2\n\n### Patch Changes\n\n- 78c6710:\n  - Resolved issue with too many key package API requests\n  - Fixed issue causing users with old installations to sometimes not be added to groups\n  - Fixed a performance bottleneck that affected listing conversations while syncing\n\n## 3.1.1\n\n### Patch Changes\n\n- 41aeaae:\n  - Improved sync and stream performance\n  - Increased max installations to 10\n  - Fixed a known fork issue\n  - Added key package rotation every 30 days\n\n## 3.1.0\n\nThis release introduces several enhancements, including quantum-resistant encryption, improved identity management, and refined read/write rate limits.\n\nIf you've been building on a previous release, this one should be a **drop-in replacement**. Update as soon as possible to take advantage of these enhancements and fixes.\n\n### Support for quantum-resistant encryption\n\nXMTP now supports quantum-resistant encryption, providing enhanced security for message transmission and storage. This upgrade ensures your app is protected against future quantum computer attacks through post-quantum cryptography.\n\nTo learn more, see [Quantum resistance](https://docs.xmtp.org/protocol/security#quantum-resistance).\n\n### Consistent identity ordering\n\nWhen an inbox has multiple associated identities, the `identities` array is now ordered by the `client_timestamp_ns` field, which sorts identities based on when they were added to the inbox, placing the earliest added identity first.\n\nTo learn more, see [Select the identity to display](https://docs.xmtp.org/inboxes/manage-inboxes#select-the-identity-to-display).\n\n### Enhanced rate limits with separate read/write limits\n\nXMTP now provides separate rate limits for read and write operations, offering more granular control over API usage. Read operations are limited to 20,000 requests per 5-minute window, while write operations are limited to 3,000 messages per 5-minute window.\n\nTo learn more, see [Observe rate limits](https://docs.xmtp.org/inboxes/rate-limits).\n\n### Improved history sync\n\nHistory sync has been enhanced with better consent management across installations and improved handling of denied conversations. These changes ensure a more consistent experience when users access XMTP from multiple installations.\n\nTo learn more, see [Enable history sync](https://docs.xmtp.org/inboxes/history-sync).\n\n### Enhanced group chat updates\n\nGroup membership changes now automatically trigger group update codec messages, ensuring all participants receive consistent information about group state changes. This improves the reliability of group chat synchronization across all devices.\n\nTo learn more, see [Manage group chat membership](https://docs.xmtp.org/inboxes/group-permissions#manage-group-chat-membership).\n\n### Performance improvements and bug fixes\n\nThis release includes various performance optimizations throughout the SDK, resulting in faster message processing, improved memory usage, and better overall responsiveness. The release also includes bug fixes that improve the reliability of group chats and address a performance degradation issue that could occur when creating new groups.\n\nTo learn more about optimizing your XMTP implementation, see [Debug your app](https://docs.xmtp.org/inboxes/debug-your-app).\n\n## 3.0.5\n\n### Patch Changes\n\n- 3f4d125:\n  - Refactored `AsyncStream` to be more spec-compliant\n  - Added `onDone` callback to `AsyncStream`\n  - Updated stream methods to use new `onDone` callback to end streams\n\n## 3.0.4\n\n### Patch Changes\n\n- e0b7745:\n  - Fixed group syncing on larger groups\n  - Fixed HTTP stream panic when subscription request fails\n\n## 3.0.3\n\n### Patch Changes\n\n- 8729f02:\n  - Increased max payload size to `25MB`\n  - Improved `syncAll` performance\n\n## 3.0.2\n\n### Patch Changes\n\n- 63c144d: Fixed static installation revokation\n\n## 3.0.1\n\n### Patch Changes\n\n- 10bf2d1: Fixed some issues that may cause group forks\n\n## 3.0.0\n\nThis update introduces enhancements for managing installations without a client. It also contains breaking changes related to signature management and consistency across SDKs.\n\n### BREAKING CHANGES\n\n#### Debug information has been moved to `client.debugInformation`\n\nTo better align with our mobile SDKs, debug information helpers are now accessible at the `debugInformation` property of client instances.\n\nUpdate your calls to the following:\n\n- `client.apiStatistics()` => `client.debugInformation.apiStatistics()`\n- `client.apiIdentityStatistics()` => `client.debugInformation.apiIdentityStatistics()`\n- `client.apiAggregateStatistics()` => `client.debugInformation.apiAggregateStatistics()`\n- `client.clearAllStatistics()` => `client.debugInformation.clearAllStatistics()`\n- `client.uploadDebugArchive()` => `client.debugInformation.uploadDebugArchive()`\n\n#### Signatures are now managed through signature requests\n\nThis change only affects developers who are using custom workflows with the `unsafe_*SignatureText` client methods.\n\nWhen using a custom signing workflow, the `unsafe_*SignatureText` client methods now return an object with the following type:\n\n```ts\ntype SignatureRequestResult = {\n  signatureText: string;\n  signatureRequestId: string;\n};\n```\n\nAfter signing the `signatureText`, you must create a special signer and pass it to the `unsafe_applySignatureRequest` client method along with the `signatureRequestId`.\n\n**Example**\n\n```ts\n// change the recovery identifier\nconst { signatureText, signatureRequestId } =\n  await this.unsafe_changeRecoveryIdentifierSignatureText(newIdentifier);\n// use a `Signer` to sign the signature text\nconst signature = await signer.signMessage(signatureText);\n// `toSafeSigner` is a new export from `@xmtp/browser-sdk`\nconst safeSigner = await toSafeSigner(signer, signature);\n\nawait client.unsafe_applySignatureRequest(safeSigner, signatureRequestId);\n```\n\nAs part of this change, the `SignatureRequestType` export has been replaced with `SignatureRequestHandle`.\n\n### Other changes\n\n- Added `Client.revokeInstallations` static method for revoking installations without a client\n- Added `Client.inboxStateFromInboxIds` static method for getting inbox state without a client\n\n## 2.2.1\n\n### Patch Changes\n\n- e86b0c9: Fixed async iterator exit when calling `end()` on `AsyncStream`\n\n## 2.2.0\n\nThis update introduces several targeted enhancements and clarifications related to managing client builds, network statistics, installations, and group chats.\n\nIf you’ve been building on a previous release, this one should be a **drop-in replacement**. Update as soon as possible to take advantage of these enhancements and fixes.\n\n### Reset network statistics for debugging\n\nA new helper, `clearAllStatistics()`, lets you reset all API/identity/stream network statistics counters.\n\nUse it to get a clean baseline between test runs or free memory on devices where cached gRPC stats grow over time.\n\nTo learn more, see [Network statistics](https://docs.xmtp.org/inboxes/debug-your-app#network-statistics).\n\n### Support installation limits and more targeted revocations\n\nXMTP now enforces up to 5 app installations per inbox ID.\n\nWhen the installation limit is reached, you can revoke an installation to free up a slot.\n\nTo learn more, see [Revoke installations](https://docs.xmtp.org/inboxes/manage-inboxes#revoke-installations).\n\n### Support slightly larger group chats\n\nThe maximum group chat size has been raised from 220 to 250 members.\n\nTo learn more, see [Create a new group chat](https://docs.xmtp.org/inboxes/create-conversations#create-a-new-group-chat).\n\n### Reduced risk of group chat forks\n\nAdditional safeguards have been added to minimize the chance of unintended group chat forks.\n\nTo learn about what group chat forks are and how they can occur, see [MLS Group State Forks: What, Why, How](https://cryspen.com/post/mls-fork-resolution/).\n\n## 2.1.1\n\n### Patch Fixes\n\nFixes streaming bug that would sometimes cause streams to miss messages\n\nFixes stream conversations bug that would hang all conversations streams upon a backend node update adding a field to welcome messages\n\nupdates @xmtp/wasm-bindings to 1.2.1\n\n## 2.1.0\n\nThis release delivers enhancements to messaging performance and reliability, as well as a set of developer debugging tools, all focused on making it easier to build with XMTP.\n\nIf you’ve been building on a previous release, this one should be a **drop-in replacement**—just update to the latest version to take advantage of everything below.\n\n### Consent-based listing, streaming, and syncing\n\nBy default, `conversations.list`, `conversations.listGroups`, `conversations.listDms`, `conversations.syncAll`, `conversations.streamAllMessages`, `conversations.streamAllGroupMessages`, and `conversations.streamAllDmMessages` now filter for conversations with a consent state of `ConsentState.Allowed` or `ConsentState.Unknown`.\n\nWe recommend listing `ConsentState.Allowed` conversations only. This ensures that spammy conversations with a consent state of `ConsentState.Unknown` don't degrade the user experience.\n\nTo include all conversations regardless of consent state, you can pass `[ConsentState.Allowed, ConsentState.Unknown, ConsentState.Denied]`.\n\n### Optimistic group chat creation\n\nProvides faster and offline group chat creation and message preparation before adding members.\n\n### Group chat member limit\n\n**A 220-member limit is now enforced for group chats.** This helps prevent errors that oversized groups can cause and ensures consistent behavior across clients.\n\n### Preference sync\n\nPreference syncing enables you to sync the following preference-related information across multiple existing app installations:\n\n- Conversation consent preferences\n- Conversation HMAC keys (for push notifications)\n\n### Developer tooling and debugging\n\nDelivers tools and features for debugging when building with XMTP, including group chat diagnostics, file logging, and network statistics.\n\n### Reliability and performance\n\n- Reliability improvements to message history\n- Reliability improvements to [`streamAll`](https://docs.xmtp.org/inboxes/list-and-stream#stream-all-group-chat-and-dm-messages)\n- Performance improvements to `peerInboxId`\n- [Duplicate DMs](https://docs.xmtp.org/inboxes/push-notifs/understand-push-notifs#dm-stitching-considerations-for-push-notifications) removed from streams\n\n## 2.0.13\n\n### Patch Changes\n\n- 441a029: `AsyncStream` updates\n  - Changed signature of `return` to allow no argument (e.g. `stream.return()`)\n  - Added `end` alias that calls `return` without an argument\n  - Added `AsyncStream` and `StreamCallback` to exports\n\n## 2.0.12\n\n### Patch Changes\n\n- 616fdec: Added `null` option to `historySyncUrl` client option to allow disabling of history sync\n\n## 2.0.11\n\n### Patch Changes\n\n- 5bc5a85: Update to the libxmtp stable release version\n\n## 2.0.10\n\n### Patch Changes\n\n- 581d465: Added guard to prevent unexpected conversation types\n\n## 2.0.9\n\n### Patch Changes\n\n- 4035fb5: Removed special sync groups from conversation list results\n\n## 2.0.8\n\n### Patch Changes\n\n- fbce324: Fix welcome processing issue that could lead to incorrect group state\n\n## 2.0.7\n\n### Patch Changes\n\n- 5a676b1: Propagated original error from workers\n\n## 2.0.6\n\n### Patch Changes\n\n- b7a3001: Fixed message processing issue that could sometimes fork groups\n\n## 2.0.5\n\n### Patch Changes\n\n- f0a43c4: Lowercase Ethereum addresses on static Client.canMessage calls\n\n## 2.0.4\n\n### Patch Changes\n\n- Converted all `any` types to `unknown`\n- Added generics for types with `unknown` where applicable\n- Prevented `CodecNotFoundError` from throwing when instantiating `DecodedMessage`\n- Added missing `signer` property to `Client`\n- Updated code comments\n- Updated dependencies [63e5276]\n  - @xmtp/content-type-group-updated@2.0.2\n  - @xmtp/content-type-primitives@2.0.2\n  - @xmtp/content-type-text@2.0.2\n\n## 2.0.3\n\n### Patch Changes\n\n- 6e54926: Exposed message decoding errors in streams\n\n## 2.0.2\n\n### Patch Changes\n\n- f021255: Fixed missing key package status error\n\n## 2.0.1\n\n### Patch Changes\n\n- 7e7fad4: Fixed error handling in `AsyncStream`\n\n## 2.0.0\n\nThis release focuses on new features, stability, and performance.\n\n## Upgrade from 1.1.4 to 2.0.0\n\nUse the information in these release notes to upgrade from `@xmtp/browser-sdk` 1.1.4 to 2.0.0.\n\n## Breaking changes\n\n### Refactored `Client.create`\n\nThe database encryption key parameter was removed from the static `Client.create` method. To use a database encryption key, add it to the client options.\n\n`1.x` code:\n\n```typescript\nimport { Client, type Signer } from \"@xmtp/browser-sdk\";\n\nconst clientOptions = {\n  /* client options */\n};\nconst dbEncryptionKey = MY_ENCRYPTION_KEY;\nconst signer: Signer = {\n  /* signer properties */\n};\nconst client = await Client.create(signer, dbEncryptionKey, clientOptions);\n```\n\n`2.0.0` code:\n\n```typescript\nimport { Client, type Signer } from \"@xmtp/browser-sdk\";\n\nconst clientOptions = {\n  dbEncryptionKey: MY_ENCRYPTION_KEY,\n};\nconst signer: Signer = { ... };\nconst client = await Client.create(signer, clientOptions);\n```\n\n### Refactored `Client` constructor\n\nThe `Client` constructor now only accepts a single parameter: client options. It's no longer possible to create a client with a signer using the constructor. Use `Client.create` to create a new client with a signer.\n\n`1.x` code:\n\n```typescript\nimport { Client, type Signer } from \"@xmtp/browser-sdk\";\n\nconst clientOptions = {\n  /* client options */\n};\nconst dbEncryptionKey = MY_ENCRYPTION_KEY;\nconst signer: Signer = {\n  /* signer properties */\n};\nconst client = new Client(signer, dbEncryptionKey, clientOptions);\n```\n\n`2.0.0` code:\n\n```typescript\nimport { Client, type Signer } from \"@xmtp/browser-sdk\";\n\nconst clientOptions = {\n  dbEncryptionKey: MY_ENCRYPTION_KEY,\n};\nconst signer: Signer = { ... };\nconst client = await Client.create(signer, clientOptions);\n```\n\n### Client `accountIdentifier` method is now a property\n\n`1.x` code:\n\n```typescript\nconst identifier = await client.accountIdentifier();\n```\n\n`2.0.0` code:\n\n```typescript\nconst identifier = client.accountIdentifier;\n```\n\n### Client options are now read-only\n\nSetting client options after initialization is no longer possible.\n\n### Removed `Opfs` export\n\nThis export was not usable in its exported form and has been removed. OPFS utilities to manage local databases will be added in a future release.\n\n## New features\n\n### Added `Client.build` static method\n\nIt's now possible to create a client without a signer using the new `Client.build` method. A signer is not required if an account is already registered on the XMTP network. Keep in mind, some client methods still require a signer.\n\n```typescript\nimport { Client, type Identifier } from \"@xmtp/browser-sdk\";\n\nconst identifier: Identifier = {\n  identifier: \"0x1234567890abcdef1234567890abcdef12345678\",\n  identifierKind: \"Ethereum\",\n};\nconst client = await Client.build(identifier, options);\n```\n\n### Added `changeRecoveryIdentifier` method to `Client`\n\nThe recovery identifier can now be changed. This method requires a client with a signer.\n\n```typescript\nimport { Client, type Signer } from \"@xmtp/browser-sdk\";\n\nconst signer: Signer = { ... };\nconst client = await Client.create(signer, options);\n\nconst identifier: Identifier = {\n  identifier: \"0x1234567890abcdef1234567890abcdef12345678\",\n  identifierKind: \"Ethereum\",\n};\nawait client.changeRecoveryIdentifier()\n```\n\n### Added `getKeyPackageStatusesForInstallationIds` method to `Client`\n\nKey package status can now be retrieved for installation IDs. This new method returns a `Map` of installation IDs and their respective status.\n\n```typescript\nimport { Client, type Identifier } from \"@xmtp/browser-sdk\";\n\nconst identifier: Identifier = {\n  identifier: \"0x1234567890abcdef1234567890abcdef12345678\",\n  identifierKind: \"Ethereum\",\n};\nconst client = await Client.build(identifier, options);\n\ntype SafeKeyPackageStatus = {\n  lifetime?: {\n    notBefore: bigint;\n    notAfter: bigint;\n  };\n  validationError?: string;\n};\n\nconst keyPackageStatuses: Map<string, SafeKeyPackageStatus> =\n  await client.getKeyPackageStatusesForInstallationIds([\n    /* array of installation IDs here */\n  ]);\n```\n\n## Added `getHmacKeys` method to `Conversation`\n\nIt's now possible to get the HMAC keys of individual conversations.\n\n```typescript\ntype SafeHmacKey = {\n  key: Uint8Array;\n  epoch: bigint;\n};\n\nconst conversation = client.conversations.getConversationById(\"...\");\n\nif (conversation) {\n  const hmacKeys: SafeHmacKey[] = await conversation.getHmacKeys();\n}\n```\n\n### Other changes\n\n- Refactored static `Client.canMessage` to remove the creation of a temporary client\n- Updated `dbPath` client option to allow `null` value\n- Added custom error types\n- Added `dbEncryptionKey` option to client options\n\n## 1.1.4\n\n### Patch Changes\n\n- 8bd3930: Fixed removing inboxes with invalid key packages from groups\n\n## 1.1.3\n\n### Patch Changes\n\n- 295e046:\n  - Fixed incorrect key package associations\n  - Resolved DM stitching issues for conversations without messages\n\n## 1.1.2\n\n### Patch Changes\n\n- 5845617: Refactored welcome message processing to prevent key package deletion on failure\n\n## 1.1.1\n\n### Patch Changes\n\n- Updated dependencies [340fcf4]\n  - @xmtp/content-type-group-updated@2.0.1\n  - @xmtp/content-type-primitives@2.0.1\n  - @xmtp/content-type-text@2.0.1\n  - @xmtp/proto@3.78.0\n  - uuid@11.1.0\n\n## 1.1.0\n\n### Minor Changes\n\n- 999bb78: Added `inboxStateFromInboxIds` to `Preferences`\n\n## 1.0.0\n\nThis release focuses on delivering an SDK for a stable, performant, and hardened XMTP V3.\n\n> [!IMPORTANT]  \n> Please upgrade your app to **use @xmtp/browser-sdk ≥ 1.0.0 by May 1, 2025** to continue using XMTP. On May 1, XMTP V3 will enforce this minimum SDK version. Apps on outdated V3 SDKs will lose connectivity.\n\n## Upgrade from 0.0.x to 1.0.0\n\nUse the information in these release notes to upgrade from @xmtp/browser-sdk 0.0.x to 1.0.0.\n\n> [!IMPORTANT]  \n> **Upgrading from a legacy XMTP V2 SDK?** Legacy XMTP V2 SDKs include JavaScript SDK vx.x.x. To learn how to upgrade to stable XMTP V3, be sure to also see important dates and considerations in [Upgrade from a legacy XMTP V2 SDK](https://docs.xmtp.org/upgrade-from-legacy-V2).\n\n## Breaking changes\n\n### Primary XMTP identifier is now an inbox ID, not an Ethereum address\n\nIn preparation for upcoming support for [Passkeys](https://community.xmtp.org/t/xip-55-passkey-identity/874), XMTP must evolve from using Ethereum account addresses (0x...) as the primary identifier to an inbox-based identity model.\n\nThis change allows for broader support of different authentication mechanisms, including the currently supported [Externally Owned Accounts (EOAs) and Smart Contract Wallets (SCWs)](https://docs.xmtp.org/inboxes/build-inbox#create-an-account-signer), as well as **future support** for Passkeys, Bitcoin, and Solana, for example.\n\nThe move to an inbox-based identity model means the following shift in approach when developing with XMTP:\n\n- Instead of assuming an Ethereum address as the unique identifier, developers should default to using an inbox ID where possible.\n- Where you previously used an Ethereum address, you must now use an inbox ID\n  - `addMembers(addresses)` → `addMembers(inboxIds)`\n  - `removeMember(addresses)` → `removeMembers(inboxIds)`\n  - `newGroup(addresses)` → `newGroup(inboxIds)`\n  - `newDm(address)` → `newDm(inboxId)`\n\n> [!WARNING]\n> These function changes (address → inbox ID) won't trigger errors since both parameters are strings. Your code will pass a type-check but may fail at runtime. Pay special attention to these changes when upgrading.\n\n- The previous methods that allowed the use of an inbox ID have been removed in favor of the above methods\n  - ~`addMembersByInboxIds(inboxIds)`~\n  - ~`removeMembersByInboxIds(inboxIds)`~\n  - ~`newGroupByInboxIds(inboxIds)`~\n  - ~`newDmByInboxId(inboxId)`~\n\n- New methods have been added to allow the use of addresses with the `Identifier` type\n  - `addMembersByIdentifiers(Identifier[])`\n  - `removeMembersByIdentifiers(Identifier[])`\n  - `newGroupByIdentifiers(Identifier[])`\n  - `newDmByIdentifier(Identifier)`\n\n- We recommend moving away from using addresses in code completely. However, if you MUST use addresses, wrap them with the `Identifier` type.\n\n  For example, the address `0x1234567890abcdef1234567890abcdef12345678` must now be wrapped like so:\n\n  ```tsx\n  const identifier: Identifier = {\n    identifier: \"0x1234567890abcdef1234567890abcdef12345678\",\n    identifierKind: \"Ethereum\",\n  };\n  ```\n\n- Because XMTP is interoperable, you may interact with inboxes that are not on your app. In these scenarios, you will need to find the appropriate inbox ID or address.\n\n  ```tsx\n  // get an inbox ID from an address\n  const inboxId = await getInboxIdForIdentifier({\n    identifier: \"0x1234567890abcdef1234567890abcdef12345678\",\n    identifierKind: \"Ethereum\",\n  });\n\n  // find the addresses associated with an inbox ID\n  const inboxState = await client.inboxStateFromInboxIds([inboxId]);\n\n  interface InboxState {\n    inboxId: string;\n    recoveryIdentifier: Identifier;\n    installations: Installation[];\n    identifiers: Identifier[];\n  }\n\n  const addresses = inboxState.identifiers\n    .filter((i) => i.identifierKind === \"Ethereum\")\n    .map((i) => i.identifier);\n  ```\n\n### Wallet and signer updates\n\nThe term “wallet” has been removed from the codebase. This is to align with future support for Passkeys and other non-wallet-based authentication methods.\n\nThis release includes breaking changes to the `Signer` type.\n\n- The `walletType` field is now `type`. The `type` field refers to the type of account that will sign messages, such as an `EOA` or `SCW`.\n- The `getAddress` field has been replaced by `getIdentifier`, which is a function that returns an `Identifier` type.\n\n```tsx\n// old\nconst address = await signer.getAddress();\n\n// new\nconst identifier = await signer.getIdentifier();\n// identifier may not be an Ethereum address\nconst address =\n  identifier.identifierKind === \"Ethereum\" ? identifier.identifier : undefined;\n```\n\n### Consent and inbox state have been moved to `client.preferences`\n\nEverything related to consent, inbox state, and user preferences is now part of the `Preferences` class and accessible via `client.preferences`.\n\n- `client.inboxState` → `client.preferences.inboxState`\n- `client.getLatestInboxState` → `client.preferences.getLatestInboxState`\n- `client.inboxStateFromInboxIds` → `client.preferences.inboxStateFromInboxIds`\n- `client.getConsentState` → `client.preferences.getConsentState`\n- `client.setConsentStates` → `client.preferences.setConsentStates`\n- `client.conversations.streamConsent` → `client.preferences.streamConsent`\n- `client.conversations.streamPreferences` → `client.preferences.streamPreferences`\n\n## Other recent changes\n\n### Conversations are now instances of `Group` or `Dm`\n\nThe new `Group` and `Dm` classes extend the `Conversation` class and provide specific functionality based on the conversation type.\n\n> [!NOTE]  \n> `client.conversations.list()` now returns an array of `Group` or `Dm` classes. When accessing specific functionality based on conversation type, you must check the type first so that the TypeScript compiler can narrow the type.\n\n```tsx\nconst conversations: (Group | Dm)[] = await client.conversations.list();\n\nfor (const conversation of conversations) {\n  // narrow the type to Group to access the group name\n  if (conversation instanceof Group) {\n    console.log(group.name);\n  }\n\n  // narrow the type to Dm to access the peer inboxId\n  if (conversation instanceof Dm) {\n    console.log(conversation.peerInboxId);\n  }\n}\n```\n\n## Recently added features\n\n### Disappearing messages\n\nThis release provides support for disappearing (ephemeral) messages. These are messages that are intended to be visible to users for only a short period of time. After the message expiration time passes, the messages are removed from the UI and deleted from local storage so the messages are no longer accessible to conversation participants.\n\nTo learn more, see [Support disappearing messages with XMTP](https://docs.xmtp.org/inboxes/disappearing-messages).\n\n### Future-proofing app interoperability\n\nThis release introduces error handling that will help support app interoperability across SDK versions, even when breaking changes are required in the future.\n\nIn the future, an SDK version may introduce a breaking change, such as a feature that works only for apps on the latest versions of the SDK. Instead of forcing immediate upgrades or causing apps on older versions to break, this update adds a safety net that gracefully handles breaking changes.\n\nAt this time, no features rely on this mechanism, and no action is needed. However, this ensures your app remains resilient to future SDK updates that introduce breaking changes.\n\n## 1.0.0-rc1\n\n- Updated `Signer` type\n- Replaced address parameters with inbox IDs or identifiers\n- Added new methods to use with identifiers\n- Added `pausedForVersion` to `Conversation`\n- Updated exports\n\n## 0.0.23\n\n### Patch Changes\n\n- dd1a33a: Fixed stream errors\n\n## 0.0.22\n\n### Patch Changes\n\n- 3cf6dd9:\n  - Exposed all client signature methods\n  - Added guard to `Client.addAccount` to prevent automatic reassignment of inboxes\n  - Renamed `syncAdmins` to `listAdmins` and `syncSuperAdmins` to `listSuperAdmins`\n  - Added consent and preference streaming\n  - Removed `allowedStates`, `conversationType`, and `includeSyncGroups` from `ListConversationsOptions`\n  - Added `contentTypes` option to `ListMessagesOptions`\n  - Changed OPFS VFS to SyncAccessHandle Pool\n  - Added more exports from the bindings\n  - Added `Group` and `Dm` classes\n  - Refactored some functions to use the new `Group` and `Dm` classes\n\n## 0.0.21\n\n### Patch Changes\n\n- f53c967: Refactored `Signer`, made `getBlockNumber` optional for SCW signers\n\n## 0.0.20\n\n### Patch Changes\n\n- 74ce850: Fix signer for SCW\n\n## 0.0.19\n\n### Patch Changes\n\n- 03d2002:\n  - Added `allowedStates`, `consentStates`, `includeSyncGroups`, and `includeDuplicateDms` options to `Conversations.list` method\n  - Added `consentStates` option to `Conversations.syncAll` method\n  - Added `newGroupByInboxIds` method to `Conversations`\n  - Added `newDmByInboxId` method to `Conversations`\n  - Added `messageDisappearingSettings` option for creating groups and DMs\n  - Added `updateMessageDisappearingSettings` method to `Conversation`\n  - Added `removeMessageDisappearingSettings` method to `Conversation`\n  - Added `isMessageDisappearingEnabled` method to `Conversation`\n  - Fixed invalid key package issues\n  - Fixed rate limiting issues\n\n## 0.0.18\n\n### Patch Changes\n\n- ec5cd41:\n  - Added streaming methods\n  - Removed group pinned frame URL metadata\n  - Fixed DB locking issues\n\n## 0.0.17\n\n### Patch Changes\n\n- 25e0e15:\n  - Optimized `toSafeConversation`\n  - Replaced some `??` with `||` to ensure string values are not empty\n\n## 0.0.16\n\n### Patch Changes\n\n- 626d420: Fixed DM group syncing across installations\n\n## 0.0.15\n\n### Patch Changes\n\n- cf6fbc0: Added default history sync URL to client with option to override\n\n## 0.0.14\n\n### Patch Changes\n\n- c91612d: Added support for HMAC keys\n\n## 0.0.13\n\n### Patch Changes\n\n- b4f452c: Added installation ID bytes to inbox state\n\n## 0.0.12\n\n### Patch Changes\n\n- d09ec27:\n  - Added support for revoking specific installations\n  - Refactored `list`, `listGroups`, and `listDms` to be synchronous when called from worker\n\n## 0.0.11\n\n### Patch Changes\n\n- 3a1e53b: Enabled group permissions updates\n  - Added `updatePermission` method to `Conversation`\n  - Refactored `permissions` getter to async function\n  - Exported `MetadataField` type\n\n## 0.0.10\n\n### Patch Changes\n\n- dad39c4:\n  - Added admins and super admins to conversation data sync\n  - Refactored `Conversation` admin and super admin accessors\n    - Changed `admins` and `superAdmins` to getters\n    - Added `syncAdmins` and `syncSuperAdmins` methods\n  - Refactored `Conversations.getConversationById`, `Conversations.listDms`, `Conversations.listGroups`, and `Conversations.getDmByInboxId` to return `Conversation` instances\n  - Refactored `Conversations.getMessageById` to return `DecodedMessage` instance\n\n## 0.0.9\n\n### Patch Changes\n\n- a35afb8: Upgraded bindings, refactored some methods to be async\n\n## 0.0.8\n\n### Patch Changes\n\n- 8120a39: Added support for custom permissions policy\n\n## 0.0.7\n\n### Patch Changes\n\n- 1777a23: Dropped support for CommonJS\n- Updated dependencies [1777a23]\n  - @xmtp/content-type-group-updated@2.0.0\n  - @xmtp/content-type-primitives@2.0.0\n  - @xmtp/content-type-text@2.0.0\n\n## 0.0.6\n\n### Patch Changes\n\n- 9324310:\n  - Added `installationIdBytes` to `Client`\n  - Added `Conversations.syncAll` method\n  - Added `signWithInstallationKey`, `verifySignedWithInstallationKey`, and `verifySignedWithPublicKey` methods to `Client`\n\n## 0.0.5\n\n### Patch Changes\n\n- 63e5276: Updated exports\n- Updated dependencies [63e5276]\n  - @xmtp/content-type-group-updated@1.0.1\n  - @xmtp/content-type-primitives@1.0.3\n  - @xmtp/content-type-text@1.0.1\n  - @xmtp/proto@3.72.0\n\n## 0.0.4\n\n### Patch Changes\n\n- a1a16a0:\n  - Added `Signer` interface\n  - Refactored `Client.create` to accept a `Signer` instead of account address\n  - Refactored client creation to automatically register and identity\n  - Added `disableAutoRegister` to `ClientOptions` to allow disabling of client registration after creation\n  - Removed direct access to all signature functions\n  - Added `Client.register` method for registering a client\n  - Added `Client.addAccount` method for adding another account to an installation\n  - Added `Client.removeAccount` method for removing an account from an installation\n  - Added `Client.revokeInstallations` method for revoking all other installations\n  - Added static `Client.canMessage` for checking if an address is on the network without a client\n\n## 0.0.3\n\n### Patch Changes\n\n- f3734c8:\n  - Upgraded to latest WASM bindings\n  - Required `encryptionKey` when creating a new client\n  - Added smart contract wallet signature support\n  - Added more logging options\n  - Updated WASM bindings re-exports\n\n## 0.0.2\n\n### Patch Changes\n\n- 5479e31: Upgraded to latest WASM bindings\n\n## 0.0.1\n\nInitial release\n",
      "size_bytes": 36123
    },
    "sdks/node-sdk/vitest.config.ts": {
      "content": "/// <reference types=\"vitest\" />\nimport { defineConfig, mergeConfig } from \"vite\";\nimport tsconfigPaths from \"vite-tsconfig-paths\";\nimport { defineConfig as defineVitestConfig } from \"vitest/config\";\n\n// https://vitejs.dev/config/\nconst viteConfig = defineConfig({\n  plugins: [tsconfigPaths()],\n});\n\nconst vitestConfig = defineVitestConfig({\n  test: {\n    globals: true,\n    testTimeout: 120000,\n    hookTimeout: 60000,\n    globalSetup: [\"./vitest.setup.ts\"],\n  },\n});\n\nexport default mergeConfig(viteConfig, vitestConfig);\n",
      "size_bytes": 524
    },
    "sdks/browser-sdk/src/Conversations.ts": {
      "content": "import {\n  ConversationType,\n  type ConsentState,\n  type Identifier,\n} from \"@xmtp/wasm-bindings\";\nimport { v4 } from \"uuid\";\nimport type { Client } from \"@/Client\";\nimport { DecodedMessage } from \"@/DecodedMessage\";\nimport { Dm } from \"@/Dm\";\nimport { Group } from \"@/Group\";\nimport type {\n  SafeConversation,\n  SafeCreateDmOptions,\n  SafeCreateGroupOptions,\n  SafeListConversationsOptions,\n  SafeMessage,\n} from \"@/utils/conversions\";\nimport {\n  createStream,\n  type StreamCallback,\n  type StreamOptions,\n} from \"@/utils/streams\";\n\n/**\n * Manages conversations\n *\n * This class is not intended to be initialized directly.\n */\nexport class Conversations<ContentTypes = unknown> {\n  #client: Client<ContentTypes>;\n\n  /**\n   * Creates a new conversations instance\n   *\n   * @param client - The client instance managing the conversations\n   */\n  constructor(client: Client<ContentTypes>) {\n    this.#client = client;\n  }\n\n  /**\n   * Synchronizes conversations for the current client from the network\n   *\n   * @returns Promise that resolves when sync is complete\n   */\n  async sync() {\n    return this.#client.sendMessage(\"conversations.sync\", undefined);\n  }\n\n  /**\n   * Synchronizes all conversations and messages from the network with optional\n   * consent state filtering, then uploads conversation and message history to\n   * the history sync server\n   *\n   * @param consentStates - Optional array of consent states to filter by\n   * @returns Promise that resolves when sync is complete\n   */\n  async syncAll(consentStates?: ConsentState[]) {\n    return this.#client.sendMessage(\"conversations.syncAll\", {\n      consentStates,\n    });\n  }\n\n  /**\n   * Retrieves a conversation by its ID\n   *\n   * @param id - The conversation ID to look up\n   * @returns Promise that resolves with the conversation, if found\n   */\n  async getConversationById(id: string) {\n    const data = await this.#client.sendMessage(\n      \"conversations.getConversationById\",\n      {\n        id,\n      },\n    );\n    if (data) {\n      return data.metadata.conversationType === \"group\"\n        ? new Group(this.#client, data.id, data)\n        : new Dm(this.#client, data.id, data);\n    }\n    return undefined;\n  }\n\n  /**\n   * Retrieves a message by its ID\n   *\n   * @param id - The message ID to look up\n   * @returns Promise that resolves with the decoded message, if found\n   */\n  async getMessageById(id: string) {\n    const data = await this.#client.sendMessage(\n      \"conversations.getMessageById\",\n      {\n        id,\n      },\n    );\n    return data ? new DecodedMessage(this.#client, data) : undefined;\n  }\n\n  /**\n   * Retrieves a DM by inbox ID\n   *\n   * @param inboxId - The inbox ID to look up\n   * @returns Promise that resolves with the DM, if found\n   */\n  async getDmByInboxId(inboxId: string) {\n    const data = await this.#client.sendMessage(\n      \"conversations.getDmByInboxId\",\n      {\n        inboxId,\n      },\n    );\n    return data ? new Dm(this.#client, data.id, data) : undefined;\n  }\n\n  /**\n   * Lists all conversations with optional filtering\n   *\n   * @param options - Optional filtering and pagination options\n   * @returns Promise that resolves with an array of conversations\n   */\n  async list(options?: SafeListConversationsOptions) {\n    const conversations = await this.#client.sendMessage(\"conversations.list\", {\n      options,\n    });\n\n    return conversations\n      .map((conversation) => {\n        switch (conversation.metadata.conversationType) {\n          case \"dm\":\n            return new Dm(this.#client, conversation.id, conversation);\n          case \"group\":\n            return new Group(this.#client, conversation.id, conversation);\n          default:\n            return undefined;\n        }\n      })\n      .filter((conversation) => conversation !== undefined);\n  }\n\n  /**\n   * Lists all group conversations with optional filtering\n   *\n   * @param options - Optional filtering and pagination options\n   * @returns Promise that resolves with an array of groups\n   */\n  async listGroups(\n    options?: Omit<SafeListConversationsOptions, \"conversation_type\">,\n  ) {\n    const conversations = await this.#client.sendMessage(\n      \"conversations.listGroups\",\n      {\n        options,\n      },\n    );\n\n    return conversations.map(\n      (conversation) => new Group(this.#client, conversation.id, conversation),\n    );\n  }\n\n  /**\n   * Lists all DM conversations with optional filtering\n   *\n   * @param options - Optional filtering and pagination options\n   * @returns Promise that resolves with an array of DMs\n   */\n  async listDms(\n    options?: Omit<SafeListConversationsOptions, \"conversation_type\">,\n  ) {\n    const conversations = await this.#client.sendMessage(\n      \"conversations.listDms\",\n      {\n        options,\n      },\n    );\n\n    return conversations.map(\n      (conversation) => new Dm(this.#client, conversation.id, conversation),\n    );\n  }\n\n  /**\n   * Creates a new group without syncing to the network\n   *\n   * @param options - Optional group creation options\n   * @returns Promise that resolves with the new group\n   */\n  async newGroupOptimistic(options?: SafeCreateGroupOptions) {\n    const conversation = await this.#client.sendMessage(\n      \"conversations.newGroupOptimistic\",\n      {\n        options,\n      },\n    );\n\n    return new Group(this.#client, conversation.id, conversation);\n  }\n\n  /**\n   * Creates a new group conversation with the specified identifiers\n   *\n   * @param identifiers - Array of identifiers for group members\n   * @param options - Optional group creation options\n   * @returns Promise that resolves with the new group\n   */\n  async newGroupWithIdentifiers(\n    identifiers: Identifier[],\n    options?: SafeCreateGroupOptions,\n  ) {\n    const conversation = await this.#client.sendMessage(\n      \"conversations.newGroupWithIdentifiers\",\n      {\n        identifiers,\n        options,\n      },\n    );\n\n    return new Group(this.#client, conversation.id, conversation);\n  }\n\n  /**\n   * Creates a new group conversation with the specified inbox IDs\n   *\n   * @param inboxIds - Array of inbox IDs for group members\n   * @param options - Optional group creation options\n   * @returns Promise that resolves with the new group\n   */\n  async newGroup(inboxIds: string[], options?: SafeCreateGroupOptions) {\n    const conversation = await this.#client.sendMessage(\n      \"conversations.newGroup\",\n      {\n        inboxIds,\n        options,\n      },\n    );\n\n    return new Group(this.#client, conversation.id, conversation);\n  }\n\n  /**\n   * Creates a new DM conversation with the specified identifier\n   *\n   * @param identifier - Identifier for the DM recipient\n   * @param options - Optional DM creation options\n   * @returns Promise that resolves with the new DM\n   */\n  async newDmWithIdentifier(\n    identifier: Identifier,\n    options?: SafeCreateDmOptions,\n  ) {\n    const conversation = await this.#client.sendMessage(\n      \"conversations.newDmWithIdentifier\",\n      {\n        identifier,\n        options,\n      },\n    );\n\n    return new Dm(this.#client, conversation.id, conversation);\n  }\n\n  /**\n   * Creates a new DM conversation with the specified inbox ID\n   *\n   * @param inboxId - Inbox ID for the DM recipient\n   * @param options - Optional DM creation options\n   * @returns Promise that resolves with the new DM\n   */\n  async newDm(inboxId: string, options?: SafeCreateDmOptions) {\n    const conversation = await this.#client.sendMessage(\"conversations.newDm\", {\n      inboxId,\n      options,\n    });\n\n    return new Dm(this.#client, conversation.id, conversation);\n  }\n\n  /**\n   * Retrieves HMAC keys for all conversations\n   *\n   * @returns Promise that resolves with the HMAC keys for all conversations\n   */\n  async getHmacKeys() {\n    return this.#client.sendMessage(\"conversations.getHmacKeys\", undefined);\n  }\n\n  /**\n   * Creates a stream for new conversations\n   *\n   * @param options - Optional stream options\n   * @param options.conversationType - Optional type to filter conversations\n   * @returns Stream instance for new conversations\n   */\n  async stream<\n    T extends Group<ContentTypes> | Dm<ContentTypes> =\n      | Group<ContentTypes>\n      | Dm<ContentTypes>,\n  >(\n    options?: StreamOptions<SafeConversation, T> & {\n      conversationType?: ConversationType;\n    },\n  ) {\n    const stream = async (\n      callback: StreamCallback<SafeConversation>,\n      onFail: () => void,\n    ) => {\n      const streamId = v4();\n      // sync the conversation\n      await this.sync();\n      // start the stream\n      await this.#client.sendMessage(\"conversations.stream\", {\n        streamId,\n        conversationType: options?.conversationType,\n      });\n      // handle stream messages\n      return this.#client.handleStreamMessage<SafeConversation, T>(\n        streamId,\n        callback,\n        {\n          ...options,\n          onFail,\n        },\n      );\n    };\n    const convertConversation = (value: SafeConversation) => {\n      return value.metadata.conversationType === \"group\"\n        ? (new Group(this.#client, value.id, value) as T)\n        : (new Dm(this.#client, value.id, value) as T);\n    };\n\n    return createStream(stream, convertConversation, options);\n  }\n\n  /**\n   * Creates a stream for new group conversations\n   *\n   * @param options - Optional stream options\n   * @returns Stream instance for new group conversations\n   */\n  async streamGroups(\n    options?: StreamOptions<SafeConversation, Group<ContentTypes>>,\n  ) {\n    return this.stream({\n      ...options,\n      conversationType: ConversationType.Group,\n    });\n  }\n\n  /**\n   * Creates a stream for new DM conversations\n   *\n   * @param options - Optional stream options\n   * @returns Stream instance for new DM conversations\n   */\n  async streamDms(options?: StreamOptions<SafeConversation, Dm<ContentTypes>>) {\n    return this.stream({\n      ...options,\n      conversationType: ConversationType.Dm,\n    });\n  }\n\n  /**\n   * Creates a stream for all new messages\n   *\n   * @param options - Optional stream options\n   * @param options.conversationType - Optional conversation type to filter messages\n   * @param options.consentStates - Optional consent states to filter messages\n   * @returns Stream instance for new messages\n   */\n  async streamAllMessages(\n    options?: StreamOptions<SafeMessage, DecodedMessage<ContentTypes>> & {\n      conversationType?: ConversationType;\n      consentStates?: ConsentState[];\n    },\n  ) {\n    const stream = async (\n      callback: StreamCallback<SafeMessage>,\n      onFail: () => void,\n    ) => {\n      const streamId = v4();\n      // sync the conversation\n      await this.sync();\n      // start the stream\n      await this.#client.sendMessage(\"conversations.streamAllMessages\", {\n        streamId,\n        conversationType: options?.conversationType,\n        consentStates: options?.consentStates,\n      });\n      // handle stream messages\n      return this.#client.handleStreamMessage<\n        SafeMessage,\n        DecodedMessage<ContentTypes>\n      >(streamId, callback, {\n        ...options,\n        onFail,\n      });\n    };\n    const convertMessage = (value: SafeMessage) => {\n      return new DecodedMessage(this.#client, value);\n    };\n\n    return createStream(stream, convertMessage, options);\n  }\n\n  /**\n   * Creates a stream for all new group messages\n   *\n   * @param options - Optional stream options\n   * @param options.consentStates - Optional consent states to filter messages\n   * @returns Stream instance for new group messages\n   */\n  async streamAllGroupMessages(\n    options?: StreamOptions<SafeMessage, DecodedMessage<ContentTypes>> & {\n      consentStates?: ConsentState[];\n    },\n  ) {\n    return this.streamAllMessages({\n      ...options,\n      conversationType: ConversationType.Group,\n    });\n  }\n\n  /**\n   * Creates a stream for all new DM messages\n   *\n   * @param options - Optional stream options\n   * @param options.consentStates - Optional consent states to filter messages\n   * @returns Stream instance for new DM messages\n   */\n  async streamAllDmMessages(\n    options?: StreamOptions<SafeMessage, DecodedMessage<ContentTypes>> & {\n      consentStates?: ConsentState[];\n    },\n  ) {\n    return this.streamAllMessages({\n      ...options,\n      conversationType: ConversationType.Dm,\n    });\n  }\n}\n",
      "size_bytes": 12234
    },
    "sdks/node-sdk/src/DecodedMessage.ts": {
      "content": "import { ContentTypeId } from \"@xmtp/content-type-primitives\";\nimport {\n  DeliveryStatus,\n  GroupMessageKind,\n  type Message,\n} from \"@xmtp/node-bindings\";\nimport type { Client } from \"@/Client\";\nimport { nsToDate } from \"@/utils/date\";\n\nexport type MessageKind = \"application\" | \"membership_change\";\nexport type MessageDeliveryStatus = \"unpublished\" | \"published\" | \"failed\";\n\n/**\n * Represents a decoded XMTP message\n *\n * This class transforms network messages into a structured format with\n * content decoding.\n *\n * @class\n * @property {any} content - The decoded content of the message\n * @property {ContentTypeId} contentType - The content type of the message content\n * @property {string} conversationId - Unique identifier for the conversation\n * @property {MessageDeliveryStatus} deliveryStatus - Current delivery status of the message (\"unpublished\" | \"published\" | \"failed\")\n * @property {string} [fallback] - Optional fallback text for the message\n * @property {number} [compression] - Optional compression level applied to the message\n * @property {string} id - Unique identifier for the message\n * @property {MessageKind} kind - Type of message (\"application\" | \"membership_change\")\n * @property {Record<string, string>} parameters - Additional parameters associated with the message\n * @property {string} senderInboxId - Identifier for the sender's inbox\n * @property {Date} sentAt - Timestamp when the message was sent\n * @property {number} sentAtNs - Timestamp when the message was sent (in nanoseconds)\n */\nexport class DecodedMessage<ContentTypes = unknown> {\n  #client: Client<ContentTypes>;\n  content: ContentTypes | undefined;\n  contentType: ContentTypeId | undefined;\n  conversationId: string;\n  deliveryStatus: MessageDeliveryStatus;\n  fallback?: string;\n  compression?: number;\n  id: string;\n  kind: MessageKind;\n  parameters: Record<string, string>;\n  senderInboxId: string;\n  sentAt: Date;\n  sentAtNs: number;\n\n  constructor(client: Client<ContentTypes>, message: Message) {\n    this.#client = client;\n    this.id = message.id;\n    this.sentAtNs = message.sentAtNs;\n    this.sentAt = nsToDate(message.sentAtNs);\n    this.conversationId = message.convoId;\n    this.senderInboxId = message.senderInboxId;\n\n    switch (message.kind) {\n      case GroupMessageKind.Application:\n        this.kind = \"application\";\n        break;\n      case GroupMessageKind.MembershipChange:\n        this.kind = \"membership_change\";\n        break;\n      // no default\n    }\n\n    switch (message.deliveryStatus) {\n      case DeliveryStatus.Unpublished:\n        this.deliveryStatus = \"unpublished\";\n        break;\n      case DeliveryStatus.Published:\n        this.deliveryStatus = \"published\";\n        break;\n      case DeliveryStatus.Failed:\n        this.deliveryStatus = \"failed\";\n        break;\n      // no default\n    }\n\n    this.contentType = message.content.type\n      ? new ContentTypeId(message.content.type)\n      : undefined;\n    this.parameters = message.content.parameters;\n    this.fallback = message.content.fallback;\n    this.compression = message.content.compression;\n    this.content = undefined;\n\n    if (this.contentType) {\n      try {\n        this.content = this.#client.decodeContent<ContentTypes>(\n          message,\n          this.contentType,\n        );\n      } catch {\n        this.content = undefined;\n      }\n    }\n  }\n}\n",
      "size_bytes": 3351
    },
    "sdks/browser-sdk/src/Client.ts": {
      "content": "import {\n  ContentTypeGroupUpdated,\n  GroupUpdatedCodec,\n} from \"@xmtp/content-type-group-updated\";\nimport type {\n  ContentCodec,\n  ContentTypeId,\n} from \"@xmtp/content-type-primitives\";\nimport { TextCodec } from \"@xmtp/content-type-text\";\nimport { GroupMessageKind, type Identifier } from \"@xmtp/wasm-bindings\";\nimport { v4 } from \"uuid\";\nimport { ClientWorkerClass } from \"@/ClientWorkerClass\";\nimport { Conversations } from \"@/Conversations\";\nimport { DebugInformation } from \"@/DebugInformation\";\nimport { Preferences } from \"@/Preferences\";\nimport type { ClientOptions, XmtpEnv } from \"@/types/options\";\nimport { Utils } from \"@/Utils\";\nimport {\n  fromSafeEncodedContent,\n  toSafeEncodedContent,\n  type SafeMessage,\n} from \"@/utils/conversions\";\nimport {\n  AccountAlreadyAssociatedError,\n  CodecNotFoundError,\n  InboxReassignError,\n  InvalidGroupMembershipChangeError,\n  SignerUnavailableError,\n} from \"@/utils/errors\";\nimport { toSafeSigner, type SafeSigner, type Signer } from \"@/utils/signer\";\n\nexport type ExtractCodecContentTypes<C extends ContentCodec[] = []> =\n  [...C, GroupUpdatedCodec, TextCodec][number] extends ContentCodec<infer T>\n    ? T\n    : never;\n\n/**\n * Client for interacting with the XMTP network\n */\nexport class Client<\n  ContentTypes = ExtractCodecContentTypes,\n> extends ClientWorkerClass {\n  #codecs: Map<string, ContentCodec>;\n  #conversations: Conversations<ContentTypes>;\n  #debugInformation: DebugInformation<ContentTypes>;\n  #identifier?: Identifier;\n  #inboxId: string | undefined;\n  #installationId: string | undefined;\n  #installationIdBytes: Uint8Array | undefined;\n  #isReady = false;\n  #preferences: Preferences<ContentTypes>;\n  #signer?: Signer;\n  #options?: ClientOptions;\n\n  /**\n   * Creates a new XMTP client instance\n   *\n   * This class is not intended to be initialized directly.\n   * Use `Client.create` or `Client.build` instead.\n   *\n   * @param options - Optional configuration for the client\n   */\n  constructor(options?: ClientOptions) {\n    const worker = new Worker(new URL(\"./workers/client\", import.meta.url), {\n      type: \"module\",\n    });\n    super(\n      worker,\n      options?.loggingLevel !== undefined && options.loggingLevel !== \"off\",\n    );\n    this.#options = options;\n    this.#conversations = new Conversations(this);\n    this.#debugInformation = new DebugInformation(this);\n    this.#preferences = new Preferences(this);\n    const codecs = [\n      new GroupUpdatedCodec(),\n      new TextCodec(),\n      ...(options?.codecs ?? []),\n    ];\n    this.#codecs = new Map(\n      codecs.map((codec) => [codec.contentType.toString(), codec]),\n    );\n  }\n\n  /**\n   * Initializes the client with the provided identifier\n   *\n   * This is not meant to be called directly.\n   * Use `Client.create` or `Client.build` instead.\n   *\n   * @param identifier - The identifier to initialize the client with\n   */\n  async init(identifier: Identifier) {\n    const result = await this.sendMessage(\"client.init\", {\n      identifier,\n      options: this.#options,\n    });\n    this.#identifier = identifier;\n    this.#inboxId = result.inboxId;\n    this.#installationId = result.installationId;\n    this.#installationIdBytes = result.installationIdBytes;\n    this.#isReady = true;\n  }\n\n  /**\n   * Creates a new client instance with a signer\n   *\n   * @param signer - The signer to use for authentication\n   * @param options - Optional configuration for the client\n   * @returns A new client instance\n   */\n  static async create<ContentCodecs extends ContentCodec[] = []>(\n    signer: Signer,\n    options?: Omit<ClientOptions, \"codecs\"> & {\n      codecs?: ContentCodecs;\n    },\n  ) {\n    const client = new Client<ExtractCodecContentTypes<ContentCodecs>>(options);\n    client.#signer = signer;\n\n    await client.init(await signer.getIdentifier());\n\n    if (!options?.disableAutoRegister) {\n      await client.register();\n    }\n\n    return client;\n  }\n\n  /**\n   * Creates a new client instance with an identifier\n   *\n   * Clients created with this method must already be registered.\n   * Any methods called that require a signer will throw an error.\n   *\n   * @param identifier - The identifier to use\n   * @param options - Optional configuration for the client\n   * @returns A new client instance\n   */\n  static async build<ContentCodecs extends ContentCodec[] = []>(\n    identifier: Identifier,\n    options?: Omit<ClientOptions, \"codecs\"> & {\n      codecs?: ContentCodecs;\n    },\n  ) {\n    const client = new Client<ExtractCodecContentTypes<ContentCodecs>>({\n      ...options,\n      disableAutoRegister: true,\n    });\n    await client.init(identifier);\n    return client;\n  }\n\n  /**\n   * Gets the client options\n   */\n  get options() {\n    return this.#options;\n  }\n\n  /**\n   * Gets the signer associated with this client\n   */\n  get signer() {\n    return this.#signer;\n  }\n\n  /**\n   * Gets whether the client has been initialized\n   */\n  get isReady() {\n    return this.#isReady;\n  }\n\n  /**\n   * Gets the inbox ID associated with this client\n   */\n  get inboxId() {\n    return this.#inboxId;\n  }\n\n  /**\n   * Gets the account identifier for this client\n   */\n  get accountIdentifier() {\n    return this.#identifier;\n  }\n\n  /**\n   * Gets the installation ID for this client\n   */\n  get installationId() {\n    return this.#installationId;\n  }\n\n  /**\n   * Gets the installation ID bytes for this client\n   */\n  get installationIdBytes() {\n    return this.#installationIdBytes;\n  }\n\n  /**\n   * Gets the conversations manager for this client\n   */\n  get conversations() {\n    return this.#conversations;\n  }\n\n  /**\n   * Gets the debug information helpers for this client\n   */\n  get debugInformation() {\n    return this.#debugInformation;\n  }\n\n  /**\n   * Gets the preferences manager for this client\n   */\n  get preferences() {\n    return this.#preferences;\n  }\n\n  /**\n   * Creates signature text for creating a new inbox\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `register` method instead.\n   *\n   * @returns The signature text and signature request ID\n   */\n  async unsafe_createInboxSignatureText() {\n    return this.sendMessage(\"client.createInboxSignatureText\", {\n      signatureRequestId: v4(),\n    });\n  }\n\n  /**\n   * Creates signature text for adding a new account to the client's inbox\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `unsafe_addAccount` method instead.\n   *\n   * @param newIdentifier - The identifier of the new account\n   * @param allowInboxReassign - Whether to allow inbox reassignment\n   * @throws {InboxReassignError} if `allowInboxReassign` is false\n   * @returns The signature text and signature request ID\n   */\n  async unsafe_addAccountSignatureText(\n    newIdentifier: Identifier,\n    allowInboxReassign: boolean = false,\n  ) {\n    if (!allowInboxReassign) {\n      throw new InboxReassignError();\n    }\n\n    return this.sendMessage(\"client.addAccountSignatureText\", {\n      newIdentifier,\n      signatureRequestId: v4(),\n    });\n  }\n\n  /**\n   * Creates signature text for removing an account from the client's inbox\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `removeAccount` method instead.\n   *\n   * @param identifier - The identifier of the account to remove\n   * @returns The signature text and signature request ID\n   */\n  async unsafe_removeAccountSignatureText(identifier: Identifier) {\n    return this.sendMessage(\"client.removeAccountSignatureText\", {\n      identifier,\n      signatureRequestId: v4(),\n    });\n  }\n\n  /**\n   * Creates signature text for revoking all other installations of the\n   * client's inbox\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `revokeAllOtherInstallations` method instead.\n   *\n   * @returns The signature text and signature request ID\n   */\n  async unsafe_revokeAllOtherInstallationsSignatureText() {\n    return this.sendMessage(\"client.revokeAllOtherInstallationsSignatureText\", {\n      signatureRequestId: v4(),\n    });\n  }\n\n  /**\n   * Creates signature text for revoking specific installations of the\n   * client's inbox\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `revokeInstallations` method instead.\n   *\n   * @param installationIds - The installation IDs to revoke\n   * @returns The signature text and signature request ID\n   */\n  async unsafe_revokeInstallationsSignatureText(installationIds: Uint8Array[]) {\n    return this.sendMessage(\"client.revokeInstallationsSignatureText\", {\n      installationIds,\n      signatureRequestId: v4(),\n    });\n  }\n\n  /**\n   * Creates signature text for changing the recovery identifier for this\n   * client's inbox\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `changeRecoveryIdentifier` method instead.\n   *\n   * @param identifier - The new recovery identifier\n   * @returns The signature text and signature request ID\n   */\n  async unsafe_changeRecoveryIdentifierSignatureText(identifier: Identifier) {\n    return this.sendMessage(\"client.changeRecoveryIdentifierSignatureText\", {\n      identifier,\n      signatureRequestId: v4(),\n    });\n  }\n\n  /**\n   * Applies a signature request to the client\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `register`, `unsafe_addAccount`,\n   * `removeAccount`, `revokeAllOtherInstallations`, `revokeInstallations`,\n   * or `changeRecoveryIdentifier` method instead.\n   *\n   * @param signer - The signer to use\n   * @param signatureRequestId - The ID of the signature request to apply\n   */\n  async unsafe_applySignatureRequest(\n    signer: SafeSigner,\n    signatureRequestId: string,\n  ) {\n    return this.sendMessage(\"client.applySignatureRequest\", {\n      signer,\n      signatureRequestId,\n    });\n  }\n\n  /**\n   * Registers the client with the XMTP network\n   *\n   * Requires a signer, use `Client.create` to create a client with a signer.\n   *\n   * @throws {SignerUnavailableError} if no signer is available\n   */\n  async register() {\n    if (!this.#signer) {\n      throw new SignerUnavailableError();\n    }\n\n    const { signatureText, signatureRequestId } =\n      await this.unsafe_createInboxSignatureText();\n\n    // if the signature text or request ID is not available, don't register\n    if (!signatureText || !signatureRequestId) {\n      return;\n    }\n\n    const signature = await this.#signer.signMessage(signatureText);\n    const signer = await toSafeSigner(this.#signer, signature);\n\n    return this.sendMessage(\"client.registerIdentity\", {\n      signer,\n      signatureRequestId,\n    });\n  }\n\n  /**\n   * Adds a new account to the client inbox\n   *\n   * WARNING: This function should be used with caution. Adding a wallet already\n   * associated with an inbox ID will cause the wallet to lose access to\n   * that inbox.\n   *\n   * The `allowInboxReassign` parameter must be true to reassign an inbox\n   * already associated with a different account.\n   *\n   * Requires a signer, use `Client.create` to create a client with a signer.\n   *\n   * @param newAccountSigner - The signer for the new account\n   * @param allowInboxReassign - Whether to allow inbox reassignment\n   * @throws {SignerUnavailableError} if no signer is available\n   * @throws {InboxReassignError} if `allowInboxReassign` is false\n   * @throws {AccountAlreadyAssociatedError} if the account is already associated with an inbox ID\n   */\n  async unsafe_addAccount(\n    newAccountSigner: Signer,\n    allowInboxReassign: boolean = false,\n  ) {\n    if (!this.#signer) {\n      throw new SignerUnavailableError();\n    }\n\n    if (!allowInboxReassign) {\n      throw new InboxReassignError();\n    }\n\n    // check for existing inbox id\n    const existingInboxId = await this.findInboxIdByIdentifier(\n      await newAccountSigner.getIdentifier(),\n    );\n\n    if (existingInboxId) {\n      throw new AccountAlreadyAssociatedError(existingInboxId);\n    }\n\n    const { signatureText, signatureRequestId } =\n      await this.unsafe_addAccountSignatureText(\n        await newAccountSigner.getIdentifier(),\n        true,\n      );\n    const signature = await newAccountSigner.signMessage(signatureText);\n    const signer = await toSafeSigner(newAccountSigner, signature);\n    return this.sendMessage(\"client.addAccount\", {\n      identifier: signer.identifier,\n      signer,\n      signatureRequestId,\n    });\n  }\n\n  /**\n   * Removes an account from the client's inbox\n   *\n   * Requires a signer, use `Client.create` to create a client with a signer.\n   *\n   * @param accountIdentifier - The identifier of the account to remove\n   * @throws {SignerUnavailableError} if no signer is available\n   */\n  async removeAccount(identifier: Identifier) {\n    if (!this.#signer) {\n      throw new SignerUnavailableError();\n    }\n\n    const { signatureText, signatureRequestId } =\n      await this.unsafe_removeAccountSignatureText(identifier);\n    const signature = await this.#signer.signMessage(signatureText);\n    const signer = await toSafeSigner(this.#signer, signature);\n\n    return this.sendMessage(\"client.removeAccount\", {\n      identifier,\n      signer,\n      signatureRequestId,\n    });\n  }\n\n  /**\n   * Revokes all other installations of the client's inbox\n   *\n   * Requires a signer, use `Client.create` to create a client with a signer.\n   *\n   * @throws {SignerUnavailableError} if no signer is available\n   */\n  async revokeAllOtherInstallations() {\n    if (!this.#signer) {\n      throw new SignerUnavailableError();\n    }\n\n    const { signatureText, signatureRequestId } =\n      await this.unsafe_revokeAllOtherInstallationsSignatureText();\n    const signature = await this.#signer.signMessage(signatureText);\n    const signer = await toSafeSigner(this.#signer, signature);\n\n    return this.sendMessage(\"client.revokeAllOtherInstallations\", {\n      signer,\n      signatureRequestId,\n    });\n  }\n\n  /**\n   * Revokes specific installations of the client's inbox\n   *\n   * Requires a signer, use `Client.create` to create a client with a signer.\n   *\n   * @param installationIds - The installation IDs to revoke\n   * @throws {SignerUnavailableError} if no signer is available\n   */\n  async revokeInstallations(installationIds: Uint8Array[]) {\n    if (!this.#signer) {\n      throw new SignerUnavailableError();\n    }\n\n    const { signatureText, signatureRequestId } =\n      await this.unsafe_revokeInstallationsSignatureText(installationIds);\n    const signature = await this.#signer.signMessage(signatureText);\n    const signer = await toSafeSigner(this.#signer, signature);\n\n    return this.sendMessage(\"client.revokeInstallations\", {\n      installationIds,\n      signer,\n      signatureRequestId,\n    });\n  }\n\n  /**\n   * Revokes specific installations of the client's inbox without a client\n   *\n   * @param env - The environment to use\n   * @param signer - The signer to use\n   * @param inboxId - The inbox ID to revoke installations for\n   * @param installationIds - The installation IDs to revoke\n   */\n  static async revokeInstallations(\n    signer: Signer,\n    inboxId: string,\n    installationIds: Uint8Array[],\n    env?: XmtpEnv,\n    enableLogging?: boolean,\n  ) {\n    const utils = new Utils(enableLogging);\n    await utils.init();\n    await utils.revokeInstallations(signer, inboxId, installationIds, env);\n    utils.close();\n  }\n\n  /**\n   * Gets the inbox state for the specified inbox IDs without a client\n   *\n   * @param inboxIds - The inbox IDs to get the state for\n   * @param env - The environment to use\n   * @returns The inbox state for the specified inbox IDs\n   */\n  static async inboxStateFromInboxIds(\n    inboxIds: string[],\n    env?: XmtpEnv,\n    enableLogging?: boolean,\n  ) {\n    const utils = new Utils(enableLogging);\n    await utils.init();\n    const result = await utils.inboxStateFromInboxIds(inboxIds, env);\n    utils.close();\n    return result;\n  }\n\n  /**\n   * Changes the recovery identifier for the client's inbox\n   *\n   * Requires a signer, use `Client.create` to create a client with a signer.\n   *\n   * @param identifier - The new recovery identifier\n   * @throws {SignerUnavailableError} if no signer is available\n   */\n  async changeRecoveryIdentifier(identifier: Identifier) {\n    if (!this.#signer) {\n      throw new SignerUnavailableError();\n    }\n\n    const { signatureText, signatureRequestId } =\n      await this.unsafe_changeRecoveryIdentifierSignatureText(identifier);\n    const signature = await this.#signer.signMessage(signatureText);\n    const signer = await toSafeSigner(this.#signer, signature);\n\n    return this.sendMessage(\"client.changeRecoveryIdentifier\", {\n      identifier,\n      signer,\n      signatureRequestId,\n    });\n  }\n\n  /**\n   * Checks if the client is registered with the XMTP network\n   *\n   * @returns Whether the client is registered\n   */\n  async isRegistered() {\n    return this.sendMessage(\"client.isRegistered\", undefined);\n  }\n\n  /**\n   * Checks if the client can message the specified identifiers\n   *\n   * @param identifiers - The identifiers to check\n   * @returns Whether the client can message the identifiers\n   */\n  async canMessage(identifiers: Identifier[]) {\n    return this.sendMessage(\"client.canMessage\", { identifiers });\n  }\n\n  /**\n   * Checks if the specified identifiers can be messaged\n   *\n   * @param identifiers - The identifiers to check\n   * @param env - Optional XMTP environment\n   * @returns Map of identifiers to whether they can be messaged\n   */\n  static async canMessage(identifiers: Identifier[], env?: XmtpEnv) {\n    const canMessageMap = new Map<string, boolean>();\n    const utils = new Utils();\n    for (const identifier of identifiers) {\n      const inboxId = await utils.getInboxIdForIdentifier(identifier, env);\n      canMessageMap.set(\n        identifier.identifier.toLowerCase(),\n        inboxId !== undefined,\n      );\n    }\n    utils.close();\n    return canMessageMap;\n  }\n\n  /**\n   * Finds the inbox ID for a given identifier\n   *\n   * @param identifier - The identifier to look up\n   * @returns The inbox ID, if found\n   */\n  async findInboxIdByIdentifier(identifier: Identifier) {\n    return this.sendMessage(\"client.findInboxIdByIdentifier\", { identifier });\n  }\n\n  /**\n   * Gets the codec for a given content type\n   *\n   * @param contentType - The content type to get the codec for\n   * @returns The codec, if found\n   */\n  codecFor<ContentType = unknown>(contentType: ContentTypeId) {\n    return this.#codecs.get(contentType.toString()) as\n      | ContentCodec<ContentType>\n      | undefined;\n  }\n\n  /**\n   * Encodes content for a given content type\n   *\n   * @param content - The content to encode\n   * @param contentType - The content type to encode for\n   * @returns The encoded content\n   * @throws {CodecNotFoundError} if no codec is found for the content type\n   */\n  encodeContent(content: ContentTypes, contentType: ContentTypeId) {\n    const codec = this.codecFor(contentType);\n    if (!codec) {\n      throw new CodecNotFoundError(contentType);\n    }\n    const encoded = codec.encode(content, this);\n    const fallback = codec.fallback(content);\n    if (fallback) {\n      encoded.fallback = fallback;\n    }\n    return toSafeEncodedContent(encoded);\n  }\n\n  /**\n   * Decodes a message for a given content type\n   *\n   * @param message - The message to decode\n   * @param contentType - The content type to decode for\n   * @returns The decoded content\n   * @throws {CodecNotFoundError} if no codec is found for the content type\n   * @throws {InvalidGroupMembershipChangeError} if the message is an invalid group membership change\n   */\n  decodeContent<ContentType = unknown>(\n    message: SafeMessage,\n    contentType: ContentTypeId,\n  ) {\n    const codec = this.codecFor<ContentType>(contentType);\n    if (!codec) {\n      throw new CodecNotFoundError(contentType);\n    }\n\n    // throw an error if there's an invalid group membership change message\n    if (\n      contentType.sameAs(ContentTypeGroupUpdated) &&\n      message.kind !== GroupMessageKind.MembershipChange\n    ) {\n      throw new InvalidGroupMembershipChangeError(message.id);\n    }\n\n    const encodedContent = fromSafeEncodedContent(message.content);\n\n    return codec.decode(encodedContent, this);\n  }\n\n  /**\n   * Signs a message with the installation key\n   *\n   * @param signatureText - The text to sign\n   * @returns The signature\n   */\n  signWithInstallationKey(signatureText: string) {\n    return this.sendMessage(\"client.signWithInstallationKey\", {\n      signatureText,\n    });\n  }\n\n  /**\n   * Verifies a signature was made with the installation key\n   *\n   * @param signatureText - The text that was signed\n   * @param signatureBytes - The signature bytes to verify\n   * @returns Whether the signature is valid\n   */\n  verifySignedWithInstallationKey(\n    signatureText: string,\n    signatureBytes: Uint8Array,\n  ) {\n    return this.sendMessage(\"client.verifySignedWithInstallationKey\", {\n      signatureText,\n      signatureBytes,\n    });\n  }\n\n  /**\n   * Verifies a signature was made with a public key\n   *\n   * @param signatureText - The text that was signed\n   * @param signatureBytes - The signature bytes to verify\n   * @param publicKey - The public key to verify against\n   * @returns Whether the signature is valid\n   */\n  verifySignedWithPublicKey(\n    signatureText: string,\n    signatureBytes: Uint8Array,\n    publicKey: Uint8Array,\n  ) {\n    return this.sendMessage(\"client.verifySignedWithPublicKey\", {\n      signatureText,\n      signatureBytes,\n      publicKey,\n    });\n  }\n\n  /**\n   * Gets the key package statuses for the specified installation IDs\n   *\n   * @param installationIds - The installation IDs to check\n   * @returns The key package statuses\n   */\n  async getKeyPackageStatusesForInstallationIds(installationIds: string[]) {\n    return this.sendMessage(\"client.getKeyPackageStatusesForInstallationIds\", {\n      installationIds,\n    });\n  }\n}\n",
      "size_bytes": 22903
    },
    "sdks/agent-sdk/src/index.ts": {
      "content": "export {\n  ConsentEntityType,\n  ConsentState,\n  ConversationType,\n  DeliveryStatus,\n  GroupMember,\n  GroupMembershipState,\n  GroupMessageKind,\n  GroupMetadata,\n  GroupPermissions,\n  GroupPermissionsOptions,\n  IdentifierKind,\n  LogLevel,\n  MetadataField,\n  PermissionLevel,\n  PermissionPolicy,\n  PermissionUpdateType,\n  SignatureRequestHandle,\n  SortDirection,\n} from \"@xmtp/node-sdk\";\nexport type * from \"@xmtp/node-sdk\";\n// Agent SDK\nexport * from \"./core/index.js\";\n",
      "size_bytes": 468
    },
    "apps/xmtp.chat/src/components/Conversations/CreateGroupModal.tsx": {
      "content": "import { Accordion, Badge, Button, Group, Stack, Text } from \"@mantine/core\";\nimport { GroupPermissionsOptions } from \"@xmtp/browser-sdk\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport { useNavigate } from \"react-router\";\nimport type { PendingMember } from \"@/components/Conversation/AddMembers\";\nimport { Members } from \"@/components/Conversation/Members\";\nimport { Metadata } from \"@/components/Conversation/Metadata\";\nimport {\n  defaultPolicySet,\n  Permissions,\n} from \"@/components/Conversation/Permissions\";\nimport { Modal } from \"@/components/Modal\";\nimport { isValidEthereumAddress, isValidInboxId } from \"@/helpers/strings\";\nimport { useCollapsedMediaQuery } from \"@/hooks/useCollapsedMediaQuery\";\nimport { useConversations } from \"@/hooks/useConversations\";\nimport { ContentLayout } from \"@/layouts/ContentLayout\";\nimport { useActions } from \"@/stores/inbox/hooks\";\nimport type { PolicySet } from \"@/types\";\n\nconst permissionsPolicyValue = (policy: GroupPermissionsOptions) => {\n  switch (policy) {\n    case GroupPermissionsOptions.Default:\n      return \"Default\";\n    case GroupPermissionsOptions.AdminOnly:\n      return \"Admin only\";\n    case GroupPermissionsOptions.CustomPolicy:\n      return \"Custom policy\";\n  }\n};\n\nexport const CreateGroupModal: React.FC = () => {\n  const { newGroup } = useConversations();\n  const { addConversation } = useActions();\n  const [loading, setLoading] = useState(false);\n  const [name, setName] = useState(\"\");\n  const [description, setDescription] = useState(\"\");\n  const [imageUrlSquare, setImageUrlSquare] = useState(\"\");\n  const [addedMembers, setAddedMembers] = useState<PendingMember[]>([]);\n  const [permissionsPolicy, setPermissionsPolicy] =\n    useState<GroupPermissionsOptions>(GroupPermissionsOptions.Default);\n  const [policySet, setPolicySet] = useState<PolicySet>(defaultPolicySet);\n  const navigate = useNavigate();\n  const fullScreen = useCollapsedMediaQuery();\n  const contentHeight = fullScreen ? \"auto\" : 500;\n\n  const handleClose = useCallback(() => {\n    void navigate(-1);\n  }, [navigate]);\n\n  const handleCreate = async () => {\n    setLoading(true);\n\n    try {\n      const addedMemberInboxIds = addedMembers\n        .filter((member) => isValidInboxId(member.inboxId))\n        .map((member) => member.inboxId);\n      const conversation = await newGroup(addedMemberInboxIds, {\n        name,\n        description,\n        imageUrlSquare,\n        permissions: permissionsPolicy,\n        customPermissionPolicySet:\n          permissionsPolicy === GroupPermissionsOptions.CustomPolicy\n            ? policySet\n            : undefined,\n      });\n\n      const addedMemberAddresses = addedMembers\n        .filter((member) => isValidEthereumAddress(member.address))\n        .map((member) => member.address);\n      if (addedMemberAddresses.length > 0) {\n        await conversation.addMembersByIdentifiers(\n          addedMemberAddresses.map((address) => ({\n            identifier: address.toLowerCase(),\n            identifierKind: \"Ethereum\",\n          })),\n        );\n      }\n\n      // ensure conversation is added to store so navigation works\n      await addConversation(conversation);\n      void navigate(`/conversations/${conversation.id}`);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const footer = useMemo(() => {\n    return (\n      <Group justify=\"flex-end\" flex={1} p=\"md\">\n        <Button variant=\"default\" onClick={handleClose}>\n          Cancel\n        </Button>\n        <Button\n          variant=\"filled\"\n          disabled={loading}\n          loading={loading}\n          onClick={() => void handleCreate()}>\n          Create\n        </Button>\n      </Group>\n    );\n  }, [handleClose, handleCreate, loading]);\n\n  return (\n    <Modal\n      closeOnClickOutside={false}\n      closeOnEscape={false}\n      withCloseButton={false}\n      opened\n      centered\n      fullScreen={fullScreen}\n      onClose={handleClose}\n      size=\"600\"\n      padding={0}>\n      <ContentLayout\n        title=\"Create group\"\n        maxHeight={contentHeight}\n        footer={footer}\n        withScrollAreaPadding={false}>\n        <Stack gap=\"sm\" py=\"md\">\n          <Accordion\n            defaultValue=\"metadata\"\n            variant=\"separated\"\n            px=\"md\"\n            styles={{\n              content: {\n                padding: 0,\n              },\n            }}>\n            <Accordion.Item value=\"metadata\">\n              <Accordion.Control>\n                <Text fw=\"bold\">Metadata</Text>\n              </Accordion.Control>\n              <Accordion.Panel>\n                <Metadata\n                  onNameChange={setName}\n                  onDescriptionChange={setDescription}\n                  onImageUrlChange={setImageUrlSquare}\n                />\n              </Accordion.Panel>\n            </Accordion.Item>\n          </Accordion>\n          <Accordion\n            variant=\"separated\"\n            px=\"md\"\n            styles={{\n              content: {\n                padding: 0,\n              },\n            }}>\n            <Accordion.Item value=\"members\">\n              <Accordion.Control>\n                <Group justify=\"space-between\" align=\"center\" pr=\"md\">\n                  <Text fw=\"bold\">Members</Text>\n                  <Badge color=\"gray\" size=\"lg\">\n                    {addedMembers.length}\n                  </Badge>\n                </Group>\n              </Accordion.Control>\n              <Accordion.Panel>\n                <Members\n                  addedMembers={addedMembers}\n                  onMembersAdded={setAddedMembers}\n                  existingMembers={[]}\n                  removedMembers={[]}\n                />\n              </Accordion.Panel>\n            </Accordion.Item>\n          </Accordion>\n          <Accordion\n            variant=\"separated\"\n            px=\"md\"\n            styles={{\n              content: {\n                padding: 0,\n              },\n            }}>\n            <Accordion.Item value=\"permissions\">\n              <Accordion.Control>\n                <Group justify=\"space-between\" align=\"center\" pr=\"md\">\n                  <Text fw=\"bold\">Permissions</Text>\n                  <Badge color=\"gray\" size=\"lg\">\n                    {permissionsPolicyValue(permissionsPolicy)}\n                  </Badge>\n                </Group>\n              </Accordion.Control>\n              <Accordion.Panel>\n                <Permissions\n                  onPermissionsPolicyChange={setPermissionsPolicy}\n                  onPolicySetChange={setPolicySet}\n                />\n              </Accordion.Panel>\n            </Accordion.Item>\n          </Accordion>\n        </Stack>\n      </ContentLayout>\n    </Modal>\n  );\n};\n",
      "size_bytes": 6645
    },
    "content-types/content-type-wallet-send-calls/rollup.config.js": {
      "content": "import terser from \"@rollup/plugin-terser\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { defineConfig } from \"rollup\";\nimport { dts } from \"rollup-plugin-dts\";\n\nconst plugins = [\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n];\n\nconst external = [\"@xmtp/content-type-primitives\"];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/browser/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins: [...plugins, terser()],\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.d.ts\",\n      format: \"es\",\n    },\n    plugins: [dts()],\n  },\n]);\n",
      "size_bytes": 832
    },
    "apps/xmtp.chat/src/types.ts": {
      "content": "import type { PermissionPolicySet } from \"@xmtp/browser-sdk\";\n\ntype AnyFn = (...args: unknown[]) => unknown;\ntype ClassProperties<C> = {\n  [K in keyof C as C[K] extends AnyFn ? never : K]: C[K];\n};\n\nexport type PolicySet = ClassProperties<PermissionPolicySet>;\n",
      "size_bytes": 261
    },
    "content-types/content-type-read-receipt/rollup.config.js": {
      "content": "import terser from \"@rollup/plugin-terser\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { defineConfig } from \"rollup\";\nimport { dts } from \"rollup-plugin-dts\";\n\nconst plugins = [\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n];\n\nconst external = [\"@xmtp/content-type-primitives\"];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/browser/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins: [...plugins, terser()],\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.d.ts\",\n      format: \"es\",\n    },\n    plugins: [dts()],\n  },\n]);\n",
      "size_bytes": 832
    },
    "content-types/content-type-transaction-reference/vitest.config.ts": {
      "content": "import { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    globalSetup: [\"./vitest.setup.ts\"],\n  },\n});\n",
      "size_bytes": 155
    },
    "content-types/content-type-read-receipt/src/ReadReceipt.test.ts": {
      "content": "import { Client, IdentifierKind, type Signer } from \"@xmtp/node-sdk\";\nimport { createWalletClient, http, toBytes } from \"viem\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { sepolia } from \"viem/chains\";\nimport {\n  ContentTypeReadReceipt,\n  ReadReceiptCodec,\n  type ReadReceipt,\n} from \"./ReadReceipt\";\n\nexport const createSigner = (): Signer => {\n  const account = privateKeyToAccount(generatePrivateKey());\n  const wallet = createWalletClient({\n    account,\n    chain: sepolia,\n    transport: http(),\n  });\n  return {\n    type: \"EOA\",\n    getIdentifier: () => ({\n      identifierKind: IdentifierKind.Ethereum,\n      identifier: account.address.toLowerCase(),\n    }),\n    signMessage: async (message: string) => {\n      const signature = await wallet.signMessage({\n        message,\n      });\n      return toBytes(signature);\n    },\n  };\n};\n\ndescribe(\"ReadReceiptContentType\", () => {\n  it(\"has the right content type\", () => {\n    expect(ContentTypeReadReceipt.authorityId).toBe(\"xmtp.org\");\n    expect(ContentTypeReadReceipt.typeId).toBe(\"readReceipt\");\n    expect(ContentTypeReadReceipt.versionMajor).toBe(1);\n    expect(ContentTypeReadReceipt.versionMinor).toBe(0);\n  });\n\n  it(\"can send a read receipt\", async () => {\n    const signer1 = createSigner();\n    const client1 = await Client.create(signer1, {\n      codecs: [new ReadReceiptCodec()],\n      env: \"local\",\n    });\n\n    const signer2 = createSigner();\n    const client2 = await Client.create(signer2, {\n      codecs: [new ReadReceiptCodec()],\n      env: \"local\",\n    });\n\n    const dm = await client1.conversations.newDm(client2.inboxId);\n\n    const readReceipt: ReadReceipt = {};\n\n    await dm.send(readReceipt, ContentTypeReadReceipt);\n\n    await client2.conversations.sync();\n    const dms = client2.conversations.listDms();\n\n    expect(dms.length).toBe(1);\n\n    await dms[0].sync();\n    const messages = await dms[0].messages();\n    expect(messages.length).toBe(2);\n\n    const readReceiptMessage = messages[1];\n    expect(readReceiptMessage.contentType?.typeId).toBe(\"readReceipt\");\n  });\n\n  it(\"has a proper shouldPush value\", () => {\n    const codec = new ReadReceiptCodec();\n    expect(codec.shouldPush()).toBe(false);\n  });\n});\n",
      "size_bytes": 2235
    },
    "apps/xmtp.chat/src/icons/InjectedWallet.tsx": {
      "content": "export const InjectedWallet = () => {\n  return (\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"28\" height=\"28\" fill=\"none\">\n      <path fill=\"#fff\" d=\"M0 0h28v28H0z\" />\n      <rect width=\"20\" height=\"16\" x=\"4\" y=\"6\" fill=\"url(#a)\" rx=\"3.5\" />\n      <path\n        fill=\"#0E76FD\"\n        d=\"M16 14a3 3 0 0 1 3-3h4.4c.56 0 .84 0 1.054.109a1 1 0 0 1 .437.437C25 11.76 25 12.04 25 12.6v2.8c0 .56 0 .84-.109 1.054a1 1 0 0 1-.437.437C24.24 17 23.96 17 23.4 17H19a3 3 0 0 1-3-3Z\"\n      />\n      <circle cx=\"19\" cy=\"14\" r=\"1.25\" fill=\"#A3D7FF\" />\n      <defs>\n        <linearGradient\n          id=\"a\"\n          x1=\"14\"\n          x2=\"14\"\n          y1=\"6\"\n          y2=\"22\"\n          gradientUnits=\"userSpaceOnUse\">\n          <stop stopColor=\"#174299\" />\n          <stop offset=\"1\" stopColor=\"#001E59\" />\n        </linearGradient>\n      </defs>\n    </svg>\n  );\n};\n",
      "size_bytes": 858
    },
    "apps/xmtp.chat/src/components/Conversation/MembersList.module.css": {
      "content": ".root > * {\n  padding-top: var(--mantine-spacing-sm);\n}\n\n.root > *:last-child {\n  padding-bottom: var(--mantine-spacing-sm);\n}\n\n.hideMembers {\n  display: none;\n}\n\n@media screen and (max-width: 1280px) {\n  .header {\n    border: 1px solid var(--mantine-color-default-border);\n    border-top-right-radius: var(--mantine-radius-md);\n  }\n\n  .content {\n    border-left: 1px solid var(--mantine-color-default-border);\n    border-right: 1px solid var(--mantine-color-default-border);\n    border-bottom: 1px solid var(--mantine-color-default-border);\n    border-bottom-right-radius: var(--mantine-radius-md);\n  }\n\n  .hideMembers {\n    display: block;\n  }\n}\n",
      "size_bytes": 648
    },
    "apps/xmtp.chat/src/components/App/AccountCard.tsx": {
      "content": "import { Box, CheckIcon, Group, Text } from \"@mantine/core\";\nimport { useCallback } from \"react\";\nimport classes from \"./AccountCard.module.css\";\n\nexport type AccountCardProps = {\n  disabled?: boolean;\n  icon: React.ReactNode;\n  label: string;\n  onClick?: () => void;\n  selected?: boolean;\n};\n\nexport const AccountCard: React.FC<AccountCardProps> = ({\n  disabled,\n  icon,\n  label,\n  onClick,\n  selected,\n}) => {\n  const classNames = [classes.root];\n  if (disabled) {\n    classNames.push(classes.disabled);\n  }\n  if (selected) {\n    classNames.push(classes.selected);\n  }\n\n  const handleClick = useCallback(() => {\n    if (!disabled && !selected) {\n      onClick?.();\n    }\n  }, [disabled, selected, onClick]);\n\n  return (\n    <Group\n      align=\"center\"\n      p=\"md\"\n      gap=\"md\"\n      className={classNames.join(\" \")}\n      tabIndex={0}\n      pos=\"relative\"\n      onClick={handleClick}>\n      {icon}\n      <Text size=\"lg\" flex={1} c={disabled ? \"dimmed\" : \"inherit\"}>\n        {label}\n      </Text>\n      {selected && (\n        <Box pos=\"absolute\" right=\"var(--mantine-spacing-md)\" w={20}>\n          <CheckIcon />\n        </Box>\n      )}\n    </Group>\n  );\n};\n",
      "size_bytes": 1161
    },
    "content-types/content-type-group-updated/src/GroupUpdated.ts": {
      "content": "import {\n  ContentTypeId,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\nimport { mlsTranscriptMessages } from \"@xmtp/proto\";\n\nexport const ContentTypeGroupUpdated = new ContentTypeId({\n  authorityId: \"xmtp.org\",\n  typeId: \"group_updated\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\nexport type GroupUpdated = mlsTranscriptMessages.GroupUpdated;\n\nexport class GroupUpdatedCodec\n  implements ContentCodec<GroupUpdated, Record<string, never>>\n{\n  get contentType(): ContentTypeId {\n    return ContentTypeGroupUpdated;\n  }\n\n  encode(content: GroupUpdated) {\n    return {\n      type: this.contentType,\n      parameters: {},\n      content: mlsTranscriptMessages.GroupUpdated.encode(content).finish(),\n    };\n  }\n\n  decode(content: EncodedContent) {\n    return mlsTranscriptMessages.GroupUpdated.decode(content.content);\n  }\n\n  fallback(): undefined {\n    return undefined;\n  }\n\n  shouldPush() {\n    return false;\n  }\n}\n",
      "size_bytes": 951
    },
    "sdks/agent-sdk/src/debug.ts": {
      "content": "export * from \"./debug/index.js\";\n",
      "size_bytes": 34
    },
    "content-types/content-type-wallet-send-calls/src/WalletSendCalls.test.ts": {
      "content": "import { Client, IdentifierKind, type Signer } from \"@xmtp/node-sdk\";\nimport { createWalletClient, http, toBytes } from \"viem\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { sepolia } from \"viem/chains\";\nimport {\n  ContentTypeWalletSendCalls,\n  WalletSendCallsCodec,\n  type WalletSendCallsParams,\n} from \"./WalletSendCalls\";\n\nexport const createSigner = (): Signer => {\n  const account = privateKeyToAccount(generatePrivateKey());\n  const wallet = createWalletClient({\n    account,\n    chain: sepolia,\n    transport: http(),\n  });\n  return {\n    type: \"EOA\",\n    getIdentifier: () => ({\n      identifierKind: IdentifierKind.Ethereum,\n      identifier: account.address.toLowerCase(),\n    }),\n    signMessage: async (message: string) => {\n      const signature = await wallet.signMessage({\n        message,\n      });\n      return toBytes(signature);\n    },\n  };\n};\n\ntest(\"content type exists\", () => {\n  expect(ContentTypeWalletSendCalls.authorityId).toBe(\"xmtp.org\");\n  expect(ContentTypeWalletSendCalls.typeId).toBe(\"walletSendCalls\");\n  expect(ContentTypeWalletSendCalls.versionMajor).toBe(1);\n  expect(ContentTypeWalletSendCalls.versionMinor).toBe(0);\n});\n\ntest(\"should successfully send and receive a WalletSendCalls message\", async () => {\n  const signer1 = createSigner();\n  const client1 = await Client.create(signer1, {\n    codecs: [new WalletSendCallsCodec()],\n    env: \"local\",\n  });\n\n  const signer2 = createSigner();\n  const client2 = await Client.create(signer2, {\n    codecs: [new WalletSendCallsCodec()],\n    env: \"local\",\n  });\n\n  const dm = await client1.conversations.newDm(client2.inboxId);\n\n  const walletSendCalls: WalletSendCallsParams = {\n    version: \"1.0\",\n    from: \"0x123...abc\",\n    chainId: \"0x2105\",\n    calls: [\n      {\n        to: \"0x456...def\",\n        value: \"0x5AF3107A4000\",\n        metadata: {\n          description: \"Send 0.0001 ETH on base to 0x456...def\",\n          transactionType: \"transfer\",\n          currency: \"ETH\",\n          amount: \"100000000000000\",\n          decimals: \"18\",\n          toAddress: \"0x456...def\",\n        },\n      },\n      {\n        to: \"0x789...cba\",\n        data: \"0xdead...beef\",\n        metadata: {\n          description: \"Lend 10 USDC on base with Morpho @ 8.5% APY\",\n          transactionType: \"lend\",\n          currency: \"USDC\",\n          amount: \"10000000\",\n          decimals: \"6\",\n          platform: \"morpho\",\n          apy: \"8.5\",\n        },\n      },\n    ],\n  };\n\n  await dm.send(walletSendCalls, ContentTypeWalletSendCalls);\n\n  await client2.conversations.sync();\n  const dms = client2.conversations.listDms();\n\n  expect(dms.length).toBe(1);\n\n  await dms[0].sync();\n  const messages = await dms[0].messages();\n  expect(messages.length).toBe(2);\n\n  const message = messages[1];\n  const messageContent = message.content as WalletSendCallsParams;\n\n  expect(messageContent.version).toBe(walletSendCalls.version);\n  expect(messageContent.from).toBe(walletSendCalls.from);\n  expect(messageContent.chainId).toBe(walletSendCalls.chainId);\n});\n\ntest(\"has a proper shouldPush value\", () => {\n  const codec = new WalletSendCallsCodec();\n  expect(codec.shouldPush()).toBe(true);\n});\n",
      "size_bytes": 3183
    },
    "content-types/content-type-remote-attachment/src/RemoteAttachment.ts": {
      "content": "import * as secp from \"@noble/secp256k1\";\nimport {\n  ContentTypeId,\n  type CodecRegistry,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\nimport { content as proto } from \"@xmtp/proto\";\nimport { Ciphertext, crypto, decrypt, encrypt } from \"./encryption\";\n\nexport const ContentTypeRemoteAttachment = new ContentTypeId({\n  authorityId: \"xmtp.org\",\n  typeId: \"remoteStaticAttachment\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\nexport type EncryptedEncodedContent = {\n  digest: string;\n  salt: Uint8Array;\n  nonce: Uint8Array;\n  secret: Uint8Array;\n  payload: Uint8Array;\n};\n\nexport type RemoteAttachment = {\n  url: string;\n  contentDigest: string;\n  salt: Uint8Array;\n  nonce: Uint8Array;\n  secret: Uint8Array;\n  scheme: string;\n  contentLength: number;\n  filename: string;\n};\n\nexport type RemoteAttachmentParameters = {\n  contentDigest: string;\n  salt: string;\n  nonce: string;\n  secret: string;\n  scheme: string;\n  contentLength: string;\n  filename: string;\n};\n\nexport class RemoteAttachmentCodec\n  implements ContentCodec<RemoteAttachment, RemoteAttachmentParameters>\n{\n  static async load<T = unknown>(\n    remoteAttachment: RemoteAttachment,\n    codecRegistry: CodecRegistry,\n  ): Promise<T> {\n    const response = await fetch(remoteAttachment.url);\n    const payload = new Uint8Array(await response.arrayBuffer());\n\n    if (payload.length === 0) {\n      throw new Error(\n        `no payload for remote attachment at ${remoteAttachment.url}`,\n      );\n    }\n\n    const digestBytes = new Uint8Array(\n      await crypto.subtle.digest(\"SHA-256\", payload),\n    );\n    const digest = secp.etc.bytesToHex(digestBytes);\n\n    if (digest !== remoteAttachment.contentDigest) {\n      throw new Error(\"content digest does not match\");\n    }\n\n    const ciphertext = new Ciphertext({\n      aes256GcmHkdfSha256: {\n        hkdfSalt: remoteAttachment.salt,\n        gcmNonce: remoteAttachment.nonce,\n        payload,\n      },\n    });\n\n    const encodedContentData = await decrypt(\n      ciphertext,\n      remoteAttachment.secret,\n    );\n    const encodedContent = proto.EncodedContent.decode(encodedContentData);\n\n    if (!encodedContent.type) {\n      throw new Error(\"no content type\");\n    }\n\n    const codec = codecRegistry.codecFor(\n      new ContentTypeId(encodedContent.type),\n    );\n\n    if (!codec) {\n      throw new Error(`no codec found for ${encodedContent.type.typeId}`);\n    }\n\n    return codec.decode(encodedContent as EncodedContent, codecRegistry) as T;\n  }\n\n  static async encodeEncrypted<T>(\n    content: T,\n    codec: ContentCodec<T>,\n  ): Promise<EncryptedEncodedContent> {\n    const secret = crypto.getRandomValues(new Uint8Array(32));\n    const encodedContent = proto.EncodedContent.encode(\n      codec.encode(content, {\n        codecFor() {\n          return undefined;\n        },\n      }),\n    ).finish();\n    const ciphertext = await encrypt(encodedContent, secret);\n    const salt = ciphertext.aes256GcmHkdfSha256?.hkdfSalt;\n    const nonce = ciphertext.aes256GcmHkdfSha256?.gcmNonce;\n    const payload = ciphertext.aes256GcmHkdfSha256?.payload;\n\n    if (!salt || !nonce || !payload) {\n      throw new Error(\"missing encryption key\");\n    }\n\n    const digestBytes = new Uint8Array(\n      await crypto.subtle.digest(\"SHA-256\", payload),\n    );\n    const digest = secp.etc.bytesToHex(digestBytes);\n\n    return {\n      digest,\n      secret,\n      salt,\n      nonce,\n      payload,\n    };\n  }\n\n  get contentType(): ContentTypeId {\n    return ContentTypeRemoteAttachment;\n  }\n\n  encode(content: RemoteAttachment) {\n    if (!content.url.startsWith(\"https\")) {\n      throw new Error(\"scheme must be https\");\n    }\n\n    return {\n      type: ContentTypeRemoteAttachment,\n      parameters: {\n        contentDigest: content.contentDigest,\n        salt: secp.etc.bytesToHex(content.salt),\n        nonce: secp.etc.bytesToHex(content.nonce),\n        secret: secp.etc.bytesToHex(content.secret),\n        scheme: content.scheme,\n        contentLength: String(content.contentLength),\n        filename: content.filename,\n      },\n      content: new TextEncoder().encode(content.url),\n    };\n  }\n\n  decode(\n    content: EncodedContent<RemoteAttachmentParameters>,\n  ): RemoteAttachment {\n    return {\n      url: new TextDecoder().decode(content.content),\n      contentDigest: content.parameters.contentDigest,\n      salt: secp.etc.hexToBytes(content.parameters.salt),\n      nonce: secp.etc.hexToBytes(content.parameters.nonce),\n      secret: secp.etc.hexToBytes(content.parameters.secret),\n      scheme: content.parameters.scheme,\n      contentLength: parseInt(content.parameters.contentLength, 10),\n      filename: content.parameters.filename,\n    };\n  }\n\n  fallback(content: RemoteAttachment): string | undefined {\n    return `Can’t display \"${content.filename}\". This app doesn’t support attachments.`;\n  }\n\n  shouldPush() {\n    return true;\n  }\n}\n",
      "size_bytes": 4882
    },
    "apps/xmtp.chat/src/components/Messages/ReadReceiptContent.tsx": {
      "content": "import { Text } from \"@mantine/core\";\n\nexport const ReadReceiptContent: React.FC = () => {\n  return <Text size=\"sm\">Read receipt received</Text>;\n};\n",
      "size_bytes": 149
    },
    "sdks/browser-sdk/src/UtilsWorkerClass.ts": {
      "content": "import { v4 } from \"uuid\";\nimport type {\n  ActionErrorData,\n  ActionName,\n  ActionWithoutData,\n  ExtractActionData,\n  ExtractActionResult,\n} from \"@/types/actions\";\nimport type { UtilsWorkerAction } from \"@/types/actions/utils\";\n\nconst handleError = (event: ErrorEvent) => {\n  console.error(event.message);\n};\n\n/**\n * Class that sets up a worker and provides communications for utility functions\n *\n * This class is not meant to be used directly, it is extended by the Utils class\n * to provide an interface to the worker.\n *\n * @param worker - The worker to use for the utils class\n * @param enableLogging - Whether to enable logging in the worker\n * @returns A new UtilsWorkerClass instance\n */\nexport class UtilsWorkerClass {\n  #worker: Worker;\n\n  #enableLogging: boolean;\n\n  #promises = new Map<\n    string,\n    { resolve: (value: unknown) => void; reject: (reason?: unknown) => void }\n  >();\n\n  constructor(worker: Worker, enableLogging: boolean) {\n    this.#worker = worker;\n    this.#worker.addEventListener(\"message\", this.handleMessage);\n    if (enableLogging) {\n      this.#worker.addEventListener(\"error\", handleError);\n    }\n    this.#enableLogging = enableLogging;\n  }\n\n  /**\n   * Initializes the utils worker\n   *\n   * @param enableLogging - Whether to enable logging in the worker\n   * @returns A promise that resolves when the worker is initialized\n   */\n  async init() {\n    return this.sendMessage(\"utils.init\", {\n      enableLogging: this.#enableLogging,\n    });\n  }\n\n  /**\n   * Sends an action message to the utils worker\n   *\n   * @param action - The action to send to the worker\n   * @param data - The data to send to the worker\n   * @returns A promise that resolves when the action is completed\n   */\n  sendMessage<A extends ActionName<UtilsWorkerAction>>(\n    action: A,\n    data: ExtractActionData<UtilsWorkerAction, A>,\n  ) {\n    const promiseId = v4();\n    this.#worker.postMessage({\n      action,\n      id: promiseId,\n      data,\n    });\n    const promise = new Promise((resolve, reject) => {\n      this.#promises.set(promiseId, {\n        resolve: resolve as (value: unknown) => void,\n        reject,\n      });\n    });\n    return promise as [ExtractActionResult<UtilsWorkerAction, A>] extends [\n      undefined,\n    ]\n      ? Promise<void>\n      : Promise<ExtractActionResult<UtilsWorkerAction, A>>;\n  }\n\n  /**\n   * Handles a message from the utils worker\n   *\n   * @param event - The event to handle\n   */\n  handleMessage = (\n    event: MessageEvent<\n      ActionWithoutData<UtilsWorkerAction> | ActionErrorData<UtilsWorkerAction>\n    >,\n  ) => {\n    const eventData = event.data;\n    if (this.#enableLogging) {\n      console.log(\"utils received event data\", eventData);\n    }\n    const promise = this.#promises.get(eventData.id);\n    if (promise) {\n      this.#promises.delete(eventData.id);\n      if (\"error\" in eventData) {\n        promise.reject(eventData.error);\n      } else {\n        promise.resolve(eventData.result);\n      }\n    }\n  };\n\n  /**\n   * Removes all event listeners and terminates the worker\n   */\n  close() {\n    this.#worker.removeEventListener(\"message\", this.handleMessage);\n    if (this.#enableLogging) {\n      this.#worker.removeEventListener(\"error\", handleError);\n    }\n    this.#worker.terminate();\n  }\n}\n",
      "size_bytes": 3262
    },
    "sdks/agent-sdk/src/core/Agent.ts": {
      "content": "import EventEmitter from \"node:events\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { GroupUpdatedCodec } from \"@xmtp/content-type-group-updated\";\nimport type { ContentCodec } from \"@xmtp/content-type-primitives\";\nimport { ReactionCodec } from \"@xmtp/content-type-reaction\";\nimport { RemoteAttachmentCodec } from \"@xmtp/content-type-remote-attachment\";\nimport { ReplyCodec } from \"@xmtp/content-type-reply\";\nimport type { TextCodec } from \"@xmtp/content-type-text\";\nimport {\n  ApiUrls,\n  Client,\n  Dm,\n  Group,\n  IdentifierKind,\n  isHexString,\n  LogLevel,\n  type ClientOptions,\n  type Conversation,\n  type CreateDmOptions,\n  type CreateGroupOptions,\n  type DecodedMessage,\n  type HexString,\n  type XmtpEnv,\n} from \"@xmtp/node-sdk\";\nimport { filter } from \"@/core/filter.js\";\nimport { getInstallationInfo } from \"@/debug.js\";\nimport { createSigner, createUser } from \"@/user/User.js\";\nimport { AgentError } from \"./AgentError.js\";\nimport { ClientContext } from \"./ClientContext.js\";\nimport { ConversationContext } from \"./ConversationContext.js\";\nimport { MessageContext } from \"./MessageContext.js\";\n\ntype ConversationStream<ContentTypes> = Awaited<\n  ReturnType<Client<ContentTypes>[\"conversations\"][\"stream\"]>\n>;\n\ntype MessageStream<ContentTypes> = Awaited<\n  ReturnType<Client<ContentTypes>[\"conversations\"][\"streamAllMessages\"]>\n>;\n\ntype EventHandlerMap<ContentTypes> = {\n  attachment: [\n    ctx: MessageContext<ReturnType<RemoteAttachmentCodec[\"decode\"]>>,\n  ];\n  conversation: [ctx: ConversationContext<ContentTypes>];\n  \"group-update\": [\n    ctx: MessageContext<ReturnType<GroupUpdatedCodec[\"decode\"]>>,\n  ];\n  dm: [ctx: ConversationContext<ContentTypes, Dm<ContentTypes>>];\n  group: [ctx: ConversationContext<ContentTypes, Group<ContentTypes>>];\n  message: [ctx: MessageContext<ContentTypes>];\n  reaction: [ctx: MessageContext<ReturnType<ReactionCodec[\"decode\"]>>];\n  reply: [ctx: MessageContext<ReturnType<ReplyCodec[\"decode\"]>>];\n  start: [ctx: ClientContext<ContentTypes>];\n  stop: [ctx: ClientContext<ContentTypes>];\n  text: [ctx: MessageContext<ReturnType<TextCodec[\"decode\"]>>];\n  unhandledError: [error: Error];\n  unknownMessage: [ctx: MessageContext<ContentTypes>];\n};\n\ntype EventName<ContentTypes> = keyof EventHandlerMap<ContentTypes>;\n\ntype EthAddress = HexString;\n\nexport type AgentBaseContext<ContentTypes = unknown> = {\n  client: Client<ContentTypes>;\n  conversation: Conversation;\n  message: DecodedMessage;\n};\n\nexport type AgentErrorContext<ContentTypes = unknown> = Partial<\n  AgentBaseContext<ContentTypes>\n> & {\n  client: Client<ContentTypes>;\n};\n\nexport type AgentOptions<ContentTypes> = {\n  client: Client<ContentTypes>;\n};\n\nexport type AgentMessageHandler<ContentTypes = unknown> = (\n  ctx: MessageContext<ContentTypes>,\n) => Promise<void> | void;\n\nexport type AgentMiddleware<ContentTypes = unknown> = (\n  ctx: MessageContext<ContentTypes>,\n  next: () => Promise<void> | void,\n) => Promise<void>;\n\nexport type AgentErrorMiddleware<ContentTypes = unknown> = (\n  error: unknown,\n  ctx: AgentErrorContext<ContentTypes>,\n  next: (err?: unknown) => Promise<void> | void,\n) => Promise<void> | void;\n\nexport type StreamAllMessagesOptions<ContentTypes> = Parameters<\n  Client<ContentTypes>[\"conversations\"][\"streamAllMessages\"]\n>[0];\n\nexport type AgentErrorRegistrar<ContentTypes> = {\n  use(\n    ...errorMiddleware: Array<\n      AgentErrorMiddleware<ContentTypes> | AgentErrorMiddleware<ContentTypes>[]\n    >\n  ): AgentErrorRegistrar<ContentTypes>;\n};\n\ntype ErrorFlow =\n  | { kind: \"handled\" } // next()\n  | { kind: \"continue\"; error: unknown } // next(err) or handler throws\n  | { kind: \"stopped\" }; // handler returns without next()\n\nexport class Agent<ContentTypes = unknown> extends EventEmitter<\n  EventHandlerMap<ContentTypes>\n> {\n  #client: Client<ContentTypes>;\n  #conversationsStream?: ConversationStream<ContentTypes>;\n  #messageStream?: MessageStream<ContentTypes>;\n  #middleware: AgentMiddleware<ContentTypes>[] = [];\n  #errorMiddleware: AgentErrorMiddleware<ContentTypes>[] = [];\n  #errors: AgentErrorRegistrar<ContentTypes> = Object.freeze({\n    use: (...errorMiddleware: AgentErrorMiddleware<ContentTypes>[]) => {\n      for (const emw of errorMiddleware) {\n        if (Array.isArray(emw)) {\n          this.#errorMiddleware.push(...emw);\n        } else if (typeof emw === \"function\") {\n          this.#errorMiddleware.push(emw);\n        }\n      }\n      return this.#errors;\n    },\n  });\n  #defaultErrorHandler: AgentErrorMiddleware<ContentTypes> = (currentError) => {\n    const emittedError =\n      currentError instanceof Error\n        ? currentError\n        : new AgentError(\n            9999,\n            `Unhandled error caught by default error middleware.`,\n            currentError,\n          );\n    this.emit(\"unhandledError\", emittedError);\n  };\n  #isLocked: boolean = false;\n\n  constructor({ client }: AgentOptions<ContentTypes>) {\n    super();\n    this.#client = client;\n  }\n\n  static async create<ContentCodecs extends ContentCodec[] = []>(\n    signer: Parameters<typeof Client.create>[0],\n    // Note: we need to omit this so that \"Client.create\" can correctly infer the codecs.\n    options?: Omit<ClientOptions, \"codecs\"> & { codecs?: ContentCodecs },\n  ) {\n    const initializedOptions = { ...(options ?? {}) };\n    initializedOptions.appVersion ??= \"agent-sdk/alpha\";\n\n    const upgradedCodecs = [\n      ...(initializedOptions.codecs ?? []),\n      new ReactionCodec(),\n      new ReplyCodec(),\n      new RemoteAttachmentCodec(),\n    ];\n\n    if (process.env.XMTP_FORCE_DEBUG) {\n      const loggingLevel = process.env.XMTP_FORCE_DEBUG_LEVEL || LogLevel.warn;\n      initializedOptions.debugEventsEnabled = true;\n      initializedOptions.loggingLevel = loggingLevel as LogLevel;\n      initializedOptions.structuredLogging = true;\n    }\n\n    const client = await Client.create(signer, {\n      ...initializedOptions,\n      codecs: upgradedCodecs,\n    });\n\n    const info = await getInstallationInfo(client);\n    if (info.totalInstallations > 1 && info.isMostRecent) {\n      console.warn(\n        `[WARNING] You have \"${info.totalInstallations}\" installations. Installation ID \"${info.installationId}\" is the most recent. Make sure to persist and reload your installation data. If you exceed the installation limit, your Agent will stop working. Read more: https://docs.xmtp.org/agents/build-agents/local-database#installation-limits-and-revocation-rules`,\n      );\n    }\n\n    return new Agent({ client });\n  }\n\n  static async createFromEnv<ContentCodecs extends ContentCodec[] = []>(\n    // Note: we need to omit this so that \"Client.create\" can correctly infer the codecs.\n    options?: Omit<ClientOptions, \"codecs\"> & { codecs?: ContentCodecs },\n  ) {\n    const {\n      XMTP_DB_DIRECTORY,\n      XMTP_DB_ENCRYPTION_KEY,\n      XMTP_ENV,\n      XMTP_WALLET_KEY,\n    } = process.env;\n\n    if (!isHexString(XMTP_WALLET_KEY)) {\n      throw new AgentError(\n        1000,\n        `XMTP_WALLET_KEY env is not in hex (0x) format.`,\n      );\n    }\n\n    const signer = createSigner(createUser(XMTP_WALLET_KEY));\n\n    const initializedOptions = { ...(options ?? {}) };\n\n    initializedOptions.dbEncryptionKey =\n      typeof XMTP_DB_ENCRYPTION_KEY === \"string\"\n        ? isHexString(XMTP_DB_ENCRYPTION_KEY)\n          ? XMTP_DB_ENCRYPTION_KEY\n          : `0x${XMTP_DB_ENCRYPTION_KEY}`\n        : undefined;\n\n    if (XMTP_ENV && Object.keys(ApiUrls).includes(XMTP_ENV)) {\n      initializedOptions.env = XMTP_ENV as XmtpEnv;\n    }\n\n    if (typeof XMTP_DB_DIRECTORY === \"string\") {\n      fs.mkdirSync(XMTP_DB_DIRECTORY, { recursive: true, mode: 0o700 });\n      initializedOptions.dbPath = (inboxId: string) => {\n        const dbPath = path.join(XMTP_DB_DIRECTORY, `xmtp-${inboxId}.db3`);\n        console.info(`Saving local database to \"${dbPath}\"`);\n        return dbPath;\n      };\n    }\n\n    return this.create(signer, initializedOptions);\n  }\n\n  use(\n    ...middleware: Array<\n      AgentMiddleware<ContentTypes> | AgentMiddleware<ContentTypes>[]\n    >\n  ): this {\n    for (const mw of middleware) {\n      if (Array.isArray(mw)) {\n        this.#middleware.push(...mw);\n      } else if (typeof mw === \"function\") {\n        this.#middleware.push(mw);\n      }\n    }\n    return this;\n  }\n\n  async #stopStreams() {\n    try {\n      await this.#conversationsStream?.end();\n    } finally {\n      this.#conversationsStream = undefined;\n    }\n\n    try {\n      await this.#messageStream?.end();\n    } finally {\n      this.#messageStream = undefined;\n    }\n  }\n\n  /**\n   * Closes all existing streams and restarts the streaming system.\n   */\n  async #handleStreamError(error: unknown) {\n    await this.#stopStreams();\n\n    const recovered = await this.#runErrorChain(error, {\n      client: this.#client,\n    });\n\n    if (recovered) {\n      this.#isLocked = false;\n      queueMicrotask(() => this.start());\n    }\n  }\n\n  async start() {\n    if (this.#isLocked || this.#conversationsStream || this.#messageStream)\n      return;\n\n    this.#isLocked = true;\n\n    try {\n      this.#conversationsStream = await this.#client.conversations.stream({\n        onValue: async (conversation) => {\n          try {\n            if (!conversation) {\n              return;\n            }\n            this.emit(\n              \"conversation\",\n              new ConversationContext<ContentTypes, Conversation<ContentTypes>>(\n                {\n                  conversation,\n                  client: this.#client,\n                },\n              ),\n            );\n            if (conversation instanceof Group) {\n              this.emit(\n                \"group\",\n                new ConversationContext<ContentTypes, Group<ContentTypes>>({\n                  conversation,\n                  client: this.#client,\n                }),\n              );\n            } else if (conversation instanceof Dm) {\n              this.emit(\n                \"dm\",\n                new ConversationContext<ContentTypes, Dm<ContentTypes>>({\n                  conversation,\n                  client: this.#client,\n                }),\n              );\n            }\n          } catch (error) {\n            const recovered = await this.#runErrorChain(\n              new AgentError(\n                1001,\n                \"Emitted value from conversation stream caused an error.\",\n                error,\n              ),\n              new ClientContext({ client: this.#client }),\n            );\n            if (!recovered) await this.stop();\n          }\n        },\n        onError: async (error) => {\n          const recovered = await this.#runErrorChain(\n            new AgentError(\n              1002,\n              \"Error occured during conversation streaming.\",\n              error,\n            ),\n            new ClientContext({ client: this.#client }),\n          );\n          if (!recovered) await this.stop();\n        },\n      });\n\n      this.#messageStream = await this.#client.conversations.streamAllMessages({\n        onValue: async (message) => {\n          try {\n            switch (true) {\n              case filter.isGroupUpdate(message):\n                await this.#processMessage(message, \"group-update\");\n                break;\n              case filter.isRemoteAttachment(message):\n                await this.#processMessage(message, \"attachment\");\n                break;\n              case filter.isReaction(message):\n                await this.#processMessage(message, \"reaction\");\n                break;\n              case filter.isReply(message):\n                await this.#processMessage(message, \"reply\");\n                break;\n              case filter.isText(message):\n                await this.#processMessage(message, \"text\");\n                break;\n              default:\n                await this.#processMessage(message);\n                break;\n            }\n          } catch (error) {\n            const recovered = await this.#runErrorChain(error, {\n              client: this.#client,\n            });\n            if (!recovered) {\n              await this.stop();\n            }\n            this.#isLocked = false;\n          }\n        },\n        onError: async (error) => {\n          const recovered = await this.#runErrorChain(\n            new AgentError(\n              1004,\n              \"Error occured during message streaming.\",\n              error,\n            ),\n            new ClientContext({ client: this.#client }),\n          );\n          if (!recovered) await this.stop();\n        },\n      });\n\n      this.emit(\"start\", new ClientContext({ client: this.#client }));\n      this.#isLocked = false;\n    } catch (error) {\n      await this.#handleStreamError(error);\n    }\n  }\n\n  async #processMessage(\n    message: DecodedMessage<ContentTypes>,\n    topic: EventName<ContentTypes> = \"unknownMessage\",\n  ) {\n    // Skip messages with undefined content (failed to decode)\n    if (!filter.hasContent(message)) {\n      return;\n    }\n\n    // Skip messages from agent itself\n    if (filter.fromSelf(message, this.#client)) {\n      return;\n    }\n\n    const conversation = await this.#client.conversations.getConversationById(\n      message.conversationId,\n    );\n\n    if (!conversation) {\n      throw new AgentError(\n        1003,\n        `Failed to process message ID \"${message.id}\" for conversation ID \"${message.conversationId}\" because the conversation could not be found.`,\n      );\n    }\n\n    const context = new MessageContext({\n      message,\n      conversation,\n      client: this.#client,\n    });\n    await this.#runMiddlewareChain(context, topic);\n  }\n\n  async #runMiddlewareChain(\n    context: MessageContext<ContentTypes>,\n    topic: EventName<ContentTypes> = \"unknownMessage\",\n  ) {\n    const finalEmit = async () => {\n      try {\n        this.emit(topic, context);\n        this.emit(\"message\", context);\n      } catch (error) {\n        await this.#runErrorChain(error, context);\n      }\n    };\n\n    const chain = this.#middleware.reduceRight<Parameters<AgentMiddleware>[1]>(\n      (next, mw) => {\n        return async () => {\n          try {\n            await mw(context, next);\n          } catch (error) {\n            const resume = await this.#runErrorChain(error, context);\n            if (resume) {\n              await next();\n            }\n            // Chain is not resuming, error is being swallowed\n          }\n        };\n      },\n      finalEmit,\n    );\n\n    await chain();\n  }\n\n  async #runErrorHandler(\n    handler: AgentErrorMiddleware<ContentTypes>,\n    context: AgentErrorContext<ContentTypes>,\n    error: unknown,\n  ): Promise<ErrorFlow> {\n    let settled = false as boolean;\n    let flow: ErrorFlow = { kind: \"stopped\" };\n\n    const next = (nextErr?: unknown) => {\n      if (settled) return;\n      settled = true;\n      flow =\n        nextErr === undefined\n          ? { kind: \"handled\" }\n          : { kind: \"continue\", error: nextErr };\n    };\n\n    try {\n      await handler(error, context, next);\n      return flow;\n    } catch (thrown) {\n      if (settled) {\n        return flow;\n      }\n      return { kind: \"continue\", error: thrown };\n    }\n  }\n\n  async #runErrorChain(\n    error: unknown,\n    context: AgentErrorContext<ContentTypes>,\n  ): Promise<boolean> {\n    const chain = [...this.#errorMiddleware, this.#defaultErrorHandler];\n\n    let currentError: unknown = error;\n\n    for (let i = 0; i < chain.length; i++) {\n      const handler = chain[i];\n      if (!handler) continue;\n      const outcome = await this.#runErrorHandler(\n        handler,\n        context,\n        currentError,\n      );\n\n      switch (outcome.kind) {\n        case \"handled\":\n          // Error was handled. Main middleware can continue.\n          return true;\n        case \"stopped\":\n          // Error cannot be handled. Main middleware won't continue.\n          return false;\n        case \"continue\":\n          // Error is passed to the next handler\n          currentError = outcome.error;\n      }\n    }\n\n    // Reached end of chain without recovery\n    return false;\n  }\n\n  get client() {\n    return this.#client;\n  }\n\n  get errors() {\n    return this.#errors;\n  }\n\n  async stop() {\n    this.#isLocked = true;\n\n    await this.#stopStreams();\n\n    this.emit(\"stop\", new ClientContext({ client: this.#client }));\n\n    this.#isLocked = false;\n  }\n\n  createDmWithAddress(address: EthAddress, options?: CreateDmOptions) {\n    return this.#client.conversations.newDmWithIdentifier(\n      {\n        identifier: address,\n        identifierKind: IdentifierKind.Ethereum,\n      },\n      options,\n    );\n  }\n\n  createGroupWithAddresses(\n    addresses: EthAddress[],\n    options?: CreateGroupOptions,\n  ) {\n    const identifiers = addresses.map((address) => {\n      return {\n        identifier: address,\n        identifierKind: IdentifierKind.Ethereum,\n      };\n    });\n    return this.#client.conversations.newGroupWithIdentifiers(\n      identifiers,\n      options,\n    );\n  }\n\n  addMembersWithAddresses<ContentTypes>(\n    group: Group<ContentTypes>,\n    addresses: EthAddress[],\n  ) {\n    const identifiers = addresses.map((address) => {\n      return {\n        identifier: address,\n        identifierKind: IdentifierKind.Ethereum,\n      };\n    });\n\n    return group.addMembersByIdentifiers(identifiers);\n  }\n\n  get address() {\n    return this.#client.accountIdentifier?.identifier;\n  }\n}\n",
      "size_bytes": 17231
    },
    "content-types/content-type-remote-attachment/src/encryption/index.ts": {
      "content": "export { default as Ciphertext } from \"./Ciphertext\";\nexport { default as crypto } from \"./crypto\";\nexport * from \"./encryption\";\n",
      "size_bytes": 130
    },
    "sdks/agent-sdk/src/core/ClientContext.ts": {
      "content": "import type { Client } from \"@xmtp/node-sdk\";\n\nexport class ClientContext<ContentTypes = unknown> {\n  #client: Client<ContentTypes>;\n\n  constructor({ client }: { client: Client<ContentTypes> }) {\n    this.#client = client;\n  }\n\n  getClientAddress() {\n    return this.#client.accountIdentifier?.identifier;\n  }\n\n  get client() {\n    return this.#client;\n  }\n}\n",
      "size_bytes": 359
    },
    "sdks/node-sdk/test/helpers.ts": {
      "content": "import { dirname, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport {\n  ContentTypeId,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\nimport {\n  generateInboxId,\n  IdentifierKind,\n  type Identifier,\n} from \"@xmtp/node-bindings\";\nimport { createWalletClient, http, toBytes } from \"viem\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { sepolia } from \"viem/chains\";\nimport { Client } from \"@/Client\";\nimport { HistorySyncUrls } from \"@/constants\";\nimport type { ClientOptions } from \"@/types\";\nimport type { Signer } from \"@/utils/signer\";\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nexport const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n\nexport const createUser = (key?: `0x${string}`) => {\n  const accountKey = key ?? generatePrivateKey();\n  const account = privateKeyToAccount(accountKey);\n  return {\n    key: accountKey,\n    account,\n    wallet: createWalletClient({\n      account,\n      chain: sepolia,\n      transport: http(),\n    }),\n  };\n};\n\nexport const createIdentifier = (user: User): Identifier => ({\n  identifier: user.account.address.toLowerCase(),\n  identifierKind: IdentifierKind.Ethereum,\n});\n\nexport const createSigner = (user: User): Signer => {\n  const identifier = createIdentifier(user);\n  return {\n    type: \"EOA\",\n    getIdentifier: () => identifier,\n    signMessage: async (message: string) => {\n      const signature = await user.wallet.signMessage({\n        message,\n      });\n      return toBytes(signature);\n    },\n  };\n};\n\nexport type User = ReturnType<typeof createUser>;\n\nexport const buildClient = async <ContentCodecs extends ContentCodec[] = []>(\n  identifier: Identifier,\n  options?: ClientOptions & {\n    codecs?: ContentCodecs;\n  },\n) => {\n  const opts = {\n    ...options,\n    env: options?.env ?? \"local\",\n  };\n  return Client.build<ContentCodecs>(identifier, {\n    ...opts,\n    dbPath: opts.dbPath ?? `./test-${identifier.identifier}.db3`,\n  });\n};\n\nexport const createClient = async <ContentCodecs extends ContentCodec[] = []>(\n  signer: Signer,\n  options?: Omit<ClientOptions, \"codecs\"> & {\n    codecs?: ContentCodecs;\n  },\n) => {\n  const opts = {\n    ...options,\n    env: options?.env ?? \"local\",\n  };\n  const inboxId = generateInboxId(await signer.getIdentifier());\n\n  let dbPath: string;\n  if (typeof opts.dbPath === \"function\") {\n    dbPath = opts.dbPath(inboxId);\n  } else {\n    dbPath = join(__dirname, opts.dbPath ?? `./test-${inboxId}.db3`);\n  }\n\n  const client = await Client.create<ContentCodecs>(signer, {\n    ...opts,\n    disableAutoRegister: true,\n    dbPath: dbPath,\n    historySyncUrl: HistorySyncUrls.local,\n  });\n  return client;\n};\n\nexport const createRegisteredClient = async <\n  ContentCodecs extends ContentCodec[] = [],\n>(\n  signer: Signer,\n  options?: Omit<ClientOptions, \"codecs\"> & {\n    codecs?: ContentCodecs;\n  },\n) => {\n  const opts = {\n    ...options,\n    env: options?.env ?? \"local\",\n  };\n  const inboxId = generateInboxId(await signer.getIdentifier());\n\n  let dbPath: string;\n  if (typeof opts.dbPath === \"function\") {\n    dbPath = opts.dbPath(inboxId);\n  } else {\n    dbPath = opts.dbPath ?? `./test-${inboxId}.db3`;\n  }\n\n  return Client.create<ContentCodecs>(signer, {\n    ...opts,\n    dbPath,\n    historySyncUrl: HistorySyncUrls.local,\n  });\n};\n\nexport const ContentTypeTest = new ContentTypeId({\n  authorityId: \"xmtp.org\",\n  typeId: \"test\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\nexport class TestCodec\n  implements ContentCodec<Record<string, string>, Record<string, never>>\n{\n  get contentType(): ContentTypeId {\n    return ContentTypeTest;\n  }\n\n  encode(\n    content: Record<string, string>,\n  ): EncodedContent<Record<string, never>> {\n    return {\n      type: this.contentType,\n      parameters: {},\n      content: new TextEncoder().encode(JSON.stringify(content)),\n    };\n  }\n\n  decode(\n    content: EncodedContent<Record<string, never>>,\n  ): Record<string, string> {\n    const decoded = new TextDecoder().decode(content.content);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return JSON.parse(decoded);\n  }\n\n  fallback() {\n    return undefined;\n  }\n\n  shouldPush() {\n    return false;\n  }\n}\n",
      "size_bytes": 4256
    },
    "apps/xmtp.chat/src/hooks/useMemberProfiles.ts": {
      "content": "import type { SafeGroupMember } from \"@xmtp/browser-sdk\";\nimport { useMemo } from \"react\";\nimport { getMemberAddress } from \"@/helpers/xmtp\";\nimport { combineProfiles, useAllProfiles } from \"@/stores/profiles\";\n\nexport type MemberProfile = SafeGroupMember & {\n  address: string;\n  avatar: string | null;\n  description: string | null;\n  displayName: string | null;\n};\n\nexport const useMemberProfiles = (\n  members: SafeGroupMember[],\n): MemberProfile[] => {\n  const profiles = useAllProfiles();\n  return useMemo(() => {\n    return members.map((member) => {\n      const address = getMemberAddress(member);\n      return {\n        ...member,\n        ...combineProfiles(address, profiles.get(address) ?? []),\n      };\n    });\n  }, [members, profiles]);\n};\n",
      "size_bytes": 751
    },
    "apps/xmtp.chat/src/hooks/useIdentity.ts": {
      "content": "import type {\n  Identifier,\n  SafeInstallation,\n  SafeKeyPackageStatus,\n} from \"@xmtp/browser-sdk\";\nimport { useEffect, useState } from \"react\";\nimport { useClient } from \"@/contexts/XMTPContext\";\n\nexport type Installation = SafeInstallation & {\n  keyPackageStatus: SafeKeyPackageStatus | undefined;\n};\n\nexport const useIdentity = (syncOnMount: boolean = false) => {\n  const client = useClient();\n  const [syncing, setSyncing] = useState(false);\n  const [revoking, setRevoking] = useState(false);\n  const [inboxId, setInboxId] = useState<string | null>(null);\n  const [recoveryIdentifier, setRecoveryIdentifier] =\n    useState<Identifier | null>(null);\n  const [accountIdentifiers, setAccountIdentifiers] = useState<Identifier[]>(\n    [],\n  );\n  const [installations, setInstallations] = useState<Installation[]>([]);\n\n  useEffect(() => {\n    if (syncOnMount) {\n      void sync();\n    }\n  }, []);\n\n  const sync = async () => {\n    setSyncing(true);\n\n    try {\n      const inboxState = await client.preferences.inboxState(true);\n      setInboxId(inboxState.inboxId);\n      setAccountIdentifiers(inboxState.identifiers);\n      setRecoveryIdentifier(inboxState.recoveryIdentifier);\n      const installations = inboxState.installations.sort((a, b) => {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (a.clientTimestampNs! > b.clientTimestampNs!) {\n          return -1;\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        } else if (a.clientTimestampNs! < b.clientTimestampNs!) {\n          return 1;\n        }\n        return 0;\n      });\n      const keyPackageStatuses =\n        await client.getKeyPackageStatusesForInstallationIds(\n          installations.map((installation) => installation.id),\n        );\n      setInstallations(\n        installations.map((installation) => ({\n          ...installation,\n          keyPackageStatus: keyPackageStatuses.get(installation.id),\n        })),\n      );\n    } finally {\n      setSyncing(false);\n    }\n  };\n\n  const revokeInstallation = async (installationIdBytes: Uint8Array) => {\n    setRevoking(true);\n\n    try {\n      await client.revokeInstallations([installationIdBytes]);\n    } finally {\n      setRevoking(false);\n    }\n  };\n\n  const revokeAllOtherInstallations = async () => {\n    setRevoking(true);\n\n    try {\n      await client.revokeAllOtherInstallations();\n    } finally {\n      setRevoking(false);\n    }\n  };\n\n  return {\n    accountIdentifiers,\n    inboxId,\n    installations,\n    recoveryIdentifier,\n    revokeAllOtherInstallations,\n    revokeInstallation,\n    revoking,\n    sync,\n    syncing,\n  };\n};\n",
      "size_bytes": 2629
    },
    "apps/xmtp.chat/src/components/Messages/RemoteAttachmentContent.tsx": {
      "content": "import { Box, Button, Group, Loader, Paper, Text } from \"@mantine/core\";\nimport {\n  AttachmentCodec,\n  RemoteAttachmentCodec,\n  type Attachment,\n  type RemoteAttachment,\n} from \"@xmtp/content-type-remote-attachment\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { AttachmentDetails } from \"@/components/Messages/AttachmentDetails\";\nimport type { MessageContentAlign } from \"@/components/Messages/MessageContentWrapper\";\nimport { formatFileSize, getFileType } from \"@/helpers/attachment\";\n\nconst urlCache = new Map<\n  string,\n  {\n    blobUrl: string | null;\n    failed: boolean;\n  }\n>();\n\nexport type RemoteAttachmentContentProps = {\n  content: RemoteAttachment;\n  align: MessageContentAlign;\n};\n\nexport const RemoteAttachmentContent: React.FC<\n  RemoteAttachmentContentProps\n> = ({ content, align }) => {\n  const [decryptedUrl, setDecryptedUrl] = useState<string | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const loadingRef = useRef(false);\n\n  const loadAttachment = useCallback(\n    async (force: boolean = false) => {\n      try {\n        // do not load the attachment if it is already loading\n        if (loadingRef.current) {\n          return;\n        }\n\n        loadingRef.current = true;\n\n        setError(null);\n        setDecryptedUrl(null);\n\n        if (!force) {\n          // Check if the blob URL is cached\n          const cachedUrl = urlCache.get(content.url);\n          if (cachedUrl) {\n            if (cachedUrl.failed) {\n              setError(\"Unable to load attachment\");\n              return;\n            }\n            if (cachedUrl.blobUrl !== null) {\n              setDecryptedUrl(cachedUrl.blobUrl);\n              return;\n            }\n          }\n        }\n\n        setIsLoading(true);\n        const decryptedAttachment =\n          await RemoteAttachmentCodec.load<Attachment>(content, {\n            codecFor: () => new AttachmentCodec(),\n          });\n\n        const blob = new Blob(\n          [decryptedAttachment.data as Uint8Array<ArrayBuffer>],\n          {\n            type: decryptedAttachment.mimeType,\n          },\n        );\n        const blobUrl = URL.createObjectURL(blob);\n\n        // Cache the blob URL\n        urlCache.set(content.url, {\n          blobUrl,\n          failed: false,\n        });\n\n        setDecryptedUrl(blobUrl);\n      } catch {\n        setError(\"Unable to load attachment\");\n        urlCache.set(content.url, {\n          blobUrl: null,\n          failed: true,\n        });\n      } finally {\n        setIsLoading(false);\n        loadingRef.current = false;\n      }\n    },\n    [content],\n  );\n\n  const handleRetry = () => {\n    void loadAttachment(true);\n  };\n\n  // if content changes, reset content display\n  useEffect(() => {\n    setDecryptedUrl(null);\n    setError(null);\n  }, [content]);\n\n  // only load the attachment once on mount\n  // if content changes, users will have to reload the attachment manually\n  useEffect(() => {\n    void loadAttachment();\n  }, []);\n\n  const fileSize = formatFileSize(content.contentLength);\n\n  if (isLoading) {\n    return (\n      <Paper p=\"sm\" radius=\"md\" withBorder>\n        <Group gap=\"xs\" align=\"center\">\n          <Loader size=\"sm\" />\n          <Text size=\"sm\" c=\"dimmed\">\n            Loading attachment...\n          </Text>\n        </Group>\n        <AttachmentDetails\n          filename={content.filename}\n          fileSize={fileSize}\n          align={align}\n        />\n      </Paper>\n    );\n  }\n\n  if (error) {\n    return (\n      <Paper p=\"sm\" radius=\"md\" withBorder>\n        <Box>\n          <Group gap=\"xs\" align=\"center\" mb=\"xs\" wrap=\"nowrap\">\n            <Text size=\"sm\" c=\"red\" style={{ whiteSpace: \"nowrap\" }}>\n              {error}\n            </Text>\n            <Button size=\"xs\" variant=\"light\" onClick={handleRetry}>\n              Retry\n            </Button>\n          </Group>\n          <AttachmentDetails\n            filename={content.filename}\n            fileSize={fileSize}\n            align={align}\n          />\n        </Box>\n      </Paper>\n    );\n  }\n\n  if (!decryptedUrl) {\n    return (\n      <Paper p=\"sm\" radius=\"md\" withBorder>\n        <Group gap=\"xs\" align=\"center\" mb=\"xs\" wrap=\"nowrap\">\n          <Text size=\"sm\" c=\"red\" style={{ whiteSpace: \"nowrap\" }}>\n            No content available\n          </Text>\n          <Button size=\"xs\" variant=\"light\" onClick={handleRetry}>\n            Retry\n          </Button>\n        </Group>\n        <AttachmentDetails\n          filename={content.filename}\n          fileSize={fileSize}\n          align={align}\n        />\n      </Paper>\n    );\n  }\n\n  const fileType = getFileType(content.filename);\n\n  return (\n    <Paper p=\"sm\" radius=\"md\" withBorder>\n      <Box>\n        {fileType === \"image\" && (\n          <img\n            src={decryptedUrl}\n            alt={content.filename || \"Attachment\"}\n            style={{\n              width: \"100%\",\n              height: \"auto\",\n              borderRadius: \"var(--mantine-radius-sm)\",\n              objectFit: \"contain\",\n              display: \"block\",\n            }}\n          />\n        )}\n        {fileType === \"video\" && (\n          <video\n            src={decryptedUrl}\n            controls\n            style={{\n              width: \"100%\",\n              height: \"auto\",\n              borderRadius: \"var(--mantine-radius-sm)\",\n              display: \"block\",\n            }}\n          />\n        )}\n        {fileType === \"audio\" && (\n          <audio\n            src={decryptedUrl}\n            controls\n            style={{\n              width: \"100%\",\n              minWidth: \"300px\",\n              display: \"block\",\n            }}\n          />\n        )}\n        <AttachmentDetails\n          filename={content.filename}\n          fileSize={fileSize}\n          align={align}\n        />\n      </Box>\n    </Paper>\n  );\n};\n",
      "size_bytes": 5840
    },
    "apps/xmtp.chat/src/components/App/Disconnect.tsx": {
      "content": "import { LoadingOverlay } from \"@mantine/core\";\nimport { useEffect } from \"react\";\nimport { useNavigate } from \"react-router\";\nimport { useXMTP } from \"@/contexts/XMTPContext\";\nimport { useConnectWallet } from \"@/hooks/useConnectWallet\";\nimport { useSettings } from \"@/hooks/useSettings\";\nimport { CenteredLayout } from \"@/layouts/CenteredLayout\";\n\nexport const Disconnect: React.FC = () => {\n  const navigate = useNavigate();\n  const { disconnect } = useConnectWallet();\n  const { setAutoConnect, setEphemeralAccountEnabled } = useSettings();\n  const { disconnect: disconnectClient } = useXMTP();\n\n  useEffect(() => {\n    disconnect(undefined, {\n      onSuccess: () => {\n        disconnectClient();\n        setEphemeralAccountEnabled(false);\n        setAutoConnect(false);\n        void navigate(\"/\");\n      },\n    });\n  }, []);\n\n  return (\n    <CenteredLayout>\n      <LoadingOverlay visible={true} />\n    </CenteredLayout>\n  );\n};\n",
      "size_bytes": 932
    },
    "apps/xmtp.chat/src/components/Conversation/Member.module.css": {
      "content": ".root {\n  position: relative;\n}\n\n.root > :first-child {\n  width: 100%;\n}\n\n.button {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: var(--mantine-spacing-md);\n}\n",
      "size_bytes": 167
    },
    "content-types/content-type-remote-attachment/vitest.config.ts": {
      "content": "import { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    globalSetup: [\"./vitest.setup.ts\"],\n  },\n});\n",
      "size_bytes": 155
    },
    "sdks/browser-sdk/test/AsyncStream.test.ts": {
      "content": "import { describe, expect, it, vi } from \"vitest\";\nimport { AsyncStream, createAsyncStreamProxy } from \"@/AsyncStream\";\n\nconst testError = new Error(\"test\");\n\ndescribe(\"AsyncStream\", () => {\n  it(\"should return values from push() in sequence\", async () => {\n    const stream = new AsyncStream<number>();\n    const onReturnSpy = vi.fn();\n    const onDoneSpy = vi.fn();\n\n    stream.onReturn = onReturnSpy;\n    stream.onDone = onDoneSpy;\n\n    stream.push(1);\n    stream.push(2);\n    stream.push(3);\n    stream.push(4);\n    stream.push(5);\n\n    const values: (number | undefined)[] = [];\n    let iterationCount = 0;\n\n    for await (const value of stream) {\n      values.push(value);\n      iterationCount++;\n\n      if (iterationCount === 3) {\n        break;\n      }\n    }\n\n    expect(values).toEqual([1, 2, 3]);\n    expect(onReturnSpy).toHaveBeenCalledOnce();\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n  });\n\n  it(\"should handle values added during iteration\", async () => {\n    const stream = new AsyncStream<number>();\n    const onReturnSpy = vi.fn();\n    const onDoneSpy = vi.fn();\n\n    stream.onReturn = onReturnSpy;\n    stream.onDone = onDoneSpy;\n\n    stream.push(1);\n\n    const values: (number | undefined)[] = [];\n    let iterationCount = 0;\n\n    for await (const value of stream) {\n      values.push(value);\n      iterationCount++;\n\n      if (iterationCount === 1) {\n        stream.push(2);\n        stream.push(3);\n      }\n\n      if (iterationCount === 3) {\n        break;\n      }\n    }\n\n    expect(values).toEqual([1, 2, 3]);\n    expect(onReturnSpy).toHaveBeenCalledOnce();\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n  });\n\n  it(\"should catch an error thrown in the for..await loop and cleanup properly\", async () => {\n    const stream = new AsyncStream<number>();\n    const onReturnSpy = vi.fn();\n    const onDoneSpy = vi.fn();\n\n    stream.onReturn = onReturnSpy;\n    stream.onDone = onDoneSpy;\n    stream.push(1);\n    stream.push(2);\n\n    try {\n      for await (const value of stream) {\n        expect(value).toBe(1);\n        throw testError;\n      }\n    } catch (error) {\n      expect(error).toBe(testError);\n    }\n\n    expect(onReturnSpy).toHaveBeenCalledOnce();\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n  });\n\n  it(\"should end for await..of loop when stream is ended and call onDone\", async () => {\n    const stream = new AsyncStream<number>();\n    const onDoneSpy = vi.fn();\n    const onReturnSpy = vi.fn();\n\n    stream.onDone = onDoneSpy;\n    stream.onReturn = onReturnSpy;\n\n    stream.push(1);\n    stream.push(2);\n\n    setTimeout(() => {\n      void stream.end();\n    }, 100);\n\n    const values: (number | undefined)[] = [];\n\n    for await (const value of stream) {\n      values.push(value);\n    }\n\n    expect(values).toEqual([1, 2]);\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(onReturnSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n\n    stream.push(3);\n\n    for await (const _value of stream) {\n      // this block should never be reached\n      expect(false).toBe(true);\n    }\n  });\n\n  it(\"should handle multiple concurrent next() calls\", async () => {\n    const stream = new AsyncStream<number>();\n\n    const nextPromise1 = stream.next();\n    const nextPromise2 = stream.next();\n    const nextPromise3 = stream.next();\n\n    stream.push(1);\n    stream.push(2);\n    stream.push(3);\n\n    const [result1, result2, result3] = await Promise.all([\n      nextPromise1,\n      nextPromise2,\n      nextPromise3,\n    ]);\n\n    expect(result1).toEqual({ done: false, value: 1 });\n    expect(result2).toEqual({ done: false, value: 2 });\n    expect(result3).toEqual({ done: false, value: 3 });\n    expect(stream.isDone).toBe(false);\n  });\n\n  it(\"should handle return() with pending promises\", async () => {\n    const stream = new AsyncStream<number>();\n    const onReturnSpy = vi.fn();\n\n    stream.onReturn = onReturnSpy;\n\n    const nextPromise1 = stream.next();\n    const nextPromise2 = stream.next();\n\n    const returnResult = await stream.return();\n\n    expect(returnResult).toEqual({ done: true, value: undefined });\n    expect(onReturnSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n\n    const result1 = await nextPromise1;\n    const result2 = await nextPromise2;\n\n    expect(result1).toEqual({ done: true, value: undefined });\n    expect(result2).toEqual({ done: true, value: undefined });\n  });\n\n  it(\"should not process callbacks after being done\", async () => {\n    const stream = new AsyncStream<number>();\n    const onDoneSpy = vi.fn();\n    const onReturnSpy = vi.fn();\n\n    stream.onDone = onDoneSpy;\n    stream.onReturn = onReturnSpy;\n\n    // End the stream\n    await stream.end();\n\n    // These callbacks should be ignored\n    stream.push(1);\n\n    for await (const _value of stream) {\n      // this block should never be reached\n      expect(false).toBe(true);\n    }\n\n    expect(stream.isDone).toBe(true);\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(onReturnSpy).toHaveBeenCalledOnce();\n\n    const result = await stream.next();\n    expect(result).toEqual({ done: true, value: undefined });\n  });\n\n  it(\"should handle queue properly when values arrive faster than consumption\", async () => {\n    const stream = new AsyncStream<number>();\n\n    for (let i = 1; i <= 5; i++) {\n      stream.push(i);\n    }\n\n    const values: (number | undefined)[] = [];\n\n    for (let i = 0; i < 3; i++) {\n      const result = await stream.next();\n      expect(result.done).toBe(false);\n      values.push(result.value);\n    }\n\n    expect(values).toEqual([1, 2, 3]);\n    expect(stream.isDone).toBe(false);\n\n    await stream.end();\n\n    const finalResult = await stream.next();\n    expect(finalResult).toEqual({ done: true, value: undefined });\n  });\n});\n\ndescribe(\"createAsyncStreamProxy\", () => {\n  it(\"should only expose allowed methods and properties\", () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    expect(typeof proxy.next).toBe(\"function\");\n    expect(typeof proxy.end).toBe(\"function\");\n    expect(typeof proxy.return).toBe(\"function\");\n    expect(typeof proxy[Symbol.asyncIterator]).toBe(\"function\");\n\n    const ownProperties = Object.getOwnPropertyNames(proxy);\n    expect(ownProperties).toHaveLength(4);\n    expect(ownProperties).toContain(\"end\");\n    expect(ownProperties).toContain(\"return\");\n    expect(ownProperties).toContain(\"isDone\");\n    expect(ownProperties).toContain(\"next\");\n  });\n\n  it(\"should prevent setting properties\", () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    // this will fail silently\n    proxy.isDone = true;\n\n    expect(proxy.isDone).toBe(false);\n  });\n\n  it(\"should correctly forward next() calls to the underlying stream\", async () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    stream.push(1);\n    stream.push(2);\n\n    const result1 = await proxy.next();\n    const result2 = await proxy.next();\n\n    expect(result1).toEqual({ done: false, value: 1 });\n    expect(result2).toEqual({ done: false, value: 2 });\n  });\n\n  it(\"should correctly forward end() calls to the underlying stream\", async () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n    const onDoneSpy = vi.fn();\n\n    stream.onDone = onDoneSpy;\n\n    const result = await proxy.end();\n\n    expect(result).toEqual({ done: true, value: undefined });\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n    expect(proxy.isDone).toBe(true);\n  });\n\n  it(\"should maintain async iterator functionality\", async () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    stream.push(1);\n    stream.push(2);\n    stream.push(3);\n\n    const values: number[] = [];\n    let iterationCount = 0;\n\n    for await (const value of proxy) {\n      values.push(value);\n      iterationCount++;\n\n      if (iterationCount === 3) {\n        break;\n      }\n    }\n\n    expect(values).toEqual([1, 2, 3]);\n    expect(stream.isDone).toBe(true);\n    expect(proxy.isDone).toBe(true);\n  });\n\n  it(\"should end for await..of loop when proxy is ended and call onDone\", async () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n    const onDoneSpy = vi.fn();\n\n    stream.onDone = onDoneSpy;\n\n    stream.push(1);\n    stream.push(2);\n\n    setTimeout(() => {\n      void proxy.end();\n    }, 100);\n\n    const values: number[] = [];\n\n    for await (const value of proxy) {\n      values.push(value);\n    }\n\n    expect(values).toEqual([1, 2]);\n    expect(onDoneSpy).toHaveBeenCalledOnce();\n    expect(stream.isDone).toBe(true);\n    expect(proxy.isDone).toBe(true);\n\n    stream.push(3);\n\n    for await (const _value of proxy) {\n      // this block should never be reached\n      expect(false).toBe(true);\n    }\n  });\n\n  it(\"should correctly implement has() trap\", () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    expect(\"isDone\" in proxy).toBe(true);\n    expect(\"next\" in proxy).toBe(true);\n    expect(\"end\" in proxy).toBe(true);\n    expect(\"return\" in proxy).toBe(true);\n    expect(Symbol.asyncIterator in proxy).toBe(true);\n\n    expect(\"push\" in proxy).toBe(false);\n    expect(\"error\" in proxy).toBe(false);\n    expect(\"onDone\" in proxy).toBe(false);\n    expect(\"onError\" in proxy).toBe(false);\n    expect(\"onReturn\" in proxy).toBe(false);\n    expect(\"nonExistentProperty\" in proxy).toBe(false);\n  });\n\n  it(\"should correctly implement ownKeys() trap\", () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    const keys = Object.getOwnPropertyNames(proxy);\n    const symbols = Object.getOwnPropertySymbols(proxy);\n\n    expect(keys).toHaveLength(4);\n    expect(keys).toContain(\"next\");\n    expect(keys).toContain(\"end\");\n    expect(keys).toContain(\"return\");\n    expect(keys).toContain(\"isDone\");\n    expect(symbols).toHaveLength(1);\n    expect(symbols).toContain(Symbol.asyncIterator);\n  });\n\n  it(\"should correctly implement getOwnPropertyDescriptor() trap\", () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    const nextDescriptor = Object.getOwnPropertyDescriptor(proxy, \"next\");\n    expect(nextDescriptor).toBeDefined();\n    expect(nextDescriptor?.enumerable).toBe(true);\n    expect(nextDescriptor?.configurable).toBe(true);\n    expect(typeof nextDescriptor?.value).toBe(\"function\");\n\n    const endDescriptor = Object.getOwnPropertyDescriptor(proxy, \"end\");\n    expect(endDescriptor).toBeDefined();\n    expect(endDescriptor?.enumerable).toBe(true);\n    expect(endDescriptor?.configurable).toBe(true);\n    expect(typeof endDescriptor?.value).toBe(\"function\");\n\n    const returnDescriptor = Object.getOwnPropertyDescriptor(proxy, \"return\");\n    expect(returnDescriptor).toBeDefined();\n    expect(returnDescriptor?.enumerable).toBe(true);\n    expect(returnDescriptor?.configurable).toBe(true);\n    expect(typeof returnDescriptor?.value).toBe(\"function\");\n\n    const asyncIteratorDescriptor = Object.getOwnPropertyDescriptor(\n      proxy,\n      Symbol.asyncIterator,\n    );\n    expect(asyncIteratorDescriptor).toBeDefined();\n    expect(asyncIteratorDescriptor?.enumerable).toBe(true);\n    expect(asyncIteratorDescriptor?.configurable).toBe(true);\n    expect(typeof asyncIteratorDescriptor?.value).toBe(\"function\");\n\n    // Non-exposed properties should return undefined\n    const callbackDescriptor = Object.getOwnPropertyDescriptor(\n      proxy,\n      \"callback\",\n    );\n    expect(callbackDescriptor).toBeUndefined();\n\n    const isDoneDescriptor = Object.getOwnPropertyDescriptor(proxy, \"isDone\");\n    expect(isDoneDescriptor).toBeDefined();\n    expect(isDoneDescriptor?.enumerable).toBe(true);\n    expect(isDoneDescriptor?.configurable).toBe(true);\n    expect(typeof isDoneDescriptor?.value).toBe(\"boolean\");\n  });\n\n  it(\"should handle concurrent operations through proxy\", async () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    const nextPromise1 = proxy.next();\n    const nextPromise2 = proxy.next();\n    const nextPromise3 = proxy.next();\n\n    stream.push(1);\n    stream.push(2);\n    stream.push(3);\n\n    const [result1, result2, result3] = await Promise.all([\n      nextPromise1,\n      nextPromise2,\n      nextPromise3,\n    ]);\n\n    expect(result1).toEqual({ done: false, value: 1 });\n    expect(result2).toEqual({ done: false, value: 2 });\n    expect(result3).toEqual({ done: false, value: 3 });\n  });\n\n  it(\"should work correctly when stream is already done\", async () => {\n    const stream = new AsyncStream<number>();\n    const proxy = createAsyncStreamProxy(stream);\n\n    stream.push(1);\n    await proxy.end();\n\n    const result1 = await proxy.next();\n    const result2 = await proxy.next();\n\n    expect(result1).toEqual({ done: true, value: undefined });\n    expect(result2).toEqual({ done: true, value: undefined });\n  });\n});\n",
      "size_bytes": 13172
    },
    "apps/xmtp.chat/src/components/CopyButton.tsx": {
      "content": "import { ActionIcon, Text, Tooltip } from \"@mantine/core\";\nimport { useClipboard } from \"@mantine/hooks\";\nimport { IconCopy } from \"@/icons/IconCopy\";\nimport classes from \"./CopyButton.module.css\";\n\ntype CopyButtonProps = {\n  value: string;\n};\n\nexport const CopyButton: React.FC<CopyButtonProps> = ({ value }) => {\n  const clipboard = useClipboard({ timeout: 1000 });\n\n  const handleCopy = () => {\n    clipboard.copy(value);\n  };\n\n  const handleKeyboardCopy = (\n    event: React.KeyboardEvent<HTMLButtonElement>,\n  ) => {\n    if (event.key === \"Enter\" || event.key === \" \") {\n      handleCopy();\n    }\n  };\n\n  return (\n    <Tooltip\n      label={\n        clipboard.copied ? (\n          <Text size=\"xs\">Copied!</Text>\n        ) : (\n          <Text size=\"xs\">Copy</Text>\n        )\n      }\n      withArrow\n      events={{ hover: true, focus: true, touch: true }}>\n      <ActionIcon\n        variant=\"transparent\"\n        onClick={handleCopy}\n        onKeyDown={handleKeyboardCopy}\n        aria-label=\"Copy\"\n        className={classes.button}>\n        <IconCopy />\n      </ActionIcon>\n    </Tooltip>\n  );\n};\n",
      "size_bytes": 1102
    },
    "apps/xmtp.chat/src/icons/IconX.tsx": {
      "content": "export type IconXProps = Omit<\n  React.SVGProps<SVGSVGElement>,\n  \"width\" | \"height\"\n> & {\n  size?: number;\n};\n\nexport const IconX: React.FC<IconXProps> = ({\n  size = 16,\n  color = \"currentColor\",\n  ...rest\n}) => {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width={size}\n      height={size}\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke={color}\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      {...rest}>\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M18 6l-12 12\" />\n      <path d=\"M6 6l12 12\" />\n    </svg>\n  );\n};\n",
      "size_bytes": 616
    },
    "content-types/content-type-primitives/README.md": {
      "content": "# Content type primitives\n\nThis package provides primitives for building custom XMTP content types.\n\n## Install the package\n\n```bash\n# npm\nnpm i @xmtp/content-type-primitives\n\n# yarn\nyarn add @xmtp/content-type-primitives\n\n# pnpm\npnpm i @xmtp/content-type-primitives\n```\n\n## Developing\n\nRun `yarn dev` to build the content type primitives and watch for changes, which will trigger a rebuild.\n\nFor more information on contributing to this repository, see our [contributing guidelines](../../CONTRIBUTING.md).\n",
      "size_bytes": 508
    },
    "apps/xmtp.chat/src/components/Messages/BreakableText.tsx": {
      "content": "import { Text, type TextProps } from \"@mantine/core\";\nimport type { ReactNode } from \"react\";\n\nexport type BreakableTextProps = TextProps & {\n  children: ReactNode;\n};\n\nexport const BreakableText: React.FC<BreakableTextProps> = ({\n  children,\n  style,\n  ...textProps\n}) => {\n  return (\n    <Text\n      style={{\n        whiteSpace: \"pre-wrap\",\n        wordBreak: \"break-word\",\n        fontFamily: \"inherit\",\n      }}\n      {...textProps}>\n      {children}\n    </Text>\n  );\n};\n\nexport default BreakableText;\n",
      "size_bytes": 506
    },
    "apps/xmtp.chat/src/components/Messages/TextContent.module.css": {
      "content": ".text {\n  cursor: text;\n  max-width: clamp(220px, 68vw, 520px);\n  line-height: 1.5;\n  font-size: 0.96rem;\n  box-shadow: 0 12px 26px rgba(4, 10, 26, 0.28);\n}\n\n.inbound {\n  background: rgba(12, 17, 28, 0.92);\n  color: rgba(226, 232, 240, 0.92);\n  border: 1px solid rgba(148, 163, 184, 0.16);\n}\n\n.outbound {\n  background: linear-gradient(135deg, #0afff1, #9772fb);\n  color: #041019;\n  border: 1px solid rgba(255, 255, 255, 0.18);\n}\n\n@media (max-width: 520px) {\n  .text {\n    max-width: 82vw;\n    font-size: 0.94rem;\n  }\n}\n",
      "size_bytes": 519
    },
    "apps/xmtp.chat/src/components/Conversations/ConversationList.module.css": {
      "content": ".root > * {\n  padding-top: var(--mantine-spacing-sm);\n}\n\n.root > *:last-child {\n  padding-bottom: var(--mantine-spacing-sm);\n}\n",
      "size_bytes": 127
    },
    "sdks/agent-sdk/src/user/NameResolver.ts": {
      "content": "import { escape } from \"node:querystring\";\nimport { isAddress } from \"viem\";\nimport { AgentError } from \"@/core/AgentError.js\";\nimport { LimitedMap } from \"@/utils/LimitedMap.js\";\n\nconst cache = new LimitedMap<string, string | null>(1000);\n\nconst fetchFromWeb3Bio = async (\n  name: string,\n  apiKey?: string,\n): Promise<{ address: string | null }[]> => {\n  const endpoint = `https://api.web3.bio/ns/${escape(name)}`;\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  if (apiKey) {\n    headers[\"X-API-KEY\"] = `Bearer ${apiKey}`;\n  }\n\n  const response = await fetch(endpoint, {\n    method: \"GET\",\n    headers,\n  });\n\n  if (!response.ok) {\n    throw new AgentError(\n      2000,\n      `Could not resolve address for name \"${name}\": ${response.statusText} (${response.status})`,\n    );\n  }\n\n  return response.json() as Promise<{ address: string | null }[]>;\n};\n\nconst resolveName = async (\n  name: string,\n  apiKey?: string,\n): Promise<string | null> => {\n  if (isAddress(name)) {\n    return name;\n  }\n\n  const cachedAddress = cache.get(name);\n\n  if (cachedAddress !== undefined) {\n    return cachedAddress;\n  }\n\n  const response = await fetchFromWeb3Bio(name, apiKey);\n  if (response.length === 0) {\n    return null;\n  }\n  const address = response[0]?.address;\n  if (!address) {\n    return null;\n  }\n  cache.set(name, address);\n  return address;\n};\n\nexport const createNameResolver = (apiKey?: string) => {\n  return (name: string) => resolveName(name, apiKey);\n};\n",
      "size_bytes": 1502
    },
    "apps/xmtp.chat/src/tailwind.css": {
      "content": "@tailwind base;\n@tailwind components;\n@tailwind utilities;\n",
      "size_bytes": 59
    },
    "content-types/content-type-read-receipt/src/index.ts": {
      "content": "export * from \"./ReadReceipt\";\n",
      "size_bytes": 31
    },
    "apps/xmtp.chat/src/components/Conversation/MemberListItem.tsx": {
      "content": "import { Box } from \"@mantine/core\";\nimport { MemberCard } from \"@/components/Conversation/MemberCard\";\nimport {\n  MemberPopover,\n  type MemberPopoverProps,\n} from \"@/components/Conversation/MemberPopover\";\n\nexport type MemberListItemProps = MemberPopoverProps;\n\nexport const MemberListItem: React.FC<MemberListItemProps> = (props) => {\n  return (\n    <Box px=\"sm\">\n      <MemberPopover {...props} position=\"left\">\n        <MemberCard\n          address={props.address}\n          displayName={props.displayName}\n          avatar={props.avatar}\n          description={props.description}\n        />\n      </MemberPopover>\n    </Box>\n  );\n};\n",
      "size_bytes": 638
    },
    "eslint.config.js": {
      "content": "import path from \"node:path\";\nimport process from \"node:process\";\nimport { fileURLToPath } from \"node:url\";\nimport { includeIgnoreFile } from \"@eslint/compat\";\nimport eslint from \"@eslint/js\";\nimport eslintPluginPrettierRecommended from \"eslint-plugin-prettier/recommended\";\nimport globals from \"globals\";\nimport tseslint from \"typescript-eslint\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst gitignorePath = path.resolve(__dirname, \".gitignore\");\n\nexport default tseslint.config(\n  includeIgnoreFile(gitignorePath),\n  {\n    ignores: [\".yarn/**/*\", \"apps/xmtp.chat-api-service/prisma/generated/**/*\"],\n  },\n  eslint.configs.recommended,\n  ...tseslint.configs.strictTypeChecked,\n  {\n    languageOptions: {\n      parserOptions: {\n        projectService: {\n          defaultProject: \"tsconfig.json\",\n        },\n        tsconfigRootDir: process.cwd(),\n      },\n    },\n  },\n  {\n    rules: {\n      \"@typescript-eslint/no-unnecessary-type-parameters\": \"off\",\n      \"@typescript-eslint/consistent-type-exports\": [\n        \"error\",\n        {\n          fixMixedExportsWithInlineTypeSpecifier: false,\n        },\n      ],\n      \"@typescript-eslint/consistent-type-imports\": \"error\",\n      \"@typescript-eslint/no-deprecated\": \"warn\",\n      \"@typescript-eslint/no-explicit-any\": \"warn\",\n      \"@typescript-eslint/no-unused-vars\": [\n        \"error\",\n        {\n          argsIgnorePattern: \"^_\",\n          destructuredArrayIgnorePattern: \"^_\",\n          ignoreRestSiblings: true,\n          varsIgnorePattern: \"^_\",\n        },\n      ],\n      \"@typescript-eslint/restrict-template-expressions\": [\n        \"error\",\n        {\n          allowNumber: true,\n        },\n      ],\n    },\n  },\n  {\n    files: [\"**/*.cjs\", \"**/*.js\"],\n    extends: [tseslint.configs.disableTypeChecked],\n    languageOptions: {\n      globals: {\n        ...globals.node,\n      },\n    },\n    rules: {\n      \"@typescript-eslint/no-require-imports\": \"off\",\n    },\n  },\n  {\n    files: [\"**/*.test.ts\"],\n    rules: {\n      \"@typescript-eslint/no-non-null-assertion\": \"off\",\n    },\n  },\n  {\n    files: [\"sdks/js-sdk/**/*.ts\"],\n    rules: {\n      \"no-restricted-syntax\": [\n        \"error\",\n        {\n          selector: \"ImportDeclaration[source.value=/^(node:)?crypto$/]\",\n          message:\n            \"Do not import directly from `crypto`, use `@/encryption` instead.\",\n        },\n      ],\n    },\n  },\n  {\n    files: [\"sdks/js-sdk/test/**/*.ts\"],\n    rules: {\n      \"@typescript-eslint/no-floating-promises\": \"off\",\n      \"@typescript-eslint/no-unsafe-member-access\": \"off\",\n      \"@typescript-eslint/no-unsafe-assignment\": \"off\",\n      \"@typescript-eslint/no-unsafe-return\": \"off\",\n      \"@typescript-eslint/no-unsafe-argument\": \"off\",\n      \"@typescript-eslint/no-unsafe-call\": \"off\",\n      \"@typescript-eslint/no-confusing-void-expression\": \"off\",\n      \"@typescript-eslint/require-await\": \"off\",\n      \"@typescript-eslint/await-thenable\": \"off\",\n      \"@typescript-eslint/no-unnecessary-condition\": \"off\",\n      \"@typescript-eslint/no-explicit-any\": \"off\",\n      \"@typescript-eslint/only-throw-error\": \"off\",\n      \"@typescript-eslint/unbound-method\": \"off\",\n      \"@typescript-eslint/no-misused-promises\": \"off\",\n      \"@typescript-eslint/no-unnecessary-type-arguments\": \"off\",\n      \"@typescript-eslint/no-unnecessary-type-assertion\": \"off\",\n      \"@typescript-eslint/no-deprecated\": \"off\",\n      \"@typescript-eslint/restrict-plus-operands\": \"off\",\n      \"@typescript-eslint/no-unused-vars\": \"off\",\n      \"@typescript-eslint/ban-ts-comment\": \"off\",\n      \"@typescript-eslint/no-non-null-assertion\": \"off\",\n      \"no-empty\": \"off\",\n    },\n  },\n  {\n    files: [\"sdks/**/*.ts\"],\n    rules: {\n      \"no-restricted-syntax\": [\n        \"error\",\n        {\n          selector: \"ImportDeclaration[source.value=/^\\\\.\\\\./]\",\n          message:\n            \"Relative parent imports are not allowed, use path aliases instead.\",\n        },\n      ],\n    },\n  },\n  {\n    files: [\"sdks/agent-sdk/**/*.ts\"],\n    rules: {\n      \"@typescript-eslint/no-misused-promises\": \"off\",\n      \"no-empty\": [\"error\", { allowEmptyCatch: true }],\n    },\n  },\n  eslintPluginPrettierRecommended,\n);\n",
      "size_bytes": 4176
    },
    "apps/xmtp.chat/src/icons/IconPlus.tsx": {
      "content": "export const IconPlus = ({\n  size = 20,\n  color = \"currentColor\",\n  ...props\n}: {\n  size?: number;\n  color?: string;\n}) => (\n  <svg\n    width={size}\n    height={size}\n    viewBox=\"0 0 24 24\"\n    fill=\"none\"\n    stroke={color}\n    strokeWidth=\"2\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n    {...props}>\n    <line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\" />\n    <line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\" />\n  </svg>\n);\n",
      "size_bytes": 415
    },
    "content-types/content-type-markdown/src/Markdown.ts": {
      "content": "import {\n  ContentTypeId,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\n\nexport const ContentTypeMarkdown = new ContentTypeId({\n  authorityId: \"xmtp.org\",\n  typeId: \"markdown\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\nexport enum Encoding {\n  utf8 = \"UTF-8\",\n  unknown = \"unknown\",\n}\n\nexport type TextParameters = {\n  encoding: Encoding;\n};\n\nexport class MarkdownCodec implements ContentCodec<string, TextParameters> {\n  get contentType(): ContentTypeId {\n    return ContentTypeMarkdown;\n  }\n\n  encode(content: string) {\n    return {\n      type: ContentTypeMarkdown,\n      parameters: { encoding: Encoding.utf8 },\n      content: new TextEncoder().encode(content),\n    };\n  }\n\n  decode(content: EncodedContent<TextParameters>) {\n    if (content.parameters.encoding !== Encoding.utf8) {\n      throw new Error(`unrecognized encoding ${content.parameters.encoding}`);\n    }\n    return new TextDecoder().decode(content.content);\n  }\n\n  fallback() {\n    return undefined;\n  }\n\n  shouldPush() {\n    return true;\n  }\n}\n",
      "size_bytes": 1051
    },
    "content-types/content-type-remote-attachment/src/Attachment.test.ts": {
      "content": "import { Client, IdentifierKind, type Signer } from \"@xmtp/node-sdk\";\nimport { createWalletClient, http, toBytes } from \"viem\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { sepolia } from \"viem/chains\";\nimport {\n  AttachmentCodec,\n  ContentTypeAttachment,\n  type Attachment,\n} from \"./Attachment\";\n\nexport const createSigner = (): Signer => {\n  const account = privateKeyToAccount(generatePrivateKey());\n  const wallet = createWalletClient({\n    account,\n    chain: sepolia,\n    transport: http(),\n  });\n  return {\n    type: \"EOA\",\n    getIdentifier: () => ({\n      identifierKind: IdentifierKind.Ethereum,\n      identifier: account.address.toLowerCase(),\n    }),\n    signMessage: async (message: string) => {\n      const signature = await wallet.signMessage({\n        message,\n      });\n      return toBytes(signature);\n    },\n  };\n};\n\ntest(\"content type exists\", () => {\n  expect(ContentTypeAttachment.authorityId).toBe(\"xmtp.org\");\n  expect(ContentTypeAttachment.typeId).toBe(\"attachment\");\n  expect(ContentTypeAttachment.versionMajor).toBe(1);\n  expect(ContentTypeAttachment.versionMinor).toBe(0);\n});\n\ntest(\"can send an attachment\", async () => {\n  const signer1 = createSigner();\n  const client1 = await Client.create(signer1, {\n    codecs: [new AttachmentCodec()],\n    env: \"local\",\n  });\n\n  const signer2 = createSigner();\n  const client2 = await Client.create(signer2, {\n    codecs: [new AttachmentCodec()],\n    env: \"local\",\n  });\n\n  const dm = await client1.conversations.newDm(client2.inboxId);\n\n  const attachment: Attachment = {\n    filename: \"test.png\",\n    mimeType: \"image/png\",\n    data: Uint8Array.from([5, 4, 3, 2, 1]),\n  };\n\n  await dm.send(attachment, ContentTypeAttachment);\n\n  await client2.conversations.sync();\n  const dms = client2.conversations.listDms();\n\n  expect(dms.length).toBe(1);\n\n  await dms[0].sync();\n  const messages = await dms[0].messages();\n  expect(messages.length).toBe(2);\n\n  const message = messages[1];\n  const messageContent = message.content as Attachment;\n  expect(messageContent.filename).toBe(\"test.png\");\n  expect(messageContent.mimeType).toBe(\"image/png\");\n  expect(messageContent.data).toStrictEqual(Uint8Array.from([5, 4, 3, 2, 1]));\n});\n\ntest(\"has a proper shouldPush value\", () => {\n  const codec = new AttachmentCodec();\n  expect(codec.shouldPush()).toBe(true);\n});\n",
      "size_bytes": 2362
    },
    "apps/xmtp.chat/src/components/App/BlockchainSelect.tsx": {
      "content": "import { Group, NativeSelect, Text, Tooltip } from \"@mantine/core\";\nimport { useMemo, useState } from \"react\";\nimport { useSwitchChain } from \"wagmi\";\nimport {\n  arbitrum,\n  base,\n  linea,\n  mainnet,\n  optimism,\n  polygon,\n  worldchain,\n  zksync,\n} from \"wagmi/chains\";\nimport { useSettings } from \"@/hooks/useSettings\";\n\nconst ALLOWED_CHAINS: number[] = [\n  arbitrum.id,\n  base.id,\n  linea.id,\n  mainnet.id,\n  optimism.id,\n  polygon.id,\n  worldchain.id,\n  zksync.id,\n];\n\nexport const BlockchainSelect: React.FC = () => {\n  const { blockchain, setBlockchain, useSCW, ephemeralAccountEnabled } =\n    useSettings();\n  const { chains, switchChain } = useSwitchChain();\n  const [loading, setLoading] = useState(false);\n\n  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {\n    setLoading(true);\n    switchChain(\n      {\n        chainId: parseInt(event.currentTarget.value),\n      },\n      {\n        onSuccess(data) {\n          setBlockchain(data.id);\n        },\n        onError(error) {\n          console.error(\"An error occurred while switching chain\", error);\n        },\n        onSettled() {\n          setLoading(false);\n        },\n      },\n    );\n  };\n\n  const options = useMemo(\n    () =>\n      chains\n        .filter((chain) => ALLOWED_CHAINS.includes(chain.id))\n        .map((chain) => ({\n          value: chain.id.toString(),\n          label: chain.name,\n        })),\n    [chains],\n  );\n\n  return (\n    <Group gap=\"sm\" align=\"center\" wrap=\"nowrap\">\n      <Text fw=\"bold\" size=\"sm\" style={{ display: \"none\" }}>\n        Blockchain\n      </Text>\n      <Tooltip label=\"Select the blockchain to use for signing smart contract wallet messages\">\n        <NativeSelect\n          disabled={loading || !useSCW || ephemeralAccountEnabled}\n          data={options}\n          value={blockchain.toString()}\n          onChange={handleChange}\n        />\n      </Tooltip>\n    </Group>\n  );\n};\n",
      "size_bytes": 1901
    },
    "apps/xmtp.chat/src/hooks/useClientPermissions.ts": {
      "content": "import { PermissionPolicy } from \"@xmtp/browser-sdk\";\nimport { useMemo } from \"react\";\nimport { useClient } from \"@/contexts/XMTPContext\";\nimport { useConversation } from \"@/hooks/useConversation\";\n\n// TODO: remove this once types are fixed\nexport type AdjustedPermissionLevel = \"SuperAdmin\" | \"Admin\" | \"Member\";\n\nconst hasPermission = (\n  permissionLevel: AdjustedPermissionLevel,\n  policy?: PermissionPolicy,\n) => {\n  if (\n    policy === undefined ||\n    policy === PermissionPolicy.Deny ||\n    policy === PermissionPolicy.Other ||\n    policy === PermissionPolicy.DoesNotExist\n  ) {\n    return false;\n  }\n  if (policy === PermissionPolicy.Allow) {\n    return true;\n  }\n\n  switch (permissionLevel) {\n    case \"SuperAdmin\":\n      // super admin can do anything\n      return true;\n    case \"Admin\":\n      return policy === PermissionPolicy.Admin;\n    default:\n      return false;\n  }\n};\n\nexport type ClientPermissions = {\n  canAddMembers: boolean;\n  canRemoveMembers: boolean;\n  canPromoteMembers: boolean;\n  canDemoteMembers: boolean;\n  canChangeGroupName: boolean;\n  canChangeGroupDescription: boolean;\n  canChangeGroupImage: boolean;\n  canChangeMessageDisappearingPolicy: boolean;\n  canChangePermissionsPolicy: boolean;\n};\n\nexport const useClientPermissions = (\n  conversationId: string,\n): ClientPermissions => {\n  const { permissions, members } = useConversation(conversationId);\n  const client = useClient();\n\n  const clientPermissionLevel: AdjustedPermissionLevel = useMemo(() => {\n    if (client.inboxId) {\n      const member = members.get(client.inboxId);\n      // TODO: remove this once the types are fixed\n      const level = member?.permissionLevel as unknown as\n        | AdjustedPermissionLevel\n        | undefined;\n      return level ?? \"Member\";\n    }\n    return \"Member\";\n  }, [members, client.inboxId]);\n\n  return useMemo(() => {\n    return {\n      canAddMembers: hasPermission(\n        clientPermissionLevel,\n        permissions?.policySet.addMemberPolicy,\n      ),\n      canRemoveMembers: hasPermission(\n        clientPermissionLevel,\n        permissions?.policySet.removeMemberPolicy,\n      ),\n      canPromoteMembers: hasPermission(\n        clientPermissionLevel,\n        permissions?.policySet.addAdminPolicy,\n      ),\n      canDemoteMembers: hasPermission(\n        clientPermissionLevel,\n        permissions?.policySet.removeAdminPolicy,\n      ),\n      canChangeGroupName: hasPermission(\n        clientPermissionLevel,\n        permissions?.policySet.updateGroupNamePolicy,\n      ),\n      canChangeGroupDescription: hasPermission(\n        clientPermissionLevel,\n        permissions?.policySet.updateGroupDescriptionPolicy,\n      ),\n      canChangeGroupImage: hasPermission(\n        clientPermissionLevel,\n        permissions?.policySet.updateGroupImageUrlSquarePolicy,\n      ),\n      canChangeMessageDisappearingPolicy: hasPermission(\n        clientPermissionLevel,\n        permissions?.policySet.updateMessageDisappearingPolicy,\n      ),\n      canChangePermissionsPolicy: clientPermissionLevel === \"SuperAdmin\",\n    };\n  }, [clientPermissionLevel, permissions]);\n};\n",
      "size_bytes": 3090
    },
    "apps/xmtp.chat/src/components/Modal.tsx": {
      "content": "import { Modal as MantineModal, type ModalProps } from \"@mantine/core\";\n\nexport const Modal: React.FC<ModalProps> = ({ children, ...props }) => {\n  return (\n    <MantineModal\n      {...props}\n      radius=\"md\"\n      styles={{\n        content: {\n          display: \"flex\",\n          flexDirection: \"column\",\n        },\n        body: {\n          display: \"flex\",\n          flexDirection: \"column\",\n          flexGrow: 1,\n        },\n      }}>\n      {children}\n    </MantineModal>\n  );\n};\n",
      "size_bytes": 485
    },
    "sdks/browser-sdk/test/Client.test.ts": {
      "content": "import { v4 } from \"uuid\";\nimport { describe, expect, it } from \"vitest\";\nimport { Client } from \"@/Client\";\nimport { SignerUnavailableError } from \"@/utils/errors\";\nimport {\n  buildClient,\n  createClient,\n  createIdentifier,\n  createRegisteredClient,\n  createSigner,\n  createUser,\n} from \"@test/helpers\";\n\ndescribe(\"Client\", () => {\n  it(\"should create a client\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createClient(signer);\n    expect(client.accountIdentifier).toEqual({\n      identifier: user.account.address.toLowerCase(),\n      identifierKind: \"Ethereum\",\n    });\n    expect(await client.isRegistered()).toBe(false);\n    expect(client.inboxId).toBeDefined();\n    expect(client.installationId).toBeDefined();\n  });\n\n  it(\"should register an identity\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer);\n    expect(await client2.isRegistered()).toBe(true);\n  });\n\n  it(\"should be able to message registered identity\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const canMessage = await client.canMessage([await signer.getIdentifier()]);\n    expect(Object.fromEntries(canMessage)).toEqual({\n      [user.account.address.toLowerCase()]: true,\n    });\n  });\n\n  it(\"should be able to check if can message without client instance\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    await createRegisteredClient(signer);\n    const canMessage = await Client.canMessage(\n      [await signer.getIdentifier()],\n      \"local\",\n    );\n    expect(Object.fromEntries(canMessage)).toEqual({\n      [user.account.address.toLowerCase()]: true,\n    });\n  });\n\n  it(\"should get an inbox ID from an address\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const inboxId = await client.findInboxIdByIdentifier(\n      await signer.getIdentifier(),\n    );\n    expect(inboxId).toBe(client.inboxId);\n  });\n\n  it(\"should return the correct inbox state\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const inboxState = await client.preferences.inboxState(false);\n    expect(inboxState.inboxId).toBe(client.inboxId);\n    expect(inboxState.installations.map((install) => install.id)).toEqual([\n      client.installationId,\n    ]);\n    expect(inboxState.identifiers).toEqual([await signer.getIdentifier()]);\n    expect(inboxState.recoveryIdentifier).toEqual(await signer.getIdentifier());\n\n    const user2 = createUser();\n    const signer2 = createSigner(user2);\n    const client2 = await createClient(signer2);\n    const inboxState2 = await client2.preferences.getLatestInboxState(\n      client.inboxId!,\n    );\n    expect(inboxState2.inboxId).toBe(client.inboxId);\n    expect(inboxState.installations.length).toBe(1);\n    expect(inboxState.installations[0].id).toBe(client.installationId);\n    expect(inboxState.installations[0].bytes).toEqual(\n      client.installationIdBytes,\n    );\n    expect(inboxState2.identifiers).toEqual([await signer.getIdentifier()]);\n    expect(inboxState2.recoveryIdentifier).toEqual(\n      await signer.getIdentifier(),\n    );\n  });\n\n  it(\"should add a wallet association to the client\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n\n    const user2 = createUser();\n    const signer2 = createSigner(user2);\n\n    await client.unsafe_addAccount(signer2, true);\n    const inboxState = await client.preferences.inboxState();\n    expect(inboxState.identifiers.length).toEqual(2);\n    expect(inboxState.identifiers).toContainEqual(await signer.getIdentifier());\n    expect(inboxState.identifiers).toContainEqual(\n      await signer2.getIdentifier(),\n    );\n  });\n\n  it(\"should revoke a wallet association from the client\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n\n    const user2 = createUser();\n    const signer2 = createSigner(user2);\n\n    await client.unsafe_addAccount(signer2, true);\n    await client.removeAccount(await signer2.getIdentifier());\n\n    const inboxState = await client.preferences.inboxState();\n    expect(inboxState.identifiers).toEqual([await signer.getIdentifier()]);\n  });\n\n  it(\"should revoke all other installations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client3 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    const inboxState = await client3.preferences.inboxState(true);\n    expect(inboxState.installations.length).toBe(3);\n\n    const installationIds = inboxState.installations.map((i) => i.id);\n    expect(installationIds).toContain(client.installationId);\n    expect(installationIds).toContain(client2.installationId);\n    expect(installationIds).toContain(client3.installationId);\n\n    await client3.revokeAllOtherInstallations();\n\n    const inboxState2 = await client3.preferences.inboxState(true);\n\n    expect(inboxState2.installations.length).toBe(1);\n    expect(inboxState2.installations[0].id).toBe(client3.installationId);\n  });\n\n  it(\"should revoke specific installations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client3 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    const inboxState = await client3.preferences.inboxState(true);\n    expect(inboxState.installations.length).toBe(3);\n\n    const installationIds = inboxState.installations.map((i) => i.id);\n    expect(installationIds).toContain(client.installationId);\n    expect(installationIds).toContain(client2.installationId);\n    expect(installationIds).toContain(client3.installationId);\n\n    await client3.revokeInstallations([client.installationIdBytes!]);\n\n    const inboxState2 = await client3.preferences.inboxState(true);\n\n    expect(inboxState2.installations.length).toBe(2);\n\n    const installationIds2 = inboxState2.installations.map((i) => i.id);\n    expect(installationIds2).toContain(client2.installationId);\n    expect(installationIds2).toContain(client3.installationId);\n    expect(installationIds2).not.toContain(client.installationId);\n  });\n\n  it(\"should throw when trying to create more than 10 installations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client3 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client4 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client5 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client6 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client7 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client8 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client9 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client10 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    const inboxState = await client3.preferences.inboxState(true);\n    expect(inboxState.installations.length).toBe(10);\n\n    const installationIds = inboxState.installations.map((i) => i.id);\n    expect(installationIds).toContain(client.installationId);\n    expect(installationIds).toContain(client2.installationId);\n    expect(installationIds).toContain(client3.installationId);\n    expect(installationIds).toContain(client4.installationId);\n    expect(installationIds).toContain(client5.installationId);\n    expect(installationIds).toContain(client6.installationId);\n    expect(installationIds).toContain(client7.installationId);\n    expect(installationIds).toContain(client8.installationId);\n    expect(installationIds).toContain(client9.installationId);\n    expect(installationIds).toContain(client10.installationId);\n\n    await expect(\n      createRegisteredClient(signer, {\n        dbPath: `./test-${v4()}.db3`,\n      }),\n    ).rejects.toThrow();\n\n    await client3.revokeAllOtherInstallations();\n\n    const inboxState2 = await client3.preferences.inboxState(true);\n\n    expect(inboxState2.installations.length).toBe(1);\n    expect(inboxState2.installations[0].id).toBe(client3.installationId);\n\n    const client11 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    const inboxState3 = await client11.preferences.inboxState(true);\n    expect(inboxState3.installations.length).toBe(2);\n    const installationIds3 = inboxState3.installations.map((i) => i.id);\n    expect(installationIds3).toContain(client3.installationId);\n    expect(installationIds3).toContain(client11.installationId);\n  });\n\n  it(\"should change the recovery identifier\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n\n    const user2 = createUser();\n    const signer2 = createSigner(user2);\n    await createRegisteredClient(signer2);\n\n    await client.changeRecoveryIdentifier(await signer2.getIdentifier());\n\n    const inboxState = await client.preferences.inboxState();\n    expect(inboxState.recoveryIdentifier).toEqual(\n      await signer2.getIdentifier(),\n    );\n  });\n\n  it(\"should get key package statuses for installation ids\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n\n    const statuses = await client.getKeyPackageStatusesForInstallationIds([\n      client.installationId!,\n    ]);\n    expect(statuses.size).toBe(1);\n\n    const status = statuses.get(client.installationId!);\n    expect(status).toBeDefined();\n    expect(status?.lifetime).toBeDefined();\n    expect(status?.validationError).toBeUndefined();\n  });\n\n  it(\"should create a client without a signer\", async () => {\n    const user = createUser();\n    const identifier = createIdentifier(user);\n    const client = await buildClient(identifier);\n    expect(client).toBeDefined();\n    expect(client.accountIdentifier).toEqual(identifier);\n    expect(await client.isRegistered()).toBe(false);\n    expect(client.inboxId).toBeDefined();\n    expect(client.installationId).toBeDefined();\n\n    const user2 = createUser();\n    const signer2 = createSigner(user2);\n\n    await expect(() => client.register()).rejects.toThrow(\n      new SignerUnavailableError(),\n    );\n\n    await expect(async () =>\n      client.removeAccount(await signer2.getIdentifier()),\n    ).rejects.toThrow(new SignerUnavailableError());\n\n    await expect(() => client.revokeInstallations([])).rejects.toThrow(\n      new SignerUnavailableError(),\n    );\n\n    await expect(() => client.revokeAllOtherInstallations()).rejects.toThrow(\n      new SignerUnavailableError(),\n    );\n\n    await expect(async () =>\n      client.changeRecoveryIdentifier(await signer2.getIdentifier()),\n    ).rejects.toThrow(new SignerUnavailableError());\n  });\n\n  it(\"should get inbox state from inbox ids without a client\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const inboxState = await Client.inboxStateFromInboxIds(\n      [client.inboxId!],\n      \"local\",\n    );\n    expect(inboxState.length).toBe(1);\n    expect(inboxState[0].inboxId).toBe(client.inboxId);\n    expect(inboxState[0].identifiers).toEqual([await signer.getIdentifier()]);\n  });\n});\n",
      "size_bytes": 12418
    },
    "apps/xmtp.chat/src/components/Messages/Message.tsx": {
      "content": "import { Box, Button, Group } from \"@mantine/core\";\nimport type { DecodedMessage } from \"@xmtp/browser-sdk\";\nimport { useNavigate } from \"react-router\";\nimport { useConversationContext } from \"@/contexts/ConversationContext\";\nimport { useClient } from \"@/contexts/XMTPContext\";\nimport { isActionable } from \"@/helpers/messages\";\nimport classes from \"./Message.module.css\";\nimport { MessageContentWithWrapper } from \"./MessageContentWithWrapper\";\nimport { ReactionPopover } from \"./ReactionPopover\";\n\nexport type MessageProps = {\n  message: DecodedMessage;\n  scrollToMessage: (id: string) => void;\n};\n\nexport const Message: React.FC<MessageProps> = ({\n  message,\n  scrollToMessage,\n}) => {\n  const navigate = useNavigate();\n  const { setReplyTarget } = useConversationContext();\n  const client = useClient();\n\n  const isSender = client.inboxId === message.senderInboxId;\n  const align = isSender ? \"right\" : \"left\";\n  const hasActions = isActionable(message);\n\n  return (\n    <Box p=\"md\" tabIndex={0} className={classes.root}>\n      <Box\n        tabIndex={0}\n        onKeyDown={(e) => {\n          if (e.key === \"Enter\") {\n            void navigate(\n              `/conversations/${message.conversationId}/message/${message.id}`,\n            );\n          }\n        }}\n        onClick={() =>\n          void navigate(\n            `/conversations/${message.conversationId}/message/${message.id}`,\n          )\n        }>\n        <MessageContentWithWrapper\n          message={message}\n          align={align}\n          senderInboxId={message.senderInboxId}\n          scrollToMessage={scrollToMessage}\n        />\n      </Box>\n      {hasActions && (\n        <Group justify={align === \"left\" ? \"flex-start\" : \"flex-end\"} mt={4}>\n          <ReactionPopover message={message} />\n          <Button\n            size=\"compact-xs\"\n            variant=\"subtle\"\n            onClick={() => {\n              setReplyTarget(message);\n            }}>\n            Reply\n          </Button>\n        </Group>\n      )}\n    </Box>\n  );\n};\n",
      "size_bytes": 2011
    },
    "content-types/content-type-remote-attachment/src/encryption/crypto.ts": {
      "content": "import { webcrypto } from \"node:crypto\";\n\nconst crypto = webcrypto;\nexport default crypto;\n",
      "size_bytes": 91
    },
    "content-types/content-type-remote-attachment/src/encryption/encryption.ts": {
      "content": "import type { ciphertext } from \"@xmtp/proto\";\nimport Ciphertext, { AESGCMNonceSize, KDFSaltSize } from \"./Ciphertext\";\nimport crypto from \"./crypto\";\n\nconst hkdfNoInfo = new Uint8Array().buffer;\nconst hkdfNoSalt = new Uint8Array().buffer;\n\n// This is a variation of https://github.com/paulmillr/noble-secp256k1/blob/main/index.ts#L1378-L1388\n// that uses `digest('SHA-256', bytes)` instead of `digest('SHA-256', bytes.buffer)`\n// which seems to produce different results.\nexport async function sha256(bytes: Uint8Array): Promise<Uint8Array> {\n  return new Uint8Array(await crypto.subtle.digest(\"SHA-256\", bytes));\n}\n\n// symmetric authenticated encryption of plaintext using the secret;\n// additionalData is used to protect un-encrypted parts of the message (header)\n// in the authentication scope of the encryption.\nexport async function encrypt(\n  plain: Uint8Array,\n  secret: Uint8Array,\n  additionalData?: Uint8Array,\n): Promise<Ciphertext> {\n  const salt = crypto.getRandomValues(new Uint8Array(KDFSaltSize));\n  const nonce = crypto.getRandomValues(new Uint8Array(AESGCMNonceSize));\n  const key = await hkdf(secret, salt);\n  const encrypted: ArrayBuffer = await crypto.subtle.encrypt(\n    aesGcmParams(nonce, additionalData),\n    key,\n    plain,\n  );\n  return new Ciphertext({\n    aes256GcmHkdfSha256: {\n      payload: new Uint8Array(encrypted),\n      hkdfSalt: salt,\n      gcmNonce: nonce,\n    },\n  });\n}\n\n// symmetric authenticated decryption of the encrypted ciphertext using the secret and additionalData\nexport async function decrypt(\n  encrypted: Ciphertext | ciphertext.Ciphertext,\n  secret: Uint8Array,\n  additionalData?: Uint8Array,\n): Promise<Uint8Array> {\n  if (!encrypted.aes256GcmHkdfSha256) {\n    throw new Error(\"invalid payload ciphertext\");\n  }\n  const key = await hkdf(secret, encrypted.aes256GcmHkdfSha256.hkdfSalt);\n  const decrypted: ArrayBuffer = await crypto.subtle.decrypt(\n    aesGcmParams(encrypted.aes256GcmHkdfSha256.gcmNonce, additionalData),\n    key,\n    encrypted.aes256GcmHkdfSha256.payload,\n  );\n  return new Uint8Array(decrypted);\n}\n\n// helper for building Web Crypto API encryption parameter structure\nfunction aesGcmParams(\n  nonce: Uint8Array,\n  additionalData?: Uint8Array,\n): AesGcmParams {\n  const spec: AesGcmParams = {\n    name: \"AES-GCM\",\n    iv: nonce as Uint8Array<ArrayBuffer>,\n  };\n  if (additionalData) {\n    spec.additionalData = additionalData as Uint8Array<ArrayBuffer>;\n  }\n  return spec;\n}\n\n// Derive AES-256-GCM key from a shared secret and salt.\n// Returns crypto.CryptoKey suitable for the encrypt/decrypt API\nasync function hkdf(secret: Uint8Array, salt: Uint8Array): Promise<CryptoKey> {\n  const key = await crypto.subtle.importKey(\"raw\", secret, \"HKDF\", false, [\n    \"deriveKey\",\n  ]);\n  return crypto.subtle.deriveKey(\n    { name: \"HKDF\", hash: \"SHA-256\", salt, info: hkdfNoInfo },\n    key,\n    { name: \"AES-GCM\", length: 256 },\n    false,\n    [\"encrypt\", \"decrypt\"],\n  );\n}\n\nexport async function hkdfHmacKey(\n  secret: Uint8Array,\n  info: Uint8Array,\n): Promise<CryptoKey> {\n  const key = await crypto.subtle.importKey(\"raw\", secret, \"HKDF\", false, [\n    \"deriveKey\",\n  ]);\n  return crypto.subtle.deriveKey(\n    { name: \"HKDF\", hash: \"SHA-256\", salt: hkdfNoSalt, info },\n    key,\n    { name: \"HMAC\", hash: \"SHA-256\", length: 256 },\n    true,\n    [\"sign\", \"verify\"],\n  );\n}\n\nexport async function generateHmacSignature(\n  secret: Uint8Array,\n  info: Uint8Array,\n  message: Uint8Array,\n): Promise<Uint8Array> {\n  const key = await hkdfHmacKey(secret, info);\n  const signed = await crypto.subtle.sign(\"HMAC\", key, message);\n  return new Uint8Array(signed);\n}\n\nexport async function verifyHmacSignature(\n  key: CryptoKey,\n  signature: Uint8Array,\n  message: Uint8Array,\n): Promise<boolean> {\n  return await crypto.subtle.verify(\"HMAC\", key, signature, message);\n}\n\nexport async function exportHmacKey(key: CryptoKey): Promise<Uint8Array> {\n  const exported = await crypto.subtle.exportKey(\"raw\", key);\n  return new Uint8Array(exported);\n}\n\nexport async function importHmacKey(key: Uint8Array): Promise<CryptoKey> {\n  return crypto.subtle.importKey(\n    \"raw\",\n    key,\n    { name: \"HMAC\", hash: \"SHA-256\", length: 256 },\n    true,\n    [\"sign\", \"verify\"],\n  );\n}\n",
      "size_bytes": 4225
    },
    "apps/xmtp.chat/src/components/Messages/IntentContent.tsx": {
      "content": "import { Badge, Group, Text } from \"@mantine/core\";\nimport { DateLabel } from \"@/components/DateLabel\";\nimport { IdentityBadge } from \"@/components/IdentityBadge\";\nimport type { Intent } from \"@/content-types/Intent\";\nimport { useConversationContext } from \"@/contexts/ConversationContext\";\nimport { nsToDate } from \"@/helpers/date\";\nimport { MEMBER_NO_LONGER_IN_GROUP } from \"@/helpers/strings\";\nimport { getMemberAddress } from \"@/helpers/xmtp\";\nimport { useConversation } from \"@/hooks/useConversation\";\n\nexport type IntentContentProps = {\n  content: Intent;\n  sentAtNs: bigint;\n  senderInboxId: string;\n};\n\nexport const IntentContent: React.FC<IntentContentProps> = ({\n  senderInboxId,\n  content,\n  sentAtNs,\n}) => {\n  const { conversationId } = useConversationContext();\n  const { members } = useConversation(conversationId);\n  const senderMember = members.get(senderInboxId);\n  return (\n    <>\n      <DateLabel date={nsToDate(sentAtNs)} align=\"center\" padding=\"sm\" />\n      <Group gap=\"4\" wrap=\"wrap\" justify=\"center\">\n        <IdentityBadge\n          address={senderMember ? getMemberAddress(senderMember) : \"\"}\n          displayName={senderInboxId}\n          tooltip={senderMember ? undefined : MEMBER_NO_LONGER_IN_GROUP}\n        />\n        <Text size=\"sm\">selected the</Text>\n        <Badge\n          radius=\"md\"\n          variant=\"default\"\n          size=\"lg\"\n          styles={{\n            label: {\n              textTransform: \"none\",\n            },\n          }}>\n          {content.actionId}\n        </Badge>\n        <Text size=\"sm\">action</Text>\n      </Group>\n    </>\n  );\n};\n",
      "size_bytes": 1592
    },
    "content-types/content-type-read-receipt/vitest.config.ts": {
      "content": "import { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    globalSetup: [\"./vitest.setup.ts\"],\n  },\n});\n",
      "size_bytes": 155
    },
    "sdks/browser-sdk/src/Dm.ts": {
      "content": "import type { Client } from \"@/Client\";\nimport { Conversation } from \"@/Conversation\";\nimport type { SafeConversation } from \"@/utils/conversions\";\n\n/**\n * Represents a direct message conversation between two inboxes\n *\n * This class is not intended to be initialized directly.\n */\nexport class Dm<ContentTypes = unknown> extends Conversation<ContentTypes> {\n  #client: Client<ContentTypes>;\n  #id: string;\n\n  /**\n   * Creates a new direct message conversation instance\n   *\n   * @param client - The client instance managing this direct message conversation\n   * @param id - Identifier for the direct message conversation\n   * @param data - Optional conversation data to initialize with\n   */\n  constructor(\n    client: Client<ContentTypes>,\n    id: string,\n    data?: SafeConversation,\n  ) {\n    super(client, id, data);\n    this.#client = client;\n    this.#id = id;\n  }\n\n  /**\n   * Retrieves the inbox ID of the other participant in the DM\n   *\n   * @returns Promise that resolves with the peer's inbox ID\n   */\n  async peerInboxId() {\n    return this.#client.sendMessage(\"dm.peerInboxId\", {\n      id: this.#id,\n    });\n  }\n\n  async getDuplicateDms() {\n    return this.#client.sendMessage(\"dm.getDuplicateDms\", {\n      id: this.#id,\n    });\n  }\n}\n",
      "size_bytes": 1249
    },
    "apps/xmtp.chat/src/helpers/messages.ts": {
      "content": "import type { DecodedMessage } from \"@xmtp/browser-sdk\";\nimport {\n  ContentTypeReaction,\n  type Reaction,\n} from \"@xmtp/content-type-reaction\";\nimport {\n  ContentTypeRemoteAttachment,\n  type RemoteAttachment,\n} from \"@xmtp/content-type-remote-attachment\";\nimport { ContentTypeReply, type Reply } from \"@xmtp/content-type-reply\";\nimport { ContentTypeText } from \"@xmtp/content-type-text\";\n\ntype ContentMessage = Pick<\n  DecodedMessage,\n  \"content\" | \"contentType\" | \"fallback\"\n>;\n\nexport const isReaction = <M extends ContentMessage>(\n  m: M,\n): m is M & { content: Reaction } => m.contentType.sameAs(ContentTypeReaction);\n\nexport const isReply = <M extends ContentMessage>(\n  m: M,\n): m is M & { content: Reply } => m.contentType.sameAs(ContentTypeReply);\n\nexport const isTextReply = <M extends ContentMessage>(\n  m: M,\n): m is M & { content: Reply & { content: string } } =>\n  isReply(m) && typeof m.content.content === \"string\";\n\nexport const isText = <M extends ContentMessage>(\n  m: M,\n): m is M & { content: string } => m.contentType.sameAs(ContentTypeText);\n\nexport const isRemoteAttachment = <M extends ContentMessage>(\n  m: M,\n): m is M & { content: RemoteAttachment } =>\n  m.contentType.sameAs(ContentTypeRemoteAttachment);\n\nexport const stringify = (message: ContentMessage): string => {\n  switch (true) {\n    case isReaction(message):\n    case isTextReply(message):\n      return message.content.content;\n    case isText(message):\n      return message.content;\n    case typeof message.content === \"string\":\n      return message.content;\n    case typeof message.fallback === \"string\":\n      return message.fallback;\n    default:\n      return JSON.stringify(message.content ?? message.fallback, null, 2);\n  }\n};\n\nexport const isActionable = (message: ContentMessage) =>\n  isText(message) ||\n  isReaction(message) ||\n  isTextReply(message) ||\n  isRemoteAttachment(message);\n",
      "size_bytes": 1881
    },
    "apps/xmtp.chat/src/components/Messages/TextContent.tsx": {
      "content": "import { Paper } from \"@mantine/core\";\nimport { BreakableText } from \"@/components/Messages/BreakableText\";\nimport classes from \"./TextContent.module.css\";\n\nexport type TextContentProps = {\n  text: string;\n  align?: \"left\" | \"right\";\n};\n\nexport const TextContent: React.FC<TextContentProps> = ({ text, align = \"left\" }) => {\n  const bubbleClass = align === \"right\" ? classes.outbound : classes.inbound;\n  return (\n    <Paper\n      className={[classes.text, bubbleClass].join(\" \")}\n      onClick={(event) => {\n        event.stopPropagation();\n      }}\n      shadow=\"sm\"\n      py=\"xs\"\n      px=\"sm\"\n      radius=\"lg\">\n      <BreakableText>{text}</BreakableText>\n    </Paper>\n  );\n};\n",
      "size_bytes": 681
    },
    "sdks/agent-sdk/src/core/Agent.test.ts": {
      "content": "import {\n  ContentTypeGroupUpdated,\n  type GroupUpdated,\n} from \"@xmtp/content-type-group-updated\";\nimport {\n  ContentTypeReaction,\n  type Reaction,\n} from \"@xmtp/content-type-reaction\";\nimport type { RemoteAttachment } from \"@xmtp/content-type-remote-attachment\";\nimport {\n  ContentTypeReply,\n  ReplyCodec,\n  type Reply,\n} from \"@xmtp/content-type-reply\";\nimport { ContentTypeText } from \"@xmtp/content-type-text\";\nimport {\n  Dm,\n  Group,\n  type Client,\n  type Conversation,\n  type DecodedMessage,\n} from \"@xmtp/node-sdk\";\nimport { beforeEach, describe, expect, expectTypeOf, it, vi } from \"vitest\";\nimport { filter } from \"@/core/filter.js\";\nimport { createSigner, createUser } from \"@/user/User.js\";\nimport {\n  createMockConversationStreamWithCallbacks,\n  createMockMessage,\n  createMockStreamWithCallbacks,\n  flushMicrotasks,\n  makeAgent,\n  mockClient,\n  type CurrentClientTypes,\n} from \"@/utils/TestUtil.js\";\nimport {\n  Agent,\n  type AgentErrorMiddleware,\n  type AgentMiddleware,\n  type AgentOptions,\n} from \"./Agent.js\";\nimport type { ClientContext } from \"./ClientContext.js\";\nimport { MessageContext } from \"./MessageContext.js\";\n\ndescribe(\"Agent\", () => {\n  const mockMessage = createMockMessage({\n    id: \"message-id-1\",\n    senderInboxId: \"sender-inbox-id\",\n    content: \"Hello, world!\",\n  });\n\n  let agent: Agent;\n  let options: AgentOptions<unknown>;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    options = { client: mockClient as unknown as Client };\n    agent = new Agent(options);\n  });\n\n  describe(\"types\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const ephemeralAgent = await Agent.create(signer, {\n      env: \"dev\",\n      dbPath: null,\n      codecs: [new ReplyCodec()],\n    });\n\n    it(\"infers additional content types from given codecs\", () => {\n      expectTypeOf(ephemeralAgent).toEqualTypeOf<Agent<CurrentClientTypes>>();\n    });\n\n    it(\"types the content in message event listener\", () => {\n      ephemeralAgent.on(\"unknownMessage\", (ctx) => {\n        expectTypeOf(ctx).toEqualTypeOf<MessageContext<CurrentClientTypes>>();\n      });\n    });\n\n    it(\"types content for 'attachment' events\", () => {\n      ephemeralAgent.on(\"attachment\", (ctx) => {\n        expectTypeOf(ctx.message.content).toEqualTypeOf<RemoteAttachment>();\n      });\n    });\n\n    it(\"types content for 'text' events\", () => {\n      ephemeralAgent.on(\"text\", (ctx) => {\n        expectTypeOf(ctx.message.content).toEqualTypeOf<string>();\n      });\n    });\n\n    it(\"types content for 'reaction' events\", () => {\n      ephemeralAgent.on(\"reaction\", (ctx) => {\n        expectTypeOf(ctx.message.content).toEqualTypeOf<Reaction>();\n      });\n    });\n\n    it(\"types content for 'reply' events\", () => {\n      ephemeralAgent.on(\"reply\", (ctx) => {\n        expectTypeOf(ctx.message.content).toEqualTypeOf<Reply>();\n      });\n    });\n\n    it(\"types content for 'group-update' events\", () => {\n      ephemeralAgent.on(\"group-update\", (ctx) => {\n        expectTypeOf(ctx.message.content).toEqualTypeOf<GroupUpdated>();\n      });\n    });\n\n    it(\"should have proper types when using type predicates in 'unknownMessage' event\", () => {\n      ephemeralAgent.on(\"unknownMessage\", (ctx) => {\n        if (ctx.isText()) {\n          expectTypeOf(ctx.message.content).toEqualTypeOf<string>();\n        }\n\n        if (ctx.isReply()) {\n          expectTypeOf(ctx.message.content).toEqualTypeOf<Reply>();\n        }\n\n        if (ctx.isReaction()) {\n          expectTypeOf(ctx.message.content).toEqualTypeOf<Reaction>();\n        }\n\n        if (ctx.isRemoteAttachment()) {\n          expectTypeOf(ctx.message.content).toEqualTypeOf<RemoteAttachment>();\n        }\n      });\n    });\n\n    it(\"should have proper types when using type predicates in 'conversation' event\", () => {\n      ephemeralAgent.on(\"conversation\", (ctx) => {\n        if (ctx.isDm()) {\n          expectTypeOf(ctx.conversation).toEqualTypeOf<\n            Dm<CurrentClientTypes>\n          >();\n        }\n\n        if (ctx.isGroup()) {\n          expectTypeOf(ctx.conversation).toEqualTypeOf<\n            Group<CurrentClientTypes>\n          >();\n        }\n      });\n    });\n\n    it(\"types content for 'start' events\", () => {\n      ephemeralAgent.on(\"start\", (ctx) => {\n        expectTypeOf(ctx).toEqualTypeOf<ClientContext<CurrentClientTypes>>();\n      });\n    });\n\n    it(\"types content for 'stop' events\", () => {\n      ephemeralAgent.on(\"stop\", (ctx) => {\n        expectTypeOf(ctx).toEqualTypeOf<ClientContext<CurrentClientTypes>>();\n      });\n    });\n  });\n\n  describe(\"start\", () => {\n    it(\"should sync conversations and start listening\", async () => {\n      const mockConversationStream = {\n        [Symbol.asyncIterator]: vi.fn().mockReturnValue({\n          next: vi.fn().mockResolvedValueOnce({ done: true }),\n        }),\n        end: vi.fn().mockResolvedValue(undefined),\n      };\n\n      const mockMessageStream = {\n        [Symbol.asyncIterator]: vi.fn().mockReturnValue({\n          next: vi.fn().mockResolvedValueOnce({ done: true }),\n        }),\n        end: vi.fn().mockResolvedValue(undefined),\n      };\n\n      mockClient.conversations.stream.mockResolvedValue(mockConversationStream);\n      mockClient.conversations.streamAllMessages.mockResolvedValue(\n        mockMessageStream,\n      );\n\n      const startSpy = vi.fn();\n      agent.on(\"start\", startSpy);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(mockClient.conversations.stream).toHaveBeenCalled();\n      expect(mockClient.conversations.streamAllMessages).toHaveBeenCalled();\n      expect(startSpy).toHaveBeenCalled();\n    });\n\n    it(\"should not start twice if already listening\", async () => {\n      const mockConversationStream = {\n        [Symbol.asyncIterator]: vi.fn().mockReturnValue({\n          next: vi.fn().mockResolvedValueOnce({ done: true }),\n        }),\n        end: vi.fn().mockResolvedValue(undefined),\n      };\n\n      const mockMessageStream = {\n        [Symbol.asyncIterator]: vi.fn().mockReturnValue({\n          next: vi.fn().mockResolvedValueOnce({ done: true }),\n        }),\n        end: vi.fn().mockResolvedValue(undefined),\n      };\n\n      mockClient.conversations.stream.mockResolvedValue(mockConversationStream);\n      mockClient.conversations.streamAllMessages.mockResolvedValue(\n        mockMessageStream,\n      );\n\n      const startSpy = vi.fn();\n      agent.on(\"start\", startSpy);\n\n      await agent.start();\n      await agent.start(); // second call should return early\n\n      expect(startSpy).toHaveBeenCalledTimes(1);\n    });\n\n    it(\"should filter messages from the agent itself (same senderInboxId)\", async () => {\n      const messageFromSelf = createMockMessage({\n        id: \"message-id-self\",\n        senderInboxId: mockClient.inboxId,\n        content: \"Message from self\",\n      });\n\n      const messageFromOther = createMockMessage({\n        id: \"message-id-other\",\n        senderInboxId: \"other-inbox-id\",\n        content: \"Message from other\",\n      });\n\n      const mockStream = createMockStreamWithCallbacks([\n        messageFromSelf,\n        messageFromOther,\n      ]);\n      mockClient.conversations.streamAllMessages.mockImplementation(mockStream);\n\n      const textEventSpy = vi.fn();\n      const unknownMessageSpy = vi.fn();\n      agent.on(\"text\", textEventSpy);\n      agent.on(\"unknownMessage\", unknownMessageSpy);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(\n        textEventSpy,\n        \"Should not emit events for message from self, but should for message from other\",\n      ).toHaveBeenCalledTimes(1);\n      expect(\n        unknownMessageSpy,\n        \"Filtered text messages don't go to unknownMessage\",\n      ).toHaveBeenCalledTimes(0);\n\n      expect(textEventSpy).toHaveBeenCalledWith(\n        expect.objectContaining({\n          message: expect.objectContaining({\n            senderInboxId: \"other-inbox-id\",\n          }) as DecodedMessage,\n        } as MessageContext),\n      );\n    });\n\n    it(\"should filter reaction messages from the agent itself\", async () => {\n      const reactionFromSelf = createMockMessage<Reaction>({\n        id: \"reaction-id-self\",\n        senderInboxId: mockClient.inboxId,\n        contentType: ContentTypeReaction,\n        content: {\n          content: \"👍\",\n          reference: \"message-ref-1\",\n          action: \"added\",\n          schema: \"unicode\",\n        },\n      });\n\n      const reactionFromOther = createMockMessage<Reaction>({\n        id: \"reaction-id-other\",\n        senderInboxId: \"other-inbox-id\",\n        contentType: ContentTypeReaction,\n        content: {\n          content: \"👍\",\n          reference: \"message-ref-1\",\n          action: \"added\",\n          schema: \"unicode\",\n        },\n      });\n\n      const mockStream = createMockStreamWithCallbacks([\n        reactionFromSelf,\n        reactionFromOther,\n      ]);\n      mockClient.conversations.streamAllMessages.mockImplementation(mockStream);\n\n      const reactionEventSpy = vi.fn();\n      const unknownMessageSpy = vi.fn();\n      agent.on(\"reaction\", reactionEventSpy);\n      agent.on(\"unknownMessage\", unknownMessageSpy);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(\n        reactionEventSpy,\n        \"Should only emit reaction event for message from other sender\",\n      ).toHaveBeenCalledTimes(1);\n      expect(\n        unknownMessageSpy,\n        \"Filtered text messages don't go to unknownMessage\",\n      ).toHaveBeenCalledTimes(0);\n\n      expect(reactionEventSpy).toHaveBeenCalledWith(\n        expect.objectContaining({\n          message: expect.objectContaining({\n            senderInboxId: \"other-inbox-id\",\n          }) as DecodedMessage,\n        } as MessageContext),\n      );\n    });\n\n    it(\"should emit 'group-update' events for group update messages\", async () => {\n      const groupUpdateMessage = createMockMessage<GroupUpdated>({\n        contentType: ContentTypeGroupUpdated,\n        content: {\n          initiatedByInboxId: \"initiator-inbox-id\",\n          addedInboxes: [{ inboxId: \"added-inbox-id\" }],\n          removedInboxes: [{ inboxId: \"removed-inbox-id\" }],\n          metadataFieldChanges: [],\n        },\n      });\n\n      const mockStream = createMockStreamWithCallbacks([groupUpdateMessage]);\n      mockClient.conversations.streamAllMessages.mockImplementation(mockStream);\n\n      const groupUpdateEventSpy = vi.fn();\n      agent.on(\"group-update\", groupUpdateEventSpy);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(groupUpdateEventSpy).toHaveBeenCalledTimes(1);\n      expect(groupUpdateEventSpy).toHaveBeenCalledWith(\n        expect.objectContaining({\n          message: expect.objectContaining({\n            contentType: ContentTypeGroupUpdated,\n          }) as DecodedMessage<GroupUpdated>,\n        } as MessageContext),\n      );\n    });\n\n    it(\"should emit generic 'message' event for all message types\", async () => {\n      const textMessage = createMockMessage({\n        id: \"text-message-id\",\n        senderInboxId: \"other-inbox-id\",\n        contentType: ContentTypeText,\n        content: \"Hello world\",\n      });\n\n      const reactionMessage = createMockMessage<Reaction>({\n        id: \"reaction-message-id\",\n        senderInboxId: \"other-inbox-id\",\n        contentType: ContentTypeReaction,\n        content: {\n          content: \"👍\",\n          reference: \"message-ref-1\",\n          action: \"added\",\n          schema: \"unicode\",\n        },\n      });\n\n      const replyMessage = createMockMessage<Reply>({\n        id: \"reply-message-id\",\n        senderInboxId: \"other-inbox-id\",\n        contentType: ContentTypeReply,\n        content: {\n          content: \"This is a reply\",\n          reference: textMessage.id,\n          contentType: ContentTypeText,\n        },\n      });\n\n      const groupUpdateMessage = createMockMessage<GroupUpdated>({\n        contentType: ContentTypeGroupUpdated,\n        content: {\n          initiatedByInboxId: \"inbox-id\",\n          addedInboxes: [],\n          removedInboxes: [],\n          metadataFieldChanges: [],\n        },\n      });\n\n      const mockStream = createMockStreamWithCallbacks([\n        textMessage,\n        reactionMessage,\n        replyMessage,\n        groupUpdateMessage,\n      ]);\n      mockClient.conversations.streamAllMessages.mockImplementation(mockStream);\n\n      const messageEventSpy = vi.fn();\n      const textEventSpy = vi.fn();\n      const reactionEventSpy = vi.fn();\n      const replyEventSpy = vi.fn();\n      const groupUpdateEventSpy = vi.fn();\n\n      agent.on(\"message\", messageEventSpy);\n      agent.on(\"text\", textEventSpy);\n      agent.on(\"reaction\", reactionEventSpy);\n      agent.on(\"reply\", replyEventSpy);\n      agent.on(\"group-update\", groupUpdateEventSpy);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(\n        messageEventSpy,\n        \"Generic 'message' event should fire for all message types\",\n      ).toHaveBeenCalledTimes(4);\n\n      expect(textEventSpy).toHaveBeenCalledTimes(1);\n      expect(reactionEventSpy).toHaveBeenCalledTimes(1);\n      expect(replyEventSpy).toHaveBeenCalledTimes(1);\n      expect(groupUpdateEventSpy).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe(\"conversation events\", () => {\n    it(\"should emit 'conversation' events for new conversations\", async () => {\n      const mockDm = Object.create(Dm.prototype) as Dm;\n      Object.defineProperty(mockDm, \"id\", {\n        value: \"dm-conversation-id\",\n        writable: false,\n      });\n      Object.defineProperty(mockDm, \"topic\", {\n        value: \"dm-topic\",\n        writable: false,\n      });\n\n      const mockGroup = Object.create(Group.prototype) as Group;\n      Object.defineProperty(mockGroup, \"id\", {\n        value: \"group-conversation-id\",\n        writable: false,\n      });\n      Object.defineProperty(mockGroup, \"topic\", {\n        value: \"group-topic\",\n        writable: false,\n      });\n\n      const conversationEventSpy = vi.fn();\n      agent.on(\"conversation\", conversationEventSpy);\n\n      const mockConversationStream = createMockConversationStreamWithCallbacks([\n        mockDm,\n        mockGroup,\n      ]);\n      const mockMessageStream = createMockStreamWithCallbacks([]);\n\n      mockClient.conversations.stream.mockImplementation(\n        mockConversationStream,\n      );\n      mockClient.conversations.streamAllMessages.mockImplementation(\n        mockMessageStream,\n      );\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(conversationEventSpy).toHaveBeenCalledTimes(2);\n\n      expect(conversationEventSpy).toHaveBeenNthCalledWith(\n        1,\n        expect.objectContaining({\n          conversation: mockDm,\n        }),\n      );\n      expect(conversationEventSpy).toHaveBeenNthCalledWith(\n        2,\n        expect.objectContaining({\n          conversation: mockGroup,\n        }),\n      );\n    });\n\n    it(\"should emit specific 'dm' events for direct messages\", async () => {\n      const mockDm = Object.create(Dm.prototype) as Dm;\n      Object.defineProperty(mockDm, \"id\", {\n        value: \"dm-conversation-id\",\n        writable: false,\n      });\n      Object.defineProperty(mockDm, \"topic\", {\n        value: \"dm-topic\",\n        writable: false,\n      });\n\n      const dmEventSpy = vi.fn();\n      const conversationEventSpy = vi.fn();\n      agent.on(\"dm\", dmEventSpy);\n      agent.on(\"conversation\", conversationEventSpy);\n\n      const mockConversationStream = createMockConversationStreamWithCallbacks([\n        mockDm,\n      ]);\n      const mockMessageStream = createMockStreamWithCallbacks([]);\n\n      mockClient.conversations.stream.mockImplementation(\n        mockConversationStream,\n      );\n      mockClient.conversations.streamAllMessages.mockImplementation(\n        mockMessageStream,\n      );\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(dmEventSpy).toHaveBeenCalledTimes(1);\n      expect(conversationEventSpy).toHaveBeenCalledTimes(1);\n\n      expect(dmEventSpy).toHaveBeenCalledWith(\n        expect.objectContaining({\n          conversation: mockDm,\n        }),\n      );\n    });\n\n    it(\"should emit specific 'group' events for Group conversations\", async () => {\n      const mockGroup = Object.create(Group.prototype) as Group;\n      Object.defineProperty(mockGroup, \"id\", {\n        value: \"group-conversation-id\",\n        writable: false,\n      });\n      Object.defineProperty(mockGroup, \"topic\", {\n        value: \"group-topic\",\n        writable: false,\n      });\n\n      const groupEventSpy = vi.fn();\n      const conversationEventSpy = vi.fn();\n      agent.on(\"group\", groupEventSpy);\n      agent.on(\"conversation\", conversationEventSpy);\n\n      const mockConversationStream = createMockConversationStreamWithCallbacks([\n        mockGroup,\n      ]);\n      const mockMessageStream = createMockStreamWithCallbacks([]);\n\n      mockClient.conversations.stream.mockImplementation(\n        mockConversationStream,\n      );\n      mockClient.conversations.streamAllMessages.mockImplementation(\n        mockMessageStream,\n      );\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(groupEventSpy).toHaveBeenCalledTimes(1);\n      expect(conversationEventSpy).toHaveBeenCalledTimes(1);\n\n      expect(groupEventSpy).toHaveBeenCalledWith(\n        expect.objectContaining({\n          conversation: mockGroup,\n        }),\n      );\n    });\n  });\n\n  describe(\"use\", () => {\n    it(\"should add middleware and return the agent instance\", () => {\n      const middleware = vi.fn();\n\n      const result = agent.use(middleware);\n\n      expect(result).toBe(agent);\n    });\n\n    it(\"should execute middleware when processing messages\", async () => {\n      const middleware = vi.fn<AgentMiddleware>(async (_, next) => {\n        await next();\n      });\n      agent.use(middleware);\n\n      const mockStream = createMockStreamWithCallbacks([mockMessage]);\n      mockClient.conversations.streamAllMessages.mockImplementation(mockStream);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(middleware).toHaveBeenCalledTimes(1);\n      expect(middleware).toHaveBeenCalledWith(\n        expect.any(MessageContext),\n        expect.any(Function),\n      );\n    });\n\n    it(\"should filter self messages before they reach middleware\", async () => {\n      const messageFromSelf = createMockMessage({\n        id: \"message-from-self\",\n        senderInboxId: mockClient.inboxId,\n        content: \"Message from agent itself\",\n      });\n\n      const messageFromOther = createMockMessage({\n        id: \"message-from-other\",\n        senderInboxId: \"other-user-inbox\",\n        content: \"Message from other user\",\n      });\n\n      const middlewareCallsSpy = vi.fn<AgentMiddleware>(async (_, next) => {\n        await next();\n      });\n      agent.use(middlewareCallsSpy);\n\n      const mockStream = createMockStreamWithCallbacks([\n        messageFromSelf,\n        messageFromOther,\n      ]);\n      mockClient.conversations.streamAllMessages.mockImplementation(mockStream);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      // Middleware should only be called once (for the message from other user)\n      expect(\n        middlewareCallsSpy,\n        \"Middleware should only process messages from other users, not self\",\n      ).toHaveBeenCalledTimes(1);\n\n      // Verify middleware was called with the message from the other user\n      expect(middlewareCallsSpy).toHaveBeenCalledWith(\n        expect.objectContaining({\n          message: expect.objectContaining({\n            senderInboxId: \"other-user-inbox\",\n          }) as DecodedMessage,\n        } as MessageContext),\n        expect.any(Function),\n      );\n    });\n\n    it(\"should continue to next middleware when next() is called\", async () => {\n      const firstMessage = createMockMessage({\n        id: \"first-message\",\n        senderInboxId: \"user-1\",\n        content: \"First message\",\n      });\n\n      const secondMessage = createMockMessage({\n        id: \"second-message\",\n        senderInboxId: \"user-2\",\n        content: \"Second message\",\n      });\n\n      const middlewareCalls: string[] = [];\n\n      const mw1 = vi.fn<AgentMiddleware>(async (ctx, next) => {\n        middlewareCalls.push(\"mw1-\" + ctx.message.id);\n        await next();\n      });\n\n      const mw2 = vi.fn<AgentMiddleware>(async (ctx, next) => {\n        middlewareCalls.push(\"mw2-\" + ctx.message.id);\n        await next();\n      });\n\n      const mw3 = vi.fn<AgentMiddleware>(async (ctx, next) => {\n        middlewareCalls.push(\"mw3-\" + ctx.message.id);\n        await next();\n      });\n\n      agent.use([mw1, mw2, mw3]);\n\n      const mockStream = createMockStreamWithCallbacks([\n        firstMessage,\n        secondMessage,\n      ]);\n      mockClient.conversations.streamAllMessages.mockImplementation(mockStream);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(middlewareCalls).toEqual([\n        \"mw1-first-message\",\n        \"mw2-first-message\",\n        \"mw3-first-message\",\n        \"mw1-second-message\",\n        \"mw2-second-message\",\n        \"mw3-second-message\",\n      ]);\n    });\n\n    it(\"should stop the processing chain when the middleware returns\", async () => {\n      const firstMessage = createMockMessage({\n        id: \"first-message\",\n        senderInboxId: \"user-1\",\n        content: \"First message\",\n      });\n\n      const secondMessage = createMockMessage({\n        id: \"second-message\",\n        senderInboxId: \"user-2\",\n        content: \"Second message\",\n        contentType: ContentTypeReply,\n      });\n\n      const middlewareCalls: string[] = [];\n\n      const mw1 = vi.fn<AgentMiddleware>(async (ctx, next) => {\n        middlewareCalls.push(\"mw1-\" + ctx.message.id);\n        await next();\n      });\n\n      const filterReply = vi.fn<AgentMiddleware>(async ({ message }, next) => {\n        middlewareCalls.push(\"filterReply-\" + message.id);\n        if (filter.isReply(message)) {\n          return;\n        }\n        await next();\n      });\n\n      const mw3 = vi.fn<AgentMiddleware>(async (ctx, next) => {\n        middlewareCalls.push(\"mw3-\" + ctx.message.id);\n        await next();\n      });\n\n      agent.use([mw1, filterReply, mw3]);\n\n      const mockStream = createMockStreamWithCallbacks([\n        firstMessage,\n        secondMessage,\n      ]);\n      mockClient.conversations.streamAllMessages.mockImplementation(mockStream);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(middlewareCalls).toEqual([\n        \"mw1-first-message\",\n        \"filterReply-first-message\",\n        \"mw3-first-message\",\n        \"mw1-second-message\",\n        \"filterReply-second-message\",\n      ]);\n    });\n  });\n\n  describe(\"emit\", () => {\n    it(\"should emit 'message' and allow sending a reply via context\", async () => {\n      const mockConversation = { send: vi.fn() };\n      let contextSend: ((text: string) => Promise<void>) | undefined;\n      const handler = vi.fn((ctx: MessageContext) => {\n        contextSend = ctx.sendText.bind(ctx);\n      });\n      agent.on(\"unknownMessage\", handler);\n\n      void agent.emit(\n        \"unknownMessage\",\n        new MessageContext({\n          message: mockMessage,\n          conversation: mockConversation as unknown as Conversation,\n          client: agent.client,\n        }),\n      );\n\n      expect(handler).toHaveBeenCalledTimes(1);\n      await contextSend?.(\"Test response\");\n      expect(mockConversation.send).toHaveBeenCalledWith(\n        \"Test response\",\n        ContentTypeText,\n      );\n    });\n  });\n\n  describe(\"stop\", () => {\n    it(\"should stop listening and emit stop event\", async () => {\n      const stopSpy = vi.fn();\n      agent.on(\"stop\", stopSpy);\n\n      await agent.stop();\n\n      expect(stopSpy).toHaveBeenCalled();\n    });\n\n    it(\"should properly clean up both conversation and message streams\", async () => {\n      const mockConversationStream = {\n        end: vi.fn().mockResolvedValue(undefined),\n        [Symbol.asyncIterator]: vi.fn(),\n      };\n\n      const mockMessageStream = {\n        end: vi.fn().mockResolvedValue(undefined),\n        [Symbol.asyncIterator]: vi.fn(),\n      };\n\n      mockClient.conversations.stream.mockResolvedValue(mockConversationStream);\n      mockClient.conversations.streamAllMessages.mockResolvedValue(\n        mockMessageStream,\n      );\n\n      await agent.start();\n      await agent.stop();\n\n      expect(mockConversationStream.end).toHaveBeenCalled();\n      expect(mockMessageStream.end).toHaveBeenCalled();\n    });\n  });\n\n  describe(\"errors.use\", () => {\n    const mockMessage = createMockMessage({\n      id: \"msg-1\",\n      conversationId: \"conv-1\",\n      senderInboxId: \"inbox-1\",\n      content: \"hello\",\n    });\n\n    it(\"propagates error, transforms, recovers, and resumes remaining middleware\", async () => {\n      const { agent, mockClient } = makeAgent();\n\n      const callOrder: string[] = [];\n      const onError = vi.fn();\n      agent.on(\"unhandledError\", onError);\n\n      const mw1: AgentMiddleware = async (ctx, next) => {\n        expect(ctx).toBeInstanceOf(MessageContext);\n        callOrder.push(\"1\");\n        await next();\n      };\n\n      const mw2: AgentMiddleware = (ctx) => {\n        expect(ctx).toBeInstanceOf(MessageContext);\n        callOrder.push(\"2\");\n        throw new Error(\"Initial error\");\n      };\n\n      const mw3: AgentMiddleware = async (ctx, next) => {\n        expect(ctx).toBeInstanceOf(MessageContext);\n        callOrder.push(\"3\");\n        await next();\n      };\n\n      const mw4: AgentMiddleware = async (ctx, next) => {\n        expect(ctx).toBeInstanceOf(MessageContext);\n        callOrder.push(\"4\");\n        await next();\n      };\n\n      const e1: AgentErrorMiddleware = async (err, ctx, next) => {\n        expect(err).toBeInstanceOf(Error);\n        expect((err as Error).message).toBe(\"Initial error\");\n        expect(ctx).toBeInstanceOf(MessageContext);\n        callOrder.push(\"E1\");\n        // Transform the initial error\n        await next(new Error(\"Transformed error\"));\n      };\n\n      const e2: AgentErrorMiddleware = async (err, ctx, next) => {\n        expect((err as Error).message).toBe(\"Transformed error\");\n        expect(ctx).toBeInstanceOf(MessageContext);\n        callOrder.push(\"E2\");\n        // Resume middleware chain\n        await next();\n      };\n\n      agent.use([mw1, mw2], [mw3], mw4);\n      agent.errors.use(e1, e2);\n\n      agent.on(\"text\", () => {\n        callOrder.push(\"EMIT\");\n      });\n\n      const mockStream = createMockStreamWithCallbacks([mockMessage]);\n      mockClient.conversations.streamAllMessages.mockImplementation(mockStream);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(callOrder).toEqual([\"1\", \"2\", \"E1\", \"E2\", \"3\", \"4\", \"EMIT\"]);\n      expect(\n        onError,\n        \"error chain recovered, no final error is emitted\",\n      ).toHaveBeenCalledTimes(0);\n    });\n\n    it(\"doesn't emit when a middleware returns early\", async () => {\n      const { agent, mockClient } = makeAgent();\n\n      const callOrder: string[] = [];\n\n      const mw1: AgentMiddleware = async (_, next) => {\n        callOrder.push(\"1\");\n        await next();\n      };\n\n      const mw2: AgentMiddleware = async (_, next) => {\n        callOrder.push(\"2\");\n        await next();\n      };\n\n      const returnsEarly: AgentMiddleware = () => {\n        return Promise.resolve();\n      };\n\n      const notBeingExecuted: AgentMiddleware = async (_, next) => {\n        callOrder.push(\"4\");\n        await next();\n      };\n\n      agent.use(mw1, mw2, returnsEarly, notBeingExecuted);\n\n      agent.on(\"unknownMessage\", () => {\n        callOrder.push(\"never happening\");\n      });\n\n      const mockStream = createMockStreamWithCallbacks([mockMessage]);\n      mockClient.conversations.streamAllMessages.mockImplementation(mockStream);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(callOrder).toEqual([\"1\", \"2\"]);\n    });\n\n    it(\"can end an error queue when returning\", async () => {\n      const { agent, mockClient } = makeAgent();\n\n      const callOrder: string[] = [];\n\n      const mw1: AgentMiddleware = () => {\n        callOrder.push(\"mw1\");\n        throw new Error();\n      };\n\n      const mw2: AgentMiddleware = async (_, next) => {\n        callOrder.push(\"mw2 won't be called\");\n        await next();\n      };\n\n      const e1: AgentErrorMiddleware = () => {\n        callOrder.push(\"e1\");\n        return;\n      };\n\n      const e2: AgentErrorMiddleware = async (_error, _ctx, next) => {\n        callOrder.push(\"e2 won't be called\");\n        await next();\n      };\n\n      agent.use(mw1, mw2);\n\n      agent.errors.use(e1, e2);\n\n      const mockStream = createMockStreamWithCallbacks([mockMessage]);\n      mockClient.conversations.streamAllMessages.mockImplementation(mockStream);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(callOrder).toEqual([\"mw1\", \"e1\"]);\n    });\n\n    it(\"emits an error if no custom error middleware is registered\", async () => {\n      const { agent, mockClient } = makeAgent();\n\n      const callOrder: string[] = [];\n\n      const errorMessage = \"Middleware failed\";\n\n      const failingMiddleware: AgentMiddleware = () => {\n        throw new Error(errorMessage);\n      };\n\n      agent.use(failingMiddleware);\n\n      agent.on(\"unhandledError\", (error) => {\n        callOrder.push(error.message);\n      });\n\n      const mockStream = createMockStreamWithCallbacks([mockMessage]);\n      mockClient.conversations.streamAllMessages.mockImplementation(mockStream);\n\n      await agent.start();\n      await flushMicrotasks();\n\n      expect(callOrder).toEqual([errorMessage]);\n    });\n  });\n});\n",
      "size_bytes": 29441
    },
    "sdks/agent-sdk/src/utils/TestUtil.ts": {
      "content": "import type { GroupUpdated } from \"@xmtp/content-type-group-updated\";\nimport type { Reaction } from \"@xmtp/content-type-reaction\";\nimport type { RemoteAttachment } from \"@xmtp/content-type-remote-attachment\";\nimport type { Reply } from \"@xmtp/content-type-reply\";\nimport { ContentTypeText } from \"@xmtp/content-type-text\";\nimport type { Client, Conversation, DecodedMessage } from \"@xmtp/node-sdk\";\nimport type { Mock } from \"vitest\";\nimport { Agent } from \"@/core/Agent.js\";\nimport type { DecodedMessageWithContent } from \"@/core/filter.js\";\n\nexport type CurrentClientTypes =\n  | string\n  | Reaction\n  | Reply\n  | RemoteAttachment\n  | GroupUpdated;\n\nexport const createMockMessage = <ContentType>(\n  overrides: Partial<DecodedMessage> & { content: ContentType },\n): DecodedMessageWithContent<ContentType> => {\n  const { content, ...rest } = overrides;\n  return {\n    id: \"mock-message-id\",\n    conversationId: \"test-conversation-id\",\n    senderInboxId: \"sender-inbox-id\",\n    contentType: ContentTypeText,\n    ...rest,\n    content,\n  } as DecodedMessageWithContent<ContentType>;\n};\n\nexport const makeAgent = () => {\n  return { agent: new Agent({ client: mockClient }), mockClient };\n};\n\nexport const mockClient = {\n  inboxId: \"test-inbox-id\",\n  conversations: {\n    sync: vi.fn().mockResolvedValue(undefined),\n    stream: vi.fn().mockResolvedValue(undefined),\n    streamAllMessages: vi.fn(),\n    getConversationById: vi.fn().mockResolvedValue({\n      send: vi.fn().mockResolvedValue(undefined),\n    }),\n  },\n  preferences: {\n    inboxStateFromInboxIds: vi.fn(),\n  },\n} as unknown as Client & {\n  conversations: {\n    stream: Mock;\n    streamAllMessages: Mock;\n  };\n};\n\nexport const createMockStreamWithCallbacks = (messages: DecodedMessage[]) => {\n  const mockStream = {\n    end: vi.fn().mockResolvedValue(undefined),\n    [Symbol.asyncIterator]: vi.fn(),\n  };\n\n  return vi\n    .fn()\n    .mockImplementation(\n      (options: { onValue: (value: DecodedMessage) => void }) => {\n        // Simulate async message delivery\n        queueMicrotask(() => {\n          messages.forEach((message) => {\n            options.onValue(message);\n          });\n        });\n        return Promise.resolve(mockStream);\n      },\n    );\n};\n\nexport const createMockConversationStreamWithCallbacks = (\n  conversations: Conversation[],\n) => {\n  const mockStream = {\n    end: vi.fn().mockResolvedValue(undefined),\n    [Symbol.asyncIterator]: vi.fn(),\n  };\n\n  return vi\n    .fn()\n    .mockImplementation(\n      (options: { onValue: (value: Conversation) => void }) => {\n        // Simulate async conversation delivery\n        queueMicrotask(() => {\n          conversations.forEach((conversation) => {\n            options.onValue(conversation);\n          });\n        });\n        return Promise.resolve(mockStream);\n      },\n    );\n};\n\nexport const flushMicrotasks = async () => {\n  await new Promise((resolve) => setTimeout(resolve, 0));\n};\n",
      "size_bytes": 2914
    },
    "apps/xmtp.chat/src/components/InboxId.tsx": {
      "content": "import { Button, Popover, Stack, Text } from \"@mantine/core\";\nimport { useState } from \"react\";\nimport { BadgeWithCopy } from \"@/components/BadgeWithCopy\";\nimport { shortAddress } from \"@/helpers/strings\";\n\nexport type InboxIdBadgeProps = {\n  inboxId: string;\n  address: string;\n  size?: \"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\";\n};\n\nexport const InboxIdBadge: React.FC<InboxIdBadgeProps> = ({\n  inboxId,\n  address,\n  size = \"lg\",\n}) => {\n  const [opened, setOpened] = useState(false);\n  return (\n    <Popover\n      width={300}\n      position=\"bottom\"\n      withArrow\n      shadow=\"md\"\n      trapFocus\n      opened={opened}\n      onChange={setOpened}>\n      <Popover.Target>\n        <Button\n          variant=\"default\"\n          size={size}\n          radius=\"md\"\n          miw={100}\n          onClick={(e) => {\n            e.stopPropagation();\n            setOpened((o) => !o);\n          }}>\n          {shortAddress(inboxId)}\n        </Button>\n      </Popover.Target>\n      <Popover.Dropdown\n        p=\"xs\"\n        onClick={(e) => {\n          e.stopPropagation();\n        }}>\n        <Stack gap=\"xs\">\n          <Text truncate size=\"sm\" ml=\"xs\">\n            Inbox ID\n          </Text>\n          <BadgeWithCopy value={inboxId} />\n          <Text truncate size=\"sm\" ml=\"xs\">\n            Address\n          </Text>\n          <BadgeWithCopy value={address} />\n        </Stack>\n      </Popover.Dropdown>\n    </Popover>\n  );\n};\n",
      "size_bytes": 1412
    },
    "apps/xmtp.chat/src/components/Conversation/MemberPopover.tsx": {
      "content": "import {\n  ActionIcon,\n  Avatar,\n  Group,\n  Menu,\n  Popover,\n  Stack,\n  Text,\n  Textarea,\n  Tooltip,\n  type PopoverProps,\n} from \"@mantine/core\";\nimport { useClipboard } from \"@mantine/hooks\";\nimport { Group as XmtpGroup, type SafeGroupMember } from \"@xmtp/browser-sdk\";\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n} from \"react\";\nimport BreakableText from \"@/components/Messages/BreakableText\";\nimport { useClient } from \"@/contexts/XMTPContext\";\nimport { shortAddress } from \"@/helpers/strings\";\nimport {\n  useClientPermissions,\n  type AdjustedPermissionLevel,\n} from \"@/hooks/useClientPermissions\";\nimport { useConversation } from \"@/hooks/useConversation\";\nimport { useConversations } from \"@/hooks/useConversations\";\nimport { IconDots } from \"@/icons/IconDots\";\nimport { useActions } from \"@/stores/inbox/hooks\";\nimport classes from \"./MemberPopover.module.css\";\n\ntype MemberPopoverContextType = {\n  opened: boolean;\n  setOpened: React.Dispatch<React.SetStateAction<boolean>>;\n};\n\nconst MemberPopoverContext = createContext<MemberPopoverContextType>({\n  opened: false,\n  setOpened: () => {},\n});\n\nconst MemberPopoverProvider: React.FC<\n  React.PropsWithChildren<MemberPopoverContextType>\n> = ({ children, opened, setOpened }) => {\n  const value = useMemo(() => ({ opened, setOpened }), [opened, setOpened]);\n  return (\n    <MemberPopoverContext.Provider value={value}>\n      {children}\n    </MemberPopoverContext.Provider>\n  );\n};\n\nexport const useMemberPopover = () => {\n  const context = useContext(MemberPopoverContext);\n  return context;\n};\n\nexport type MemberPopoverProps = React.PropsWithChildren<{\n  address: string;\n  avatar: string | null;\n  conversationId: string;\n  description: string | null;\n  displayName: string | null;\n  inboxId: string;\n  permissionLevel: SafeGroupMember[\"permissionLevel\"];\n  position?: PopoverProps[\"position\"];\n  showDm?: boolean;\n}>;\n\nexport const MemberPopover: React.FC<MemberPopoverProps> = ({\n  address,\n  avatar,\n  children,\n  conversationId,\n  description,\n  displayName,\n  inboxId,\n  permissionLevel,\n  position,\n  showDm = true,\n}) => {\n  const client = useClient();\n  const { newDm, getDmByInboxId } = useConversations();\n  const { conversation, members } = useConversation(conversationId);\n  const clientPermissions = useClientPermissions(conversationId);\n  const { syncMembers } = useActions();\n  const clipboard = useClipboard({ timeout: 1000 });\n  const [sending, setSending] = useState(false);\n  const [sendError, setSendError] = useState(false);\n  const [message, setMessage] = useState(\"\");\n  const [opened, setOpened] = useState(false);\n  const handleCopy = useCallback(\n    (value: string) => {\n      clipboard.copy(value);\n    },\n    [clipboard],\n  );\n  const handleKeyDown = useCallback(\n    (event: React.KeyboardEvent<HTMLTextAreaElement>) => {\n      if (event.key === \"Enter\" && !event.shiftKey) {\n        event.preventDefault();\n        if (message.trim() !== \"\") {\n          setSending(true);\n          setSendError(false);\n          getDmByInboxId(inboxId)\n            .then((dm) => dm ?? newDm(inboxId))\n            .then((dm) => dm.send(message))\n            .then(() => {\n              setMessage(\"\");\n            })\n            .catch(() => {\n              setSendError(true);\n            })\n            .finally(() => {\n              setSending(false);\n            });\n        }\n      }\n    },\n    [message, inboxId, getDmByInboxId, newDm],\n  );\n\n  const handlePermissionLevelChange = useCallback(\n    // TODO: remove this once types are fixed\n    async (inboxId: string, permissionLevel: AdjustedPermissionLevel) => {\n      const member = members.get(inboxId);\n      if (!member || !(conversation instanceof XmtpGroup)) {\n        return;\n      }\n      // TODO: remove this once types are fixed\n      const level =\n        member.permissionLevel as unknown as AdjustedPermissionLevel;\n      if (level === permissionLevel) {\n        return;\n      }\n\n      switch (level) {\n        case \"SuperAdmin\": {\n          await conversation.removeSuperAdmin(inboxId);\n          switch (permissionLevel) {\n            case \"Admin\":\n              await conversation.addAdmin(inboxId);\n              break;\n          }\n          break;\n        }\n        case \"Admin\": {\n          await conversation.removeAdmin(inboxId);\n          switch (permissionLevel) {\n            case \"SuperAdmin\":\n              await conversation.addSuperAdmin(inboxId);\n              break;\n          }\n          break;\n        }\n        case \"Member\": {\n          switch (permissionLevel) {\n            case \"SuperAdmin\":\n              await conversation.addSuperAdmin(inboxId);\n              break;\n            case \"Admin\":\n              await conversation.addAdmin(inboxId);\n              break;\n          }\n          break;\n        }\n      }\n      await syncMembers(conversationId);\n    },\n    [conversation, conversationId, syncMembers],\n  );\n\n  const handleRemoveMember = useCallback(\n    async (inboxId: string) => {\n      if (!(conversation instanceof XmtpGroup)) {\n        return;\n      }\n      await conversation.removeMembers([inboxId]);\n      await syncMembers(conversationId);\n    },\n    [conversation, conversationId, syncMembers],\n  );\n\n  // TODO: remove this once types are fixed\n  const level = permissionLevel as unknown as AdjustedPermissionLevel;\n  const canManageMember = useMemo(() => {\n    return (\n      (clientPermissions.canPromoteMembers &&\n        (level === \"Admin\" || level === \"Member\")) ||\n      (clientPermissions.canDemoteMembers &&\n        (level === \"SuperAdmin\" || level === \"Admin\")) ||\n      (clientPermissions.canRemoveMembers && client.inboxId !== inboxId)\n    );\n  }, [clientPermissions, level]);\n  const canPromoteToSuperAdmin = useMemo(() => {\n    return (\n      clientPermissions.canPromoteMembers &&\n      (level === \"Admin\" || level === \"Member\") &&\n      client.inboxId !== inboxId\n    );\n  }, [clientPermissions.canPromoteMembers, level, client.inboxId, inboxId]);\n  const canPromoteToAdmin = useMemo(() => {\n    return (\n      clientPermissions.canPromoteMembers &&\n      level === \"Member\" &&\n      client.inboxId !== inboxId\n    );\n  }, [clientPermissions.canPromoteMembers, level, client.inboxId, inboxId]);\n  const canDemoteToAdmin = useMemo(() => {\n    return (\n      clientPermissions.canDemoteMembers &&\n      level === \"SuperAdmin\" &&\n      client.inboxId !== inboxId\n    );\n  }, [clientPermissions.canDemoteMembers, level, client.inboxId, inboxId]);\n  const canDemoteToMember = useMemo(() => {\n    return (\n      clientPermissions.canDemoteMembers &&\n      (level === \"SuperAdmin\" || level === \"Admin\") &&\n      client.inboxId !== inboxId\n    );\n  }, [clientPermissions.canDemoteMembers, level, client.inboxId, inboxId]);\n  const canRemoveMember = useMemo(() => {\n    return clientPermissions.canRemoveMembers && client.inboxId !== inboxId;\n  }, [clientPermissions.canRemoveMembers, client.inboxId, inboxId]);\n\n  return (\n    <MemberPopoverProvider opened={opened} setOpened={setOpened}>\n      <Popover\n        withArrow\n        shadow=\"md\"\n        opened={opened}\n        trapFocus\n        onChange={setOpened}\n        position={position}>\n        <Popover.Target>{children}</Popover.Target>\n        <Popover.Dropdown\n          onClick={(e) => {\n            e.stopPropagation();\n          }}>\n          <Stack\n            gap=\"sm\"\n            align=\"center\"\n            maw={300}\n            miw={260}\n            className={classes.profile}>\n            <Menu shadow=\"md\" withArrow>\n              <Menu.Target>\n                <ActionIcon\n                  variant=\"default\"\n                  className={classes.menu}\n                  onClick={(e) => {\n                    e.stopPropagation();\n                  }}>\n                  <IconDots />\n                </ActionIcon>\n              </Menu.Target>\n              <Menu.Dropdown>\n                {canPromoteToSuperAdmin && (\n                  <Menu.Item\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      void handlePermissionLevelChange(inboxId, \"SuperAdmin\");\n                    }}>\n                    Promote to super admin\n                  </Menu.Item>\n                )}\n                {canPromoteToAdmin && (\n                  <Menu.Item\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      void handlePermissionLevelChange(inboxId, \"Admin\");\n                    }}>\n                    Promote to admin\n                  </Menu.Item>\n                )}\n                {canDemoteToAdmin && (\n                  <Menu.Item\n                    c=\"red\"\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      void handlePermissionLevelChange(inboxId, \"Admin\");\n                    }}>\n                    Demote to admin\n                  </Menu.Item>\n                )}\n                {canDemoteToMember && (\n                  <Menu.Item\n                    c=\"red\"\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      void handlePermissionLevelChange(inboxId, \"Member\");\n                    }}>\n                    Demote to member\n                  </Menu.Item>\n                )}\n                {canManageMember && <Menu.Divider />}\n                <Menu.Item\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    handleCopy(address);\n                  }}>\n                  Copy address\n                </Menu.Item>\n                <Menu.Item\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    handleCopy(inboxId);\n                  }}>\n                  Copy inbox ID\n                </Menu.Item>\n                {canRemoveMember && <Menu.Divider />}\n                {canRemoveMember && (\n                  <Menu.Item\n                    c=\"red\"\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      void handleRemoveMember(inboxId);\n                    }}>\n                    Remove from group\n                  </Menu.Item>\n                )}\n              </Menu.Dropdown>\n            </Menu>\n            <Avatar src={avatar} size=\"xl\" radius=\"100%\" variant=\"default\" />\n            <Group w=\"100%\" align=\"center\" justify=\"center\">\n              {displayName ? (\n                <BreakableText>{displayName}</BreakableText>\n              ) : (\n                <Tooltip label={<Text size=\"xs\">{address}</Text>}>\n                  <BreakableText>{shortAddress(address, 8)}</BreakableText>\n                </Tooltip>\n              )}\n            </Group>\n            {description && <Text size=\"xs\">{description}</Text>}\n            {showDm && (\n              <Stack gap=\"0\" w=\"100%\">\n                <Textarea\n                  error={\n                    sendError ? \"Failed to send message, try again\" : undefined\n                  }\n                  onKeyDown={handleKeyDown}\n                  disabled={sending}\n                  maxRows={4}\n                  size=\"sm\"\n                  autosize\n                  placeholder=\"Send a message...\"\n                  onChange={(e) => {\n                    setMessage(e.target.value);\n                  }}\n                  value={message}\n                  w=\"100%\"\n                />\n                {sending ? (\n                  <Text size=\"xxs\" p=\"xxxs\" pb=\"0\" c=\"dimmed\">\n                    Sending message...\n                  </Text>\n                ) : (\n                  <Text size=\"xxs\" p=\"xxxs\" pb=\"0\" c=\"dimmed\">\n                    <Text fw={700} span>\n                      Shift + Enter\n                    </Text>{\" \"}\n                    for new line,{\" \"}\n                    <Text fw={700} span>\n                      Enter\n                    </Text>{\" \"}\n                    to send\n                  </Text>\n                )}\n              </Stack>\n            )}\n          </Stack>\n        </Popover.Dropdown>\n      </Popover>\n    </MemberPopoverProvider>\n  );\n};\n",
      "size_bytes": 12086
    },
    "apps/xmtp.chat/src/components/Conversation/AttachmentPreview.tsx": {
      "content": "import { ActionIcon, Box, Group, Paper, Text } from \"@mantine/core\";\nimport { useMemo } from \"react\";\nimport { IconX } from \"@/icons/IconX\";\n\nexport type AttachmentPreviewProps = {\n  file: File;\n  onCancel: () => void;\n  disabled?: boolean;\n};\n\nexport const AttachmentPreview: React.FC<AttachmentPreviewProps> = ({\n  file,\n  onCancel,\n  disabled,\n}) => {\n  const fileUrl = useMemo(() => URL.createObjectURL(file), [file]);\n  const fileType = file.type.split(\"/\")[0];\n  const fileSize = useMemo(() => {\n    const kb = file.size / 1024;\n    if (kb < 1024) {\n      return `${kb.toFixed(1)} KB`;\n    }\n    const mb = kb / 1024;\n    return `${mb.toFixed(1)} MB`;\n  }, [file.size]);\n\n  return (\n    <>\n      <Box miw=\"0\">\n        <Paper p=\"xs\" radius=\"sm\" withBorder>\n          <Group gap=\"xs\" align=\"flex-start\" wrap=\"nowrap\">\n            <Box style={{ flex: 1, minWidth: 0 }}>\n              {fileType === \"image\" && (\n                <img\n                  src={fileUrl}\n                  alt={file.name}\n                  style={{\n                    width: \"100%\",\n                    maxHeight: \"300px\",\n                    borderRadius: \"var(--mantine-radius-sm)\",\n                    objectFit: \"contain\",\n                  }}\n                />\n              )}\n              {fileType === \"video\" && (\n                <video\n                  src={fileUrl}\n                  controls\n                  style={{\n                    width: \"100%\",\n                    maxHeight: \"300px\",\n                    borderRadius: \"var(--mantine-radius-sm)\",\n                  }}\n                />\n              )}\n              {fileType === \"audio\" && (\n                <audio\n                  src={fileUrl}\n                  controls\n                  style={{\n                    width: \"100%\",\n                  }}\n                />\n              )}\n              <Group gap=\"xxs\" mt=\"xs\" align=\"center\">\n                <Text size=\"sm\" fw={500} truncate>\n                  {file.name}\n                </Text>\n                <Text size=\"sm\" c=\"dimmed\">\n                  {fileSize}\n                </Text>\n              </Group>\n            </Box>\n          </Group>\n        </Paper>\n      </Box>\n      <Box style={{ alignSelf: \"start\" }}>\n        <ActionIcon\n          aria-label=\"Cancel attachment\"\n          variant=\"light\"\n          radius=\"xl\"\n          onClick={onCancel}\n          disabled={disabled}>\n          <IconX size={18} />\n        </ActionIcon>\n      </Box>\n    </>\n  );\n};\n",
      "size_bytes": 2491
    },
    "apps/xmtp.chat/src/components/CodeWithCopy.tsx": {
      "content": "import { Box, Code } from \"@mantine/core\";\nimport { CopyButton } from \"./CopyButton\";\n\ntype CodeWithCopyProps = {\n  code: string;\n};\n\nexport const CodeWithCopy: React.FC<CodeWithCopyProps> = ({ code }) => {\n  return (\n    <Box pos=\"relative\">\n      <Code\n        pt=\"xl\"\n        pl=\"md\"\n        pr=\"md\"\n        pb=\"md\"\n        block\n        style={{\n          whiteSpace: \"pre-wrap\",\n          wordBreak: \"break-word\",\n        }}>\n        {code}\n      </Code>\n      <Box pos=\"absolute\" top={0} right={0} px=\"xs\">\n        <CopyButton value={code} />\n      </Box>\n    </Box>\n  );\n};\n",
      "size_bytes": 581
    },
    "content-types/content-type-transaction-reference/rollup.config.js": {
      "content": "import terser from \"@rollup/plugin-terser\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { defineConfig } from \"rollup\";\nimport { dts } from \"rollup-plugin-dts\";\n\nconst plugins = [\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n];\n\nconst external = [\"@xmtp/content-type-primitives\"];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/browser/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins: [...plugins, terser()],\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.d.ts\",\n      format: \"es\",\n    },\n    plugins: [dts()],\n  },\n]);\n",
      "size_bytes": 832
    },
    "content-types/content-type-reply/src/Reply.ts": {
      "content": "import {\n  ContentTypeId,\n  type CodecRegistry,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\nimport { content as proto } from \"@xmtp/proto\";\n\nexport const ContentTypeReply = new ContentTypeId({\n  authorityId: \"xmtp.org\",\n  typeId: \"reply\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\nexport type Reply = {\n  /**\n   * The message ID for the message that is being replied to\n   */\n  reference: string;\n  /**\n   * The inbox ID of the user who sent the message that is being replied to\n   *\n   * This only applies to group messages\n   */\n  referenceInboxId?: string;\n  /**\n   * The content of the reply\n   */\n  content: unknown;\n  /**\n   * The content type of the reply\n   */\n  contentType: ContentTypeId;\n};\n\nexport type ReplyParameters = {\n  contentType: string;\n  reference: string;\n  referenceInboxId?: string;\n};\n\nexport class ReplyCodec implements ContentCodec<Reply, ReplyParameters> {\n  get contentType(): ContentTypeId {\n    return ContentTypeReply;\n  }\n\n  encode(\n    content: Reply,\n    registry: CodecRegistry,\n  ): EncodedContent<ReplyParameters> {\n    const codec = registry.codecFor(content.contentType);\n    if (!codec) {\n      throw new Error(\n        `missing codec for content type \"${content.contentType.toString()}\"`,\n      );\n    }\n\n    const encodedContent = codec.encode(content.content, registry);\n    const bytes = proto.EncodedContent.encode(encodedContent).finish();\n\n    const parameters: ReplyParameters = {\n      // TODO: cut when we're certain no one is looking for \"contentType\" here.\n      contentType: content.contentType.toString(),\n      reference: content.reference,\n    };\n\n    // add referenceInboxId if it's present\n    if (content.referenceInboxId) {\n      parameters.referenceInboxId = content.referenceInboxId;\n    }\n\n    return {\n      type: this.contentType,\n      parameters,\n      content: bytes,\n    };\n  }\n\n  decode(\n    content: EncodedContent<ReplyParameters>,\n    registry: CodecRegistry,\n  ): Reply {\n    const decodedContent = proto.EncodedContent.decode(content.content);\n    if (!decodedContent.type) {\n      throw new Error(\"missing content type\");\n    }\n    const contentType = new ContentTypeId(decodedContent.type);\n    const codec = registry.codecFor(contentType);\n    if (!codec) {\n      throw new Error(\n        `missing codec for content type \"${contentType.toString()}\"`,\n      );\n    }\n\n    return {\n      reference: content.parameters.reference,\n      referenceInboxId: content.parameters.referenceInboxId,\n      contentType,\n      content: codec.decode(decodedContent as EncodedContent, registry),\n    };\n  }\n\n  fallback(content: Reply): string | undefined {\n    if (typeof content.content === \"string\") {\n      return `Replied with “${content.content}” to an earlier message`;\n    }\n    return \"Replied to an earlier message\";\n  }\n\n  shouldPush() {\n    return true;\n  }\n}\n",
      "size_bytes": 2880
    },
    "content-types/content-type-reaction/vitest.setup.ts": {
      "content": "import { unlink } from \"node:fs/promises\";\nimport { dirname, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { glob } from \"fast-glob\";\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nexport const teardown = async () => {\n  const files = await glob(\"**/*.db3*\", { cwd: __dirname });\n  await Promise.all(files.map((file) => unlink(join(__dirname, file))));\n};\n",
      "size_bytes": 398
    },
    "apps/xmtp.chat/src/components/Messages/ReplyContent.tsx": {
      "content": "import { Group, Stack, Text, Tooltip } from \"@mantine/core\";\nimport type { DecodedMessage } from \"@xmtp/browser-sdk\";\nimport { type Reply } from \"@xmtp/content-type-reply\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport { MessageContent } from \"@/components/Messages/MessageContent\";\nimport type { MessageContentAlign } from \"@/components/Messages/MessageContentWrapper\";\nimport { useConversations } from \"@/hooks/useConversations\";\nimport classes from \"./ReplyContent.module.css\";\n\nexport type ReplyContentProps = {\n  align: MessageContentAlign;\n  conversationId: string;\n  fallback?: string;\n  reply: Reply;\n  scrollToMessage: (id: string) => void;\n};\n\nexport const ReplyContent: React.FC<ReplyContentProps> = ({\n  align,\n  conversationId,\n  fallback,\n  reply,\n  scrollToMessage,\n}) => {\n  const { getMessageById } = useConversations();\n  const [originalMessage, setOriginalMessage] = useState<\n    DecodedMessage | undefined\n  >(undefined);\n\n  useEffect(() => {\n    void getMessageById(reply.reference).then((originalMessage) => {\n      setOriginalMessage(originalMessage as DecodedMessage);\n    });\n  }, [reply.reference]);\n\n  const handleClick = useCallback(() => {\n    if (originalMessage) {\n      scrollToMessage(originalMessage.id);\n    }\n  }, [originalMessage, scrollToMessage]);\n\n  return (\n    <Stack gap=\"xs\" align={align === \"left\" ? \"flex-start\" : \"flex-end\"}>\n      <Group gap={4}>\n        <Text size=\"xs\">Replied to a</Text>\n        <Tooltip label=\"Click to scroll to the original message\">\n          <Text size=\"xs\" className={classes.text} onClick={handleClick}>\n            message\n          </Text>\n        </Tooltip>\n      </Group>\n      <MessageContent\n        contentType={reply.contentType}\n        content={reply.content}\n        conversationId={conversationId}\n        fallback={fallback}\n        align={align}\n        scrollToMessage={scrollToMessage}\n      />\n    </Stack>\n  );\n};\n",
      "size_bytes": 1927
    },
    "sdks/browser-sdk/src/utils/errors.ts": {
      "content": "import type { ContentTypeId } from \"@xmtp/content-type-primitives\";\n\nexport class ClientNotInitializedError extends Error {\n  constructor() {\n    super(\n      \"Client not initialized, use Client.create or Client.build to create a client\",\n    );\n  }\n}\n\nexport class SignerUnavailableError extends Error {\n  constructor() {\n    super(\n      \"Signer unavailable, use Client.create to create a client with a signer\",\n    );\n  }\n}\n\nexport class CodecNotFoundError extends Error {\n  constructor(contentType: ContentTypeId) {\n    super(`Codec not found for \"${contentType.toString()}\" content type`);\n  }\n}\n\nexport class InboxReassignError extends Error {\n  constructor() {\n    super(\n      \"Unable to create add account signature text, `allowInboxReassign` must be true\",\n    );\n  }\n}\n\nexport class AccountAlreadyAssociatedError extends Error {\n  constructor(inboxId: string) {\n    super(`Account already associated with inbox ${inboxId}`);\n  }\n}\n\nexport class GroupNotFoundError extends Error {\n  constructor(groupId: string) {\n    super(`Group \"${groupId}\" not found`);\n  }\n}\n\nexport class StreamNotFoundError extends Error {\n  constructor(streamId: string) {\n    super(`Stream \"${streamId}\" not found`);\n  }\n}\n\nexport class InvalidGroupMembershipChangeError extends Error {\n  constructor(messageId: string) {\n    super(`Invalid group membership change for message ${messageId}`);\n  }\n}\n\nexport class MissingContentTypeError extends Error {\n  constructor() {\n    super(\"Content type is required when sending content other than text\");\n  }\n}\n\nexport class StreamFailedError extends Error {\n  constructor(retryAttempts: number) {\n    const times = `time${retryAttempts !== 1 ? \"s\" : \"\"}`;\n    super(`Stream failed, retried ${retryAttempts} ${times}`);\n  }\n}\n\nexport class StreamInvalidRetryAttemptsError extends Error {\n  constructor() {\n    super(\"Stream retry attempts must be greater than 0\");\n  }\n}\n",
      "size_bytes": 1898
    },
    "apps/xmtp.chat/src/layouts/CenteredLayout.tsx": {
      "content": "import classes from \"./CenteredLayout.module.css\";\n\ntype CenteredLayoutProps = React.PropsWithChildren & {\n  fullScreen?: boolean;\n};\n\nexport const CenteredLayout: React.FC<CenteredLayoutProps> = ({\n  children,\n  fullScreen = false,\n}) => {\n  const rootClassNames = [\n    classes.root,\n    fullScreen && classes.fullScreen,\n  ].filter(Boolean);\n  return (\n    <div className={rootClassNames.join(\" \")}>\n      <div className={classes.content}>{children}</div>\n    </div>\n  );\n};\n",
      "size_bytes": 478
    },
    "sdks/browser-sdk/test/helpers.ts": {
      "content": "import {\n  ContentTypeId,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\nimport type { Identifier } from \"@xmtp/wasm-bindings\";\nimport { v4 } from \"uuid\";\nimport { createWalletClient, http, toBytes } from \"viem\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { sepolia } from \"viem/chains\";\nimport { Client } from \"@/Client\";\nimport type { ClientOptions } from \"@/types/options\";\nimport type { Signer } from \"@/utils/signer\";\n\nexport const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n\nexport const createUser = () => {\n  const key = generatePrivateKey();\n  const account = privateKeyToAccount(key);\n  return {\n    key,\n    account,\n    wallet: createWalletClient({\n      account,\n      chain: sepolia,\n      transport: http(),\n    }),\n    uuid: v4(),\n  };\n};\n\nexport const createIdentifier = (user: User): Identifier => ({\n  identifier: user.account.address.toLowerCase(),\n  identifierKind: \"Ethereum\",\n});\n\nexport const createSigner = (user: User): Signer => {\n  const identifier = createIdentifier(user);\n  return {\n    type: \"EOA\",\n    getIdentifier: () => identifier,\n    signMessage: async (message: string) => {\n      const signature = await user.wallet.signMessage({\n        message,\n      });\n      return toBytes(signature);\n    },\n  };\n};\n\nexport type User = ReturnType<typeof createUser>;\n\nexport const buildClient = async <ContentCodecs extends ContentCodec[] = []>(\n  identifier: Identifier,\n  options?: ClientOptions & {\n    codecs?: ContentCodecs;\n  },\n) => {\n  const opts = {\n    ...options,\n    env: options?.env ?? \"local\",\n  };\n  return Client.build<ContentCodecs>(identifier, {\n    ...opts,\n    dbPath: opts.dbPath ?? `./test-${identifier.identifier}.db3`,\n  });\n};\n\nexport const createClient = async <ContentCodecs extends ContentCodec[] = []>(\n  signer: Signer,\n  options?: ClientOptions & {\n    codecs?: ContentCodecs;\n  },\n) => {\n  const opts = {\n    ...options,\n    env: options?.env ?? \"local\",\n  };\n  const identifier = await signer.getIdentifier();\n  return Client.create<ContentCodecs>(signer, {\n    ...opts,\n    disableAutoRegister: true,\n    dbPath: opts.dbPath ?? `./test-${identifier.identifier}.db3`,\n  });\n};\n\nexport const createRegisteredClient = async <\n  ContentCodecs extends ContentCodec[] = [],\n>(\n  signer: Signer,\n  options?: ClientOptions & {\n    codecs?: ContentCodecs;\n  },\n) => {\n  const opts = {\n    ...options,\n    env: options?.env ?? \"local\",\n  };\n  const identifier = await signer.getIdentifier();\n  return Client.create<ContentCodecs>(signer, {\n    ...opts,\n    dbPath: opts.dbPath ?? `./test-${identifier.identifier}.db3`,\n  });\n};\n\nexport const ContentTypeTest = new ContentTypeId({\n  authorityId: \"xmtp.org\",\n  typeId: \"test\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\nexport class TestCodec implements ContentCodec {\n  get contentType(): ContentTypeId {\n    return ContentTypeTest;\n  }\n\n  encode(content: Record<string, string>) {\n    return {\n      type: this.contentType,\n      parameters: {},\n      content: new TextEncoder().encode(JSON.stringify(content)),\n    };\n  }\n\n  decode(content: EncodedContent): Record<string, string> {\n    const decoded = new TextDecoder().decode(content.content);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return JSON.parse(decoded);\n  }\n\n  fallback() {\n    return undefined;\n  }\n\n  shouldPush() {\n    return false;\n  }\n}\n",
      "size_bytes": 3447
    },
    "apps/xmtp.chat/src/components/Conversation/Composer.module.css": {
      "content": ".wrapper {\n  width: 100%;\n}\n\n.composer {\n  display: grid;\n  grid-template-columns: auto 1fr auto;\n  align-items: center;\n  gap: var(--mantine-spacing-sm);\n  padding: 10px 14px;\n  background: rgba(10, 13, 25, 0.88);\n  border: 1px solid rgba(148, 163, 184, 0.16);\n  border-radius: 999px;\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);\n}\n\n.actionButton {\n  color: rgba(203, 213, 225, 0.9);\n}\n\n.input {\n  width: 100%;\n  color: rgba(238, 242, 255, 0.95);\n  font-size: 0.95rem;\n}\n\n.input::placeholder {\n  color: rgba(148, 163, 184, 0.75);\n}\n\n.sendButton {\n  padding-inline: 18px;\n  box-shadow: 0 12px 24px rgba(10, 255, 241, 0.2);\n}\n\n.sendButton:disabled {\n  box-shadow: none;\n}\n\n@media (max-width: 640px) {\n  .composer {\n    grid-template-columns: auto 1fr auto;\n    gap: var(--mantine-spacing-xs);\n    padding: 8px 12px;\n    border-radius: 28px;\n  }\n\n  .sendButton {\n    padding-inline: 14px;\n  }\n}\n\n@media (max-width: 480px) {\n  .composer {\n    padding: 8px 10px;\n    gap: var(--mantine-spacing-xs);\n  }\n\n  .sendButton {\n    padding-inline: 12px;\n    font-size: 0.9rem;\n  }\n}\n",
      "size_bytes": 1081
    },
    "content-types/content-type-wallet-send-calls/vitest.config.ts": {
      "content": "import { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    globalSetup: [\"./vitest.setup.ts\"],\n  },\n});\n",
      "size_bytes": 155
    },
    "sdks/node-sdk/src/utils/signer.ts": {
      "content": "import type { Identifier } from \"@xmtp/node-bindings\";\n\nexport type SignMessage = (message: string) => Promise<Uint8Array> | Uint8Array;\nexport type GetIdentifier = () => Promise<Identifier> | Identifier;\nexport type GetChainId = () => bigint;\nexport type GetBlockNumber = () => bigint;\n\nexport type Signer =\n  | {\n      type: \"EOA\";\n      signMessage: SignMessage;\n      getIdentifier: GetIdentifier;\n    }\n  | {\n      type: \"SCW\";\n      signMessage: SignMessage;\n      getIdentifier: GetIdentifier;\n      getBlockNumber?: GetBlockNumber;\n      getChainId: GetChainId;\n    };\n\nexport type EOASigner = Extract<Signer, { type: \"EOA\" }>;\nexport type SCWSigner = Extract<Signer, { type: \"SCW\" }>;\n",
      "size_bytes": 694
    },
    "apps/xmtp.chat/src/icons/CoinbaseWallet.tsx": {
      "content": "export const CoinbaseWallet = () => {\n  return (\n    <svg\n      width=\"28\"\n      height=\"28\"\n      viewBox=\"0 0 28 28\"\n      fill=\"none\"\n      xmlns=\"http://www.w3.org/2000/svg\">\n      <rect width=\"28\" height=\"28\" fill=\"#2C5FF6\" />\n      <path\n        fillRule=\"evenodd\"\n        clipRule=\"evenodd\"\n        d=\"M14 23.8C19.4124 23.8 23.8 19.4124 23.8 14C23.8 8.58761 19.4124 4.2 14 4.2C8.58761 4.2 4.2 8.58761 4.2 14C4.2 19.4124 8.58761 23.8 14 23.8ZM11.55 10.8C11.1358 10.8 10.8 11.1358 10.8 11.55V16.45C10.8 16.8642 11.1358 17.2 11.55 17.2H16.45C16.8642 17.2 17.2 16.8642 17.2 16.45V11.55C17.2 11.1358 16.8642 10.8 16.45 10.8H11.55Z\"\n        fill=\"white\"\n      />\n    </svg>\n  );\n};\n",
      "size_bytes": 683
    },
    "apps/xmtp.chat/src/components/Identity/IdentityModal.tsx": {
      "content": "import {\n  Button,\n  CloseButton,\n  Group,\n  Paper,\n  Stack,\n  Text,\n  Title,\n} from \"@mantine/core\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport { useNavigate } from \"react-router\";\nimport { BadgeWithCopy } from \"@/components/BadgeWithCopy\";\nimport { InstallationTable } from \"@/components/Identity/InstallationTable\";\nimport { Modal } from \"@/components/Modal\";\nimport { useClient } from \"@/contexts/XMTPContext\";\nimport { useCollapsedMediaQuery } from \"@/hooks/useCollapsedMediaQuery\";\nimport { useIdentity } from \"@/hooks/useIdentity\";\nimport { ContentLayout } from \"@/layouts/ContentLayout\";\n\nexport const IdentityModal: React.FC = () => {\n  const navigate = useNavigate();\n  const client = useClient();\n\n  const {\n    installations,\n    revokeAllOtherInstallations,\n    revoking,\n    sync,\n    syncing,\n  } = useIdentity(true);\n  const [accountIdentifier, setAccountIdentifier] = useState<string | null>(\n    null,\n  );\n\n  const fullScreen = useCollapsedMediaQuery();\n  const contentHeight = fullScreen ? \"auto\" : \"70dvh\";\n\n  useEffect(() => {\n    setAccountIdentifier(\n      client.accountIdentifier?.identifier.toLowerCase() ?? null,\n    );\n  }, [client.accountIdentifier]);\n\n  const handleRevokeAllOtherInstallations = useCallback(async () => {\n    await revokeAllOtherInstallations();\n    await sync();\n  }, [revokeAllOtherInstallations, sync]);\n\n  const handleClose = useCallback(() => {\n    void navigate(-1);\n  }, [navigate]);\n\n  return (\n    <>\n      <Modal\n        opened\n        centered\n        withCloseButton={false}\n        fullScreen={fullScreen}\n        onClose={handleClose}\n        size=\"auto\"\n        padding={0}>\n        <ContentLayout\n          maxHeight={contentHeight}\n          loading={revoking || syncing}\n          withScrollAreaPadding={false}\n          title={\n            <Group justify=\"space-between\" align=\"center\" flex={1}>\n              <Text size=\"lg\" fw={700} c=\"text.primary\">\n                Identity\n              </Text>\n              <CloseButton size=\"md\" onClick={handleClose} />\n            </Group>\n          }>\n          <Stack gap=\"md\" p=\"md\">\n            <Paper p=\"md\" radius=\"md\" withBorder>\n              <Stack gap=\"md\">\n                <Group gap=\"md\" wrap=\"nowrap\">\n                  <Text flex=\"0 0 25%\" style={{ whiteSpace: \"nowrap\" }}>\n                    Address\n                  </Text>\n                  <BadgeWithCopy value={accountIdentifier || \"\"} />\n                </Group>\n                <Group gap=\"md\" wrap=\"nowrap\">\n                  <Text flex=\"0 0 25%\" style={{ whiteSpace: \"nowrap\" }}>\n                    Inbox ID\n                  </Text>\n                  {/* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */}\n                  <BadgeWithCopy value={client.inboxId!} />\n                </Group>\n                <Group gap=\"md\" wrap=\"nowrap\">\n                  <Text flex=\"0 0 25%\" style={{ whiteSpace: \"nowrap\" }}>\n                    Installation ID\n                  </Text>\n                  {/* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */}\n                  <BadgeWithCopy value={client.installationId!} />\n                </Group>\n              </Stack>\n            </Paper>\n            <Title order={4} ml=\"md\">\n              Installations\n            </Title>\n            <Paper p=\"md\" radius=\"md\" withBorder>\n              <Stack gap=\"md\">\n                {installations.length === 0 && (\n                  <Text>No other installations found</Text>\n                )}\n                {installations.length > 0 && (\n                  <>\n                    <InstallationTable\n                      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                      clientInstallationId={client.installationId!}\n                      installations={installations}\n                      refreshInstallations={sync}\n                    />\n                    <Group justify=\"flex-end\">\n                      <Button\n                        variant=\"outline\"\n                        color=\"red\"\n                        onClick={() =>\n                          void handleRevokeAllOtherInstallations()\n                        }>\n                        Revoke all other installations\n                      </Button>\n                    </Group>\n                  </>\n                )}\n              </Stack>\n            </Paper>\n          </Stack>\n        </ContentLayout>\n      </Modal>\n    </>\n  );\n};\n",
      "size_bytes": 4480
    },
    "content-types/content-type-markdown/src/index.ts": {
      "content": "export * from \"./Markdown\";\n",
      "size_bytes": 28
    },
    "apps/xmtp.chat/src/hooks/useMemberId.ts": {
      "content": "import { useEffect, useState } from \"react\";\nimport {\n  getInboxIdForAddressQuery,\n  isValidName,\n  resolveNameQuery,\n} from \"@/helpers/names\";\nimport { isValidEthereumAddress, isValidInboxId } from \"@/helpers/strings\";\nimport { useSettings } from \"@/hooks/useSettings\";\nimport { combineProfiles } from \"@/stores/profiles\";\n\nexport const useMemberId = () => {\n  const [loading, setLoading] = useState(false);\n  const [memberId, setMemberId] = useState(\"\");\n  const [inboxId, setInboxId] = useState(\"\");\n  const [address, setAddress] = useState(\"\");\n  const [displayName, setDisplayName] = useState<string | null>(null);\n  const [description, setDescription] = useState<string | null>(null);\n  const [avatar, setAvatar] = useState<string | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const { environment } = useSettings();\n\n  useEffect(() => {\n    const checkMemberId = async () => {\n      setError(null);\n      setInboxId(\"\");\n      setAddress(\"\");\n      setDisplayName(null);\n      setDescription(null);\n      setAvatar(null);\n\n      if (!memberId) {\n        return;\n      }\n\n      if (\n        !isValidEthereumAddress(memberId) &&\n        !isValidInboxId(memberId) &&\n        !isValidName(memberId)\n      ) {\n        setError(\"Invalid address, inbox ID, ENS name, or Base name\");\n      } else if (isValidEthereumAddress(memberId)) {\n        setLoading(true);\n\n        try {\n          const inboxId = await getInboxIdForAddressQuery(\n            memberId.toLowerCase(),\n            environment,\n          );\n\n          if (!inboxId) {\n            setError(\"Address not registered on XMTP\");\n          } else {\n            setInboxId(inboxId);\n            setAddress(memberId);\n          }\n        } catch {\n          setError(\"Unable to get inbox ID for address. Try again.\");\n        } finally {\n          setLoading(false);\n        }\n      } else if (isValidInboxId(memberId)) {\n        setInboxId(memberId);\n      } else if (isValidName(memberId)) {\n        setLoading(true);\n        try {\n          const profiles = await resolveNameQuery(memberId);\n          if (!profiles || profiles.length === 0) {\n            setError(\"Invalid ENS or Base name\");\n          } else {\n            try {\n              const profile = combineProfiles(\n                profiles[0].address,\n                profiles,\n                memberId,\n              );\n              const inboxId = await getInboxIdForAddressQuery(\n                profile.address,\n                environment,\n              );\n              if (!inboxId) {\n                setError(\"Address not registered on XMTP\");\n              } else {\n                setInboxId(inboxId);\n                setAddress(profile.address);\n                setDisplayName(profile.displayName);\n                setDescription(profile.description);\n                setAvatar(profile.avatar);\n              }\n            } catch {\n              setError(\"Unable to get inbox ID for address. Try again.\");\n            } finally {\n              setLoading(false);\n            }\n          }\n        } catch {\n          setError(\"Unable to resolve name\");\n        } finally {\n          setLoading(false);\n        }\n      }\n    };\n\n    void checkMemberId();\n  }, [memberId, environment]);\n\n  return {\n    memberId,\n    setMemberId,\n    error,\n    loading,\n    inboxId,\n    address,\n    displayName,\n    description,\n    avatar,\n    setMemberIdError: setError,\n  };\n};\n",
      "size_bytes": 3433
    },
    "content-types/content-type-text/CHANGELOG.md": {
      "content": "# @xmtp/content-type-text\n\n## 2.0.2\n\n### Patch Changes\n\n- Updated dependencies [779fd0c]\n  - @xmtp/content-type-primitives@2.0.2\n\n## 2.0.1\n\n### Patch Changes\n\n- Updated dependencies [340fcf4]\n  - @xmtp/content-type-primitives@2.0.1\n\n## 2.0.0\n\n### Major Changes\n\n- 1777a23: Dropped support for CommonJS\n\n### Patch Changes\n\n- Updated dependencies [1777a23]\n  - @xmtp/content-type-primitives@2.0.0\n\n## 1.0.1\n\n### Patch Changes\n\n- Updated dependencies [63e5276]\n  - @xmtp/content-type-primitives@1.0.3\n\n## 1.0.0\n\nInitial release\n",
      "size_bytes": 525
    },
    "apps/xmtp.chat/src/components/DateLabel.tsx": {
      "content": "import { Flex, Text, Tooltip } from \"@mantine/core\";\nimport { useClipboard } from \"@mantine/hooks\";\nimport { formatRFC3339, intlFormat } from \"date-fns\";\n\nexport type DateLabelTooltipProps = {\n  date: Date;\n};\n\nexport const DateLabelTooltip: React.FC<DateLabelTooltipProps> = ({ date }) => {\n  return (\n    <Flex direction=\"column\">\n      <Text size=\"sm\">{formatRFC3339(date, { fractionDigits: 3 })}</Text>\n      <Text size=\"xs\" c=\"dimmed\" ta=\"center\">\n        click to copy\n      </Text>\n    </Flex>\n  );\n};\n\nexport type DateLabelProps = {\n  date: Date;\n  size?: \"sm\" | \"xs\" | \"md\" | \"lg\" | \"xl\";\n  align?: \"left\" | \"right\" | \"center\";\n  padding?: \"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\";\n};\n\nexport const DateLabel: React.FC<DateLabelProps> = ({\n  date,\n  size = \"sm\",\n  align = \"left\",\n  padding,\n}) => {\n  const clipboard = useClipboard({ timeout: 1000 });\n\n  const handleCopy = (\n    event:\n      | React.MouseEvent<HTMLDivElement>\n      | React.KeyboardEvent<HTMLDivElement>,\n  ) => {\n    event.stopPropagation();\n    clipboard.copy(formatRFC3339(date, { fractionDigits: 3 }));\n  };\n\n  const handleKeyboardCopy = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    if (event.key === \"Enter\" || event.key === \" \") {\n      handleCopy(event);\n    }\n  };\n\n  return (\n    <Tooltip\n      label={\n        clipboard.copied ? (\n          <Text size=\"xs\">Copied!</Text>\n        ) : (\n          <DateLabelTooltip date={date} />\n        )\n      }\n      withArrow\n      events={{ hover: true, focus: true, touch: true }}>\n      <Text\n        p={padding}\n        pt={0}\n        size={size}\n        ta={align}\n        onKeyDown={handleKeyboardCopy}\n        onClick={handleCopy}\n        miw={100}\n        tabIndex={0}>\n        {intlFormat(date, {\n          year: \"numeric\",\n          month: \"2-digit\",\n          day: \"2-digit\",\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n        })}\n      </Text>\n    </Tooltip>\n  );\n};\n",
      "size_bytes": 1947
    },
    "sdks/node-sdk/scripts/accounts.ts": {
      "content": "import { writeFile } from \"node:fs/promises\";\nimport path from \"node:path\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\n\ntype Account = [key: string, address: string];\ntype AccountsMap = Record<string, string>;\n\nconst createRandomAccount = (): Account => {\n  const privateKey = generatePrivateKey();\n  const account = privateKeyToAccount(privateKey);\n  return [privateKey, account.address];\n};\n\nconst writeAccountsJson = async (accounts: AccountsMap) => {\n  console.log(\"Writing accounts to file...\");\n  const accountsJsonPath = path.join(import.meta.dirname, \"accounts.json\");\n  await writeFile(accountsJsonPath, JSON.stringify(accounts, null, 2));\n  console.log(`Accounts data written to '${accountsJsonPath}'`);\n};\n\nconst main = async () => {\n  console.log(\"Creating 1000 accounts...\");\n  const accounts = Object.fromEntries(\n    Array.from({ length: 1000 }, () => createRandomAccount()),\n  );\n  await writeAccountsJson(accounts);\n};\n\nawait main();\n",
      "size_bytes": 981
    },
    "content-types/content-type-reaction/vitest.config.ts": {
      "content": "import { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    globalSetup: [\"./vitest.setup.ts\"],\n  },\n});\n",
      "size_bytes": 155
    },
    "apps/xmtp.chat/src/components/Markdown.tsx": {
      "content": "import {\n  Anchor,\n  Blockquote,\n  Code,\n  List,\n  Table,\n  Text,\n  Title,\n} from \"@mantine/core\";\nimport ReactMarkdown, { type Components } from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\n\nexport type MarkdownProps = {\n  markdown: string;\n};\n\nconst components: Components = {\n  h1: ({ node, ...rest }) => <Title order={1} {...rest} my=\"md\" />,\n  h2: ({ node, ...rest }) => <Title order={2} {...rest} my=\"md\" />,\n  h3: ({ node, ...rest }) => <Title order={3} {...rest} my=\"md\" />,\n  h4: ({ node, ...rest }) => <Title order={4} {...rest} my=\"md\" />,\n  h5: ({ node, ...rest }) => <Title order={5} {...rest} my=\"md\" />,\n  h6: ({ node, ...rest }) => <Title order={6} {...rest} my=\"md\" />,\n  em: ({ node, ...rest }) => <Text {...rest} component=\"span\" fs=\"italic\" />,\n  strong: ({ node, ...rest }) => <Text {...rest} component=\"span\" fw={700} />,\n  a: ({ node, ...rest }) => (\n    <Anchor {...rest} target=\"_blank\" rel=\"noopener noreferrer\" />\n  ),\n  ul: ({ node, ...rest }) => <List {...rest} spacing=\"xxxs\" px=\"md\" />,\n  ol: ({ node, ...rest }) => (\n    <List {...rest} type=\"ordered\" spacing=\"xxxs\" px=\"md\" />\n  ),\n  li: ({ node, ...rest }) => <List.Item {...rest} />,\n  blockquote: ({ node, ...rest }) => <Blockquote {...rest} p=\"md\" />,\n  p: ({ node, ...rest }) => <Text {...rest} my=\"md\" />,\n  code: ({ node, ...rest }) => <Code {...rest} my=\"md\" />,\n  pre: ({ node, ...rest }) => <Code {...rest} block my=\"md\" />,\n  del: ({ node, ...rest }) => (\n    <Text {...rest} component=\"span\" td=\"line-through\" />\n  ),\n  table: ({ node, ...rest }) => <Table {...rest} />,\n  thead: ({ node, ...rest }) => <Table.Thead {...rest} />,\n  tbody: ({ node, ...rest }) => <Table.Tbody {...rest} />,\n  tr: ({ node, ...rest }) => <Table.Tr {...rest} />,\n  th: ({ node, ...rest }) => <Table.Th {...rest} />,\n  td: ({ node, ...rest }) => <Table.Td {...rest} />,\n};\n\nexport const Markdown: React.FC<MarkdownProps> = ({ markdown }) => {\n  return (\n    <ReactMarkdown\n      disallowedElements={[\"input\", \"img\", \"hr\"]}\n      components={components}\n      skipHtml\n      remarkPlugins={[remarkGfm]}>\n      {markdown}\n    </ReactMarkdown>\n  );\n};\n",
      "size_bytes": 2131
    },
    "content-types/content-type-read-receipt/vitest.setup.ts": {
      "content": "import { unlink } from \"node:fs/promises\";\nimport { dirname, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { glob } from \"fast-glob\";\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nexport const teardown = async () => {\n  const files = await glob(\"**/*.db3*\", { cwd: __dirname });\n  await Promise.all(files.map((file) => unlink(join(__dirname, file))));\n};\n",
      "size_bytes": 398
    },
    "apps/xmtp.chat/README.md": {
      "content": "# xmtp.chat app\n\nUse this React app as a tool to start building an app with XMTP.\n\nThe app is built using the [XMTP client browser SDK](/sdks/browser-sdk/README.md), [React](https://react.dev/), and [RainbowKit](https://www.rainbowkit.com/).\n\nTo keep up with the latest React app developments, see the [Issues tab](https://github.com/xmtp/xmtp-js/issues) in this repo.\n\nTo learn more about XMTP and get answers to frequently asked questions, see the [XMTP documentation](https://xmtp.org/docs).\n\n### Limitations\n\nThis React app isn't a complete solution. For example, the list of conversations doesn't update when new messages arrive in existing conversations.\n\n## Useful commands\n\n- `yarn clean`: Removes `node_modules` and `.turbo` folders\n- `yarn dev`: Runs the app in development mode\n- `yarn typecheck`: Runs `tsc`\n",
      "size_bytes": 820
    },
    "apps/xmtp.chat/src/content-types/Intent.ts": {
      "content": "import {\n  ContentTypeId,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\nimport { z } from \"zod\";\n\n// 10KB limit for intent metadata\nconst INTENT_METADATA_LIMIT = 10 * 1024;\n\n/**\n * Intent content structure\n * Users express their selection by sending Intent messages when they tap action buttons\n */\nconst intentSchema = z.object({\n  /** References Actions.id - provides strong coupling with Actions message */\n  id: z.string(),\n  /** References specific Action.id - indicates which action was selected */\n  actionId: z.string(),\n  /** Optional context data for the selection */\n  metadata: z\n    .record(\n      z.string(),\n      z.union([z.string(), z.number(), z.boolean(), z.null()]),\n    )\n    .optional(),\n});\n\nexport type Intent = z.infer<typeof intentSchema>;\n\n/**\n * Content Type ID for Intent messages\n * Following XIP-67 specification for inline actions\n */\nexport const ContentTypeIntent = new ContentTypeId({\n  authorityId: \"coinbase.com\",\n  typeId: \"intent\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\n/**\n * Intent codec for encoding/decoding Intent messages\n * Implements XMTP ContentCodec interface for Intent content type\n */\nexport class IntentCodec implements ContentCodec<Intent> {\n  get contentType(): ContentTypeId {\n    return ContentTypeIntent;\n  }\n\n  encode(content: Intent): EncodedContent {\n    this.#validateContent(content);\n\n    return {\n      type: ContentTypeIntent,\n      parameters: {},\n      content: new TextEncoder().encode(JSON.stringify(content)),\n    };\n  }\n\n  decode(content: EncodedContent): Intent {\n    const decodedContent = new TextDecoder().decode(content.content);\n    try {\n      const parsed = JSON.parse(decodedContent) as Intent;\n      this.#validateContent(parsed);\n      return parsed;\n    } catch (error: unknown) {\n      throw new Error(\n        `Failed to decode Intent content: ${(error as Error).message}`,\n      );\n    }\n  }\n\n  fallback(content: Intent): string {\n    return `User selected action: ${content.actionId}`;\n  }\n\n  shouldPush(): boolean {\n    return true;\n  }\n\n  /**\n   * Validates Intent content according to XIP-67 specification\n   */\n  #validateContent(content: Intent): void {\n    const result = intentSchema.safeParse(content);\n    if (!result.success) {\n      throw new Error(z.prettifyError(result.error));\n    }\n\n    // Validate metadata if provided\n    if (content.metadata !== undefined) {\n      // Check for reasonable metadata size to avoid XMTP content limits\n      const metadataString = JSON.stringify(content.metadata);\n      if (metadataString.length > INTENT_METADATA_LIMIT) {\n        // 10KB limit for metadata\n        throw new Error(\n          `Intent.metadata is too large (exceeds ${(INTENT_METADATA_LIMIT / 1024).toFixed(0)}KB limit)`,\n        );\n      }\n    }\n  }\n}\n",
      "size_bytes": 2800
    },
    "apps/xmtp.chat/src/layouts/ContentLayout.module.css": {
      "content": ":root {\n  --content-aside-width: 260px;\n  --content-header-padding: var(--mantine-spacing-md);\n  --content-header-button-height: rem(36px);\n  --content-header-border-width: 1px;\n  --content-header-height: calc(\n    var(--content-header-padding) * 2 + var(--content-header-button-height) +\n      calc(var(--content-header-border-width) * 2)\n  );\n  --content-header-border-color: var(--mantine-color-default-border);\n  --content-gradient-color-light: var(--mantine-color-gray-0);\n  --content-gradient-color-dark: var(--mantine-color-dark-7);\n}\n\n.root {\n  position: relative;\n  z-index: 20;\n  flex-grow: 1;\n}\n\n.header {\n  flex-shrink: 0;\n  position: relative;\n  z-index: 10;\n  padding: var(--content-header-padding);\n  height: var(--content-header-height);\n  background: rgba(8, 11, 22, 0.78);\n  border: var(--content-header-border-width) solid rgba(10, 255, 241, 0.16);\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.02);\n  backdrop-filter: blur(10px);\n  display: flex;\n  align-items: center;\n  gap: var(--mantine-spacing-sm);\n}\n\n.header.withBorders {\n  border-top-left-radius: var(--mantine-radius-md);\n  border-top-right-radius: var(--mantine-radius-md);\n}\n\n.headerActions {\n  flex-shrink: 0;\n  margin-left: auto;\n}\n\n.content {\n  position: relative;\n  z-index: 10;\n  min-height: 0;\n  flex-grow: 1;\n  display: flex;\n  flex-direction: column;\n  background: rgba(6, 9, 20, 0.72);\n  --gradient-color: light-dark(\n    var(--content-gradient-color-light),\n    var(--content-gradient-color-dark)\n  );\n  border-left: var(--content-header-border-width) solid rgba(10, 255, 241, 0.12);\n  border-right: var(--content-header-border-width) solid rgba(10, 255, 241, 0.12);\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.02);\n}\n\n.content.withBorders {\n  border-left-color: rgba(10, 255, 241, 0.12);\n  border-right-color: rgba(10, 255, 241, 0.12);\n}\n\n.content.noFooter.withBorders {\n  border-bottom-left-radius: var(--mantine-radius-md);\n  border-bottom-right-radius: var(--mantine-radius-md);\n  border-bottom: var(--content-header-border-width) solid rgba(10, 255, 241, 0.12);\n}\n\n.contentScrollFade::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 20px;\n  background: linear-gradient(to top, transparent, var(--gradient-color) 20px);\n  pointer-events: none;\n  z-index: 1;\n  border-radius: var(--mantine-radius-md) var(--mantine-radius-md) 0 0;\n}\n\n.contentScrollFade::after {\n  content: \"\";\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  height: 20px;\n  background: linear-gradient(\n    to bottom,\n    transparent,\n    var(--gradient-color) 20px\n  );\n  pointer-events: none;\n  z-index: 1;\n  border-radius: 0 0 var(--mantine-radius-md) var(--mantine-radius-md);\n}\n\n.scrollArea {\n  flex-grow: 1;\n}\n\n.aside {\n  position: absolute;\n  top: 0;\n  bottom: var(--mantine-spacing-md);\n  right: 0;\n  width: var(--content-aside-width);\n  z-index: 1;\n  background-color: var(--mantine-color-body);\n  transition:\n    right 0.1s ease-out,\n    bottom 0.1s ease-out;\n  display: flex;\n  flex-direction: column;\n}\n\n.showAside {\n  right: calc(var(--content-aside-width) * -1 + 1px);\n}\n\n.footer {\n  position: relative;\n  flex-shrink: 0;\n  z-index: 10;\n  background: rgba(6, 9, 20, 0.78);\n  border: var(--content-header-border-width) solid rgba(10, 255, 241, 0.12);\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.02);\n  backdrop-filter: blur(10px);\n}\n\n.footer.withBorders {\n  border-bottom-left-radius: var(--mantine-radius-md);\n  border-bottom-right-radius: var(--mantine-radius-md);\n  border-color: rgba(10, 255, 241, 0.12);\n}\n\n@media screen and (max-width: 768px) {\n  .header {\n    padding: var(--mantine-spacing-sm);\n    height: auto;\n    gap: var(--mantine-spacing-xs);\n    flex-wrap: wrap;\n  }\n\n  .content {\n    border-left: none;\n    border-right: none;\n    padding: 0 var(--mantine-spacing-sm);\n  }\n\n  .content.withBorders {\n    border-left: none;\n    border-right: none;\n  }\n\n  .footer {\n    padding: var(--mantine-spacing-sm);\n    border-left: none;\n    border-right: none;\n  }\n}\n\n@media screen and (max-width: 520px) {\n  .header {\n    padding: var(--mantine-spacing-sm) var(--mantine-spacing-xs);\n    gap: var(--mantine-spacing-xxs);\n  }\n\n  .content {\n    padding: 0 var(--mantine-spacing-xs);\n  }\n\n  .footer {\n    padding: var(--mantine-spacing-sm) var(--mantine-spacing-xs);\n  }\n}\n\n@media screen and (max-width: 1280px) {\n  .aside {\n    right: 0;\n    bottom: 0;\n    transition-duration: 0s;\n  }\n\n  .aside.showAside {\n    z-index: 30;\n  }\n}\n\n@media screen and (max-width: 1080px) {\n  .header.withBorders {\n    border-left: none;\n    border-right: none;\n    border-radius: 0;\n  }\n\n  .content.withBorders {\n    border-left: none;\n    border-right: none;\n    border-radius: 0;\n  }\n\n  .content.noFooter.withBorders {\n    border-bottom: none;\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n\n  .footer.withBorders {\n    border-left: none;\n    border-right: none;\n    border-radius: 0;\n  }\n\n  .aside {\n    right: calc(var(--content-aside-width) * -1 + 1px);\n    transition-duration: 0.1s;\n  }\n\n  .showAside {\n    right: 0;\n  }\n}\n",
      "size_bytes": 5085
    },
    "apps/xmtp.chat/src/components/Identity/InstallationTable.tsx": {
      "content": "import {\n  Box,\n  Button,\n  Popover,\n  Table,\n  Text,\n  Tooltip,\n  useMatches,\n} from \"@mantine/core\";\nimport { formatDistanceToNow } from \"date-fns\";\nimport { BadgeWithCopy } from \"@/components/BadgeWithCopy\";\nimport { CodeWithCopy } from \"@/components/CodeWithCopy\";\nimport { nsToDate } from \"@/helpers/date\";\nimport { useIdentity, type Installation } from \"@/hooks/useIdentity\";\n\ntype InstallationTableRowProps = {\n  clientInstallationId: string;\n  installation: Installation;\n  refreshInstallations: () => Promise<void>;\n};\n\nconst InstallationTableRow: React.FC<InstallationTableRowProps> = ({\n  clientInstallationId,\n  installation,\n  refreshInstallations,\n}) => {\n  const { revokeInstallation, revoking } = useIdentity();\n\n  const handleRevokeInstallation = async (installationIdBytes: Uint8Array) => {\n    await revokeInstallation(installationIdBytes);\n    await refreshInstallations();\n  };\n\n  const maw = useMatches({\n    base: \"12rem\",\n    sm: \"20rem\",\n  });\n\n  const createdAt = nsToDate(installation.clientTimestampNs ?? 0n);\n  const notAfter = installation.keyPackageStatus?.lifetime?.notAfter\n    ? new Date(Number(installation.keyPackageStatus.lifetime.notAfter) * 1000)\n    : undefined;\n\n  return (\n    <Table.Tr>\n      <Table.Td maw={maw}>\n        <BadgeWithCopy value={installation.id} />\n      </Table.Td>\n      <Table.Td>\n        <Tooltip label={createdAt.toISOString()}>\n          <Text size=\"sm\" style={{ whiteSpace: \"nowrap\" }}>\n            {formatDistanceToNow(createdAt, {\n              addSuffix: true,\n            })}\n          </Text>\n        </Tooltip>\n      </Table.Td>\n      <Table.Td>\n        {notAfter ? (\n          <Tooltip label={notAfter.toISOString()}>\n            <Text size=\"sm\" style={{ whiteSpace: \"nowrap\" }}>\n              {formatDistanceToNow(notAfter, {\n                addSuffix: true,\n              })}\n            </Text>\n          </Tooltip>\n        ) : (\n          <Text size=\"sm\">Error</Text>\n        )}\n      </Table.Td>\n      <Table.Td w=\"100\">\n        {installation.keyPackageStatus?.validationError ? (\n          <Popover width={200} position=\"bottom\" withArrow shadow=\"md\">\n            <Popover.Target>\n              <Button color=\"red\" size=\"xs\">\n                Details\n              </Button>\n            </Popover.Target>\n            <Popover.Dropdown>\n              <Box maw=\"300\">\n                <CodeWithCopy\n                  code={installation.keyPackageStatus.validationError}\n                />\n              </Box>\n            </Popover.Dropdown>\n          </Popover>\n        ) : (\n          <Text size=\"sm\">None</Text>\n        )}\n      </Table.Td>\n      <Table.Td w=\"100\">\n        {installation.id !== clientInstallationId && (\n          <Button\n            size=\"xs\"\n            loading={revoking}\n            onClick={() => void handleRevokeInstallation(installation.bytes)}>\n            Revoke\n          </Button>\n        )}\n      </Table.Td>\n    </Table.Tr>\n  );\n};\n\ntype InstallationTableProps = {\n  clientInstallationId: string;\n  installations: Installation[];\n  refreshInstallations: () => Promise<void>;\n};\n\nexport const InstallationTable: React.FC<InstallationTableProps> = ({\n  clientInstallationId,\n  installations,\n  refreshInstallations,\n}) => {\n  return (\n    <Table>\n      <Table.Thead>\n        <Table.Tr>\n          <Table.Th>Installation ID</Table.Th>\n          <Table.Th>Created</Table.Th>\n          <Table.Th>Expires</Table.Th>\n          <Table.Th>Error</Table.Th>\n          <Table.Th></Table.Th>\n        </Table.Tr>\n      </Table.Thead>\n      <Table.Tbody>\n        {installations.map((installation) => (\n          <InstallationTableRow\n            key={installation.id}\n            clientInstallationId={clientInstallationId}\n            installation={installation}\n            refreshInstallations={refreshInstallations}\n          />\n        ))}\n      </Table.Tbody>\n    </Table>\n  );\n};\n",
      "size_bytes": 3879
    },
    "sdks/browser-sdk/README.md": {
      "content": "# XMTP client SDK for browsers\n\nThis package provides the XMTP client SDK for browsers.\n\nTo keep up with the latest SDK developments, see the [Issues tab](https://github.com/xmtp/xmtp-js/issues) in this repo.\n\n> [!CAUTION]\n> This SDK is in beta status and ready for you to build with in production. Software in this status may change based on feedback.\n\n## Documentation\n\nTo learn how to use the XMTP client SDK for browsers, see [Get started with the XMTP Browser SDK](https://docs.xmtp.org/sdks/browser).\n\n## SDK reference\n\nComing soon\n\n## Limitations\n\nThis SDK uses the [origin private file system](https://developer.mozilla.org/en-US/docs/Web/API/File_System_API/Origin_private_file_system) (OPFS) to persist a SQLite database and the [SyncAccessHandle Pool VFS](https://sqlite.org/wasm/doc/trunk/persistence.md#vfs-opfs-sahpool) to access it. This VFS does not support multiple simultaneous connections.\n\nThis means that when using this SDK in your app, you must prevent multiple browser tabs or windows from accessing your app at the same time.\n\n### Bundlers\n\nThis SDK and some of its dependencies use `import.meta.url`. Some bundlers must be configured to account for this during development.\n\n#### Vite\n\nAdd the following to `vite.config.ts`:\n\n```typescript\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  optimizeDeps: {\n    exclude: [\"@xmtp/wasm-bindings\", \"@xmtp/browser-sdk\"],\n    include: [\"@xmtp/proto\"],\n  },\n});\n```\n\n## Install\n\n**NPM**\n\n```bash\nnpm install @xmtp/browser-sdk\n```\n\n**PNPM**\n\n```bash\npnpm install @xmtp/browser-sdk\n```\n\n**Yarn**\n\n```bash\nyarn add @xmtp/browser-sdk\n```\n\n## Developing\n\nRun `yarn dev` to build the SDK and watch for changes, which will trigger a rebuild.\n\n### Useful commands\n\n- `yarn build`: Builds the SDK\n- `yarn clean`: Removes `node_modules`, `dist`, and `.turbo` folders\n- `yarn dev`: Builds the SDK and watches for changes, which will trigger a rebuild\n- `yarn test`: Runs all tests\n- `yarn typecheck`: Runs `tsc`\n\n## Breaking revisions\n\nBecause this SDK is in active development, you should expect breaking revisions that might require you to adopt the latest SDK release to enable your app to continue working as expected.\n\nBreaking revisions in a Browser SDK release are described on the [Releases page](https://github.com/xmtp/xmtp-js/releases).\n\n## Deprecation\n\nOlder versions of the SDK will eventually be deprecated, which means:\n\n1. The network will not support and eventually actively reject connections from clients using deprecated versions.\n2. Bugs will not be fixed in deprecated versions.\n\nThe following table provides the deprecation schedule.\n\n| Announced                   | Effective   | Minimum Version | Rationale                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| --------------------------- | ----------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| No more support for XMTP V2 | May 1, 2025 | >=1.1.4         | In a move toward better security with MLS and the ability to decentralize, we will be shutting down XMTP V2 and moving entirely to XMTP V3. To learn more about V2 deprecation, see [XIP-53: XMTP V2 deprecation plan](https://community.xmtp.org/t/xip-53-xmtp-v2-deprecation-plan/867). To learn how to upgrade, see [@xmtp/browser-sdk v1.1.4](https://github.com/xmtp/xmtp-js/releases/tag/%40xmtp%2Fbrowser-sdk%401.1.4). |\n\nBug reports, feature requests, and PRs are welcome in accordance with these [contribution guidelines](https://github.com/xmtp/xmtp-js/blob/main/CONTRIBUTING.md).\n",
      "size_bytes": 4251
    },
    "apps/xmtp.chat/src/layouts/CenteredLayout.module.css": {
      "content": ".root {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  position: relative;\n  flex-grow: 1;\n}\n\n.root.fullScreen {\n  height: 100dvh;\n  width: 100dvw;\n}\n\n.content {\n  width: 70ch;\n  position: relative;\n  flex-grow: 1;\n}\n\n.fullScreen > .content {\n  width: 100dvw;\n}\n\n@media screen and (max-width: 1080px) {\n  .content {\n    width: auto;\n  }\n}\n",
      "size_bytes": 360
    },
    "apps/xmtp.chat/src/components/Conversation/MembersList.tsx": {
      "content": "import { ActionIcon, Badge, Group, Stack, Text, Tooltip } from \"@mantine/core\";\nimport { Dm } from \"@xmtp/browser-sdk\";\nimport { useMemo, type ComponentProps } from \"react\";\nimport { Virtuoso } from \"react-virtuoso\";\nimport { MemberListItem } from \"@/components/Conversation/MemberListItem\";\nimport { useConversation } from \"@/hooks/useConversation\";\nimport {\n  useMemberProfiles,\n  type MemberProfile,\n} from \"@/hooks/useMemberProfiles\";\nimport { IconX } from \"@/icons/IconX\";\nimport {\n  ContentLayoutContent,\n  ContentLayoutHeader,\n} from \"@/layouts/ContentLayout\";\nimport classes from \"./MembersList.module.css\";\n\nconst List = (props: ComponentProps<\"div\">) => {\n  return <div className={classes.root} {...props} />;\n};\n\nexport type MembersListProps = {\n  conversationId: string;\n  toggle: () => void;\n};\n\ntype MembersListTitle = {\n  title: string;\n  count: number;\n};\n\nconst isMembersListTitle = (\n  item: MembersListTitle | MemberProfile,\n): item is MembersListTitle => {\n  return \"title\" in item && \"count\" in item;\n};\n\ntype TitleCardProps = {\n  title: string;\n  count: number;\n};\n\nconst TitleCard: React.FC<TitleCardProps> = ({ title, count }) => {\n  return (\n    <Group\n      justify=\"space-between\"\n      gap=\"xs\"\n      align=\"center\"\n      wrap=\"nowrap\"\n      px=\"md\">\n      <Text size=\"xs\" fw={700}>\n        {title.toUpperCase()}\n      </Text>\n      <Badge color=\"gray\" size=\"sm\">\n        {count}\n      </Badge>\n    </Group>\n  );\n};\n\nexport const MembersList: React.FC<MembersListProps> = ({\n  conversationId,\n  toggle,\n}) => {\n  const { members, conversation } = useConversation(conversationId);\n  const memberProfiles = useMemberProfiles(Array.from(members.values()));\n  const membersListItems = useMemo(() => {\n    const items: (MembersListTitle | MemberProfile)[] = [];\n\n    const superAdmins = memberProfiles.filter(\n      // @ts-expect-error - the types are wrong\n      (profile) => profile.permissionLevel === \"SuperAdmin\",\n    );\n\n    if (superAdmins.length > 0) {\n      items.push({ title: \"Super admins\", count: superAdmins.length });\n      items.push(...superAdmins);\n    }\n\n    const admins = memberProfiles.filter(\n      // @ts-expect-error - the types are wrong\n      (profile) => profile.permissionLevel === \"Admin\",\n    );\n\n    if (admins.length > 0) {\n      items.push({ title: \"Admins\", count: admins.length });\n      items.push(...admins);\n    }\n\n    const regulars = memberProfiles.filter(\n      // @ts-expect-error - TODO: the types are wrong\n      (profile) => profile.permissionLevel === \"Member\",\n    );\n\n    if (regulars.length > 0) {\n      items.push({\n        title: \"Members\",\n        count: regulars.length,\n      });\n      items.push(...regulars);\n    }\n\n    return items;\n  }, [memberProfiles]);\n\n  return (\n    <Stack gap={0} style={{ flexGrow: 1 }}>\n      <ContentLayoutHeader\n        headerClassName={classes.header}\n        title={\n          <Group align=\"center\" gap=\"xs\">\n            <Text size=\"md\" fw={700}>\n              Members\n            </Text>\n            <Badge color=\"gray\" size=\"lg\">\n              {members.size}\n            </Badge>\n          </Group>\n        }\n        headerActions={\n          <Group align=\"center\" gap=\"xxxs\">\n            <Tooltip label={<Text size=\"xs\">Hide members</Text>}>\n              <ActionIcon\n                variant=\"default\"\n                onClick={toggle}\n                className={classes.hideMembers}>\n                <IconX />\n              </ActionIcon>\n            </Tooltip>\n          </Group>\n        }\n      />\n      <ContentLayoutContent\n        withScrollArea={false}\n        withScrollFade\n        className={classes.content}>\n        <Virtuoso\n          components={{\n            List,\n          }}\n          style={{ flexGrow: 1 }}\n          data={membersListItems}\n          itemContent={(_, item) => {\n            if (isMembersListTitle(item)) {\n              return <TitleCard title={item.title} count={item.count} />;\n            }\n            return (\n              <MemberListItem\n                address={item.address}\n                avatar={item.avatar}\n                conversationId={conversationId}\n                description={item.description}\n                displayName={item.displayName}\n                inboxId={item.inboxId}\n                permissionLevel={item.permissionLevel}\n                showDm={!(conversation instanceof Dm)}\n              />\n            );\n          }}\n        />\n      </ContentLayoutContent>\n    </Stack>\n  );\n};\n",
      "size_bytes": 4468
    },
    "content-types/content-type-remote-attachment/src/encryption/Ciphertext.ts": {
      "content": "import { ciphertext } from \"@xmtp/proto\";\n\nexport const AESKeySize = 32; // bytes\nexport const KDFSaltSize = 32; // bytes\n// AES-GCM defaults from https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams\nexport const AESGCMNonceSize = 12; // property iv\nexport const AESGCMTagLength = 16; // property tagLength\n\n// Ciphertext packages the encrypted ciphertext with the salt and nonce used to produce it.\n// salt and nonce are not secret, and should be transmitted/stored along with the encrypted ciphertext.\nexport default class Ciphertext implements ciphertext.Ciphertext {\n  aes256GcmHkdfSha256: ciphertext.Ciphertext_Aes256gcmHkdfsha256 | undefined;\n\n  constructor(obj: ciphertext.Ciphertext) {\n    if (!obj.aes256GcmHkdfSha256) {\n      throw new Error(\"invalid ciphertext\");\n    }\n    if (obj.aes256GcmHkdfSha256.payload.length < AESGCMTagLength) {\n      throw new Error(\n        `invalid ciphertext ciphertext length: ${obj.aes256GcmHkdfSha256.payload.length}`,\n      );\n    }\n    if (obj.aes256GcmHkdfSha256.hkdfSalt.length !== KDFSaltSize) {\n      throw new Error(\n        `invalid ciphertext salt length: ${obj.aes256GcmHkdfSha256.hkdfSalt.length}`,\n      );\n    }\n    if (obj.aes256GcmHkdfSha256.gcmNonce.length !== AESGCMNonceSize) {\n      throw new Error(\n        `invalid ciphertext nonce length: ${obj.aes256GcmHkdfSha256.gcmNonce.length}`,\n      );\n    }\n    this.aes256GcmHkdfSha256 = obj.aes256GcmHkdfSha256;\n  }\n\n  toBytes(): Uint8Array {\n    return ciphertext.Ciphertext.encode(this).finish();\n  }\n\n  static fromBytes(bytes: Uint8Array): Ciphertext {\n    return new Ciphertext(ciphertext.Ciphertext.decode(bytes));\n  }\n}\n",
      "size_bytes": 1644
    },
    "apps/xmtp.chat/src/components/Landing/MumbleLanding.tsx": {
      "content": "import { useEffect, useState, type FC } from \"react\";\nimport classes from \"./MumbleLanding.module.css\";\n\nconst Logo = \"/favicon.svg\";\n\nconst navLinks = [\n  { label: \"Home\", href: \"#home\" },\n  { label: \"Powered By\", href: \"#powered-by\" },\n  { label: \"Roadmap\", href: \"#roadmap\" },\n  { label: \"Tokenomics\", href: \"#tokenomics\" },\n  { label: \"FAQs\", href: \"#faqs\" },\n];\n\nconst featureCards = [\n  {\n    title: \"End-to-End Encryption\",\n    copy: \"Messages stay encrypted from your wallet to your recipient, secured by Ramestta-native keys.\",\n  },\n  {\n    title: \"Decentralized Storage\",\n    copy: \"All threads live on the Ramestta blockchain—immutable, censorship resistant, and verifiable.\",\n  },\n  {\n    title: \"Community Owned\",\n    copy: \"Wallets act as identity. No phone numbers, emails, or centralized gateways required.\",\n  },\n  {\n    title: \"Privacy First\",\n    copy: \"Metadata is minimized and routed over encrypted transports so conversations stay private.\",\n  },\n  {\n    title: \"Lightning Fast\",\n    copy: \"Optimized indexing and local caching deliver near-instant message sync without sacrificing security.\",\n  },\n  {\n    title: \"Global Access\",\n    copy: \"Wherever your wallet connects, your inbox follows. Ramestta availability keeps communities online.\",\n  },\n];\n\nconst channels = [\n  \"0xe9..2d9\",\n  \"jsreigns.rama\",\n  \"0x35..1c02\",\n  \"findus.rama\",\n  \"0x45..db6b\",\n  \"0xe74b..3d44\",\n];\n\nconst channelMessages = [\n  {\n    sender: \"them\",\n    content: \"Hey, are you ready for the Ramestta mainnet launch tonight?\",\n  },\n  {\n    sender: \"me\",\n    content:\n      \"Absolutely. Liquidity is locked, keys rotated, infra double-checked.\",\n  },\n  {\n    sender: \"them\",\n    content:\n      \"Perfect. MumbleChat notifications are pinned in the community channel.\",\n  },\n  {\n    sender: \"me\",\n    content: \"See you in the launch stream. XMTP client already synced.\",\n  },\n];\n\n// ...existing code...\n\nconst roadmapPhases = [\n  {\n    phase: \"Phase I\",\n    title: \"Core messaging launch\",\n    copy: \"Direct wallet-to-wallet chat, encrypted storage, and Ramestta mainnet availability.\",\n    status: \"Shipped\",\n  },\n  {\n    phase: \"Phase II\",\n    title: \"Community tooling\",\n    copy: \"Group channels, moderation controls, and programmable bots for DAO operations.\",\n    status: \"In progress\",\n  },\n  {\n    phase: \"Phase III\",\n    title: \"Ecosystem expansion\",\n    copy: \"Bridged inboxes, custom themes, and liquidity programs to grow the MumbleChat network.\",\n    status: \"Queued\",\n  },\n];\n\nconst allocations = [\n  {\n    label: \"Community rewards\",\n    percent: \"40%\",\n    copy: \"Distributed to active chat operators, moderators, and builders expanding the network.\",\n  },\n  {\n    label: \"Core contributors\",\n    percent: \"30%\",\n    copy: \"Vested allocation aligned with long-term protocol development and maintenance.\",\n  },\n  {\n    label: \"Liquidity & treasury\",\n    percent: \"20%\",\n    copy: \"Supports exchange liquidity, partnerships, and ongoing infrastructure costs.\",\n  },\n  {\n    label: \"Ecosystem grants\",\n    percent: \"10%\",\n    copy: \"Fund experimentation across wallets, clients, and integrations on Ramestta.\",\n  },\n];\n\nconst faqItems = [\n  {\n    question: \"Do I need a specific wallet to use MumbleChat?\",\n    answer:\n      \"Any wallet supported on Ramestta works. Connect, approve the session, and your encrypted inbox syncs immediately.\",\n  },\n  {\n    question: \"How is my data stored?\",\n    answer:\n      \"Messages are sealed with XMTP encryption and anchored to Ramestta storage. Only the intended participants can decrypt them.\",\n  },\n  {\n    question: \"Can communities customize the chat experience?\",\n    answer:\n      \"Yes. Roles, channel permissions, and bot automations are all configurable so DAOs can tailor their workspace.\",\n  },\n  {\n    question: \"Is there a cost to send messages?\",\n    answer:\n      \"Ramestta keeps fees minimal. MumbleChat batches writes where possible so everyday messaging stays affordable.\",\n  },\n];\n\nconst classNames = (...values: Array<string | false | undefined>) =>\n  values.filter(Boolean).join(\" \");\n\nexport const MumbleLanding: FC = () => {\n  const [scrolled, setScrolled] = useState(false);\n  const [menuOpen, setMenuOpen] = useState(false);\n\n  useEffect(() => {\n    const onScroll = () => {\n      setScrolled(window.scrollY > 16);\n    };\n    onScroll();\n    window.addEventListener(\"scroll\", onScroll);\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll);\n    };\n  }, []);\n\n  const navClass = classNames(\n    classes.navbar,\n    scrolled && classes.navbarScrolled,\n  );\n\n  return (\n    <div className={classes.page}>\n      <div className={classes.background} aria-hidden=\"true\" />\n      <header className={navClass}>\n        <div className={classes.navContainer}>\n          <a\n            className={classes.brand}\n            href=\"#home\"\n            onClick={() => {\n              setMenuOpen(false);\n            }}>\n            <img\n              src={Logo}\n              alt=\"MumbleChat Logo\"\n              className={classes.brandIcon}\n              style={{ height: 32, width: 32 }}\n            />\n            <span className={classes.brandLabel}>MumbleChat</span>\n          </a>\n          <nav className={classes.navLinks} aria-label=\"Primary\">\n            {navLinks.map(({ label, href }) => (\n              <a key={label} href={href} className={classes.navLink}>\n                {label}\n              </a>\n            ))}\n          </nav>\n          <div className={classes.navActions}>\n            <a\n              className={classes.primaryButton}\n              href=\"http://localhost:5173/welcome\">\n              Connect Wallet\n            </a>\n            <button\n              type=\"button\"\n              className={classes.menuButton}\n              aria-expanded={menuOpen}\n              aria-controls=\"mumble-mobile-nav\"\n              onClick={() => {\n                setMenuOpen((value) => !value);\n              }}>\n              <span />\n              <span />\n              <span />\n            </button>\n          </div>\n        </div>\n        {menuOpen && (\n          <nav\n            id=\"mumble-mobile-nav\"\n            className={classes.mobileNav}\n            aria-label=\"Mobile navigation\">\n            {navLinks.map(({ label, href }) => (\n              <a\n                key={label}\n                href={href}\n                className={classes.mobileNavLink}\n                onClick={() => {\n                  setMenuOpen(false);\n                }}>\n                {label}\n              </a>\n            ))}\n            <a\n              className={classes.mobilePrimaryButton}\n              href=\"http://localhost:5173/welcome\"\n              onClick={() => {\n                setMenuOpen(false);\n              }}>\n              Connect Wallet\n            </a>\n          </nav>\n        )}\n      </header>\n\n      <main className={classes.content}>\n        <section className={classes.hero} id=\"home\">\n          <div className={classes.heroBadge}>Ramestta Layer-3 Blockchain</div>\n          <h1 className={classes.heroTitle}>\n            Institutional-grade decentralized messaging, powered by Ramestta.\n          </h1>\n          <p className={classes.heroCopy}>\n            Ramestta is an Ethereum-aligned Layer-3 blockchain built on Polygon,\n            engineered for real-world adoption with sub-2 second finality,\n            65,000+ TPS, and deterministic micro-fees. Experience secure,\n            censorship-resistant messaging with EVM compatibility and\n            Ethereum-level trust.\n          </p>\n          <ul className={classes.heroList}>\n            <li>\n              True Layer-3 architecture: Built on Polygon, secured by Ethereum\n            </li>\n            <li>Sub-2 second programmable finality</li>\n            <li>Deterministic micro-fees ($0.0002-$0.001 per transaction)</li>\n            <li>100% EVM equivalence for seamless migration</li>\n            <li>Enterprise-grade throughput (65,000+ TPS)</li>\n            <li>Production-ready for payments, gaming, DeFi, and more</li>\n          </ul>\n          <div className={classes.heroActions}>\n            <a\n              className={classes.primaryButton}\n              href=\"http://localhost:5173/welcome\">\n              Connect Wallet\n            </a>\n            <a className={classes.secondaryButton} href=\"#powered-by\">\n              Learn More About Ramestta\n            </a>\n          </div>\n          <p className={classes.heroNote}>\n            Ramestta: The missing execution layer in Web3 infrastructure. Built\n            for privacy, security, and true ownership of your communication.\n          </p>\n        </section>\n\n        <section\n          className={classes.mockupSection}\n          aria-labelledby=\"mockup-heading\">\n          <h2 id=\"mockup-heading\" className={classes.sectionVisuallyHidden}>\n            Product preview\n          </h2>\n          <div className={classes.mockupContainer}>\n            <div className={classes.mockupTopBar}>\n              <div className={classes.windowControls}>\n                <span />\n                <span />\n                <span />\n              </div>\n              <div className={classes.addressBar}>mumblechat.com</div>\n            </div>\n            <div className={classes.mockupBody}>\n              <aside className={classes.channelColumn}>\n                <div className={classes.channelHeader}>\n                  <span>Chats</span>\n                  <span className={classes.channelMenu}>⋮</span>\n                </div>\n                <div className={classes.channelSearch}>Search channels...</div>\n                <ul className={classes.channelList}>\n                  {channels.map((channel, index) => (\n                    <li\n                      key={channel}\n                      className={classNames(\n                        classes.channelItem,\n                        index === 0 && classes.channelItemActive,\n                      )}>\n                      <span className={classes.channelAvatar}>\n                        {channel.slice(0, 2)}\n                      </span>\n                      <span className={classes.channelLabel}>{channel}</span>\n                    </li>\n                  ))}\n                </ul>\n              </aside>\n              <div className={classes.threadColumn}>\n                <header className={classes.threadHeader}>\n                  <div>\n                    <div className={classes.threadTitle}>0xe9..2d9</div>\n                    <div className={classes.threadStatus}>Online</div>\n                  </div>\n                  <div className={classes.threadActions}>\n                    <span />\n                    <span />\n                  </div>\n                </header>\n                <div className={classes.threadMessages}>\n                  {channelMessages.map(({ sender, content }) => (\n                    <div\n                      key={content}\n                      className={classNames(\n                        classes.messageRow,\n                        sender === \"me\" && classes.messageRowOwn,\n                      )}>\n                      <div className={classes.messageBubble}>{content}</div>\n                    </div>\n                  ))}\n                </div>\n                <div className={classes.threadComposer}>\n                  Encrypted message composer\n                </div>\n              </div>\n            </div>\n          </div>\n        </section>\n\n        <section className={classes.powered} id=\"powered-by\">\n          <div className={classes.sectionHeading}>\n            <span className={classes.sectionEyebrow}>Why Ramestta?</span>\n            <h2>Institutional-Grade Layer-3 Infrastructure</h2>\n            <p>\n              Ramestta completes the Ethereum scalability stack—not as a\n              competitor, but as the final adoption-ready Layer-3. Every\n              conversation is anchored directly on the Ramestta blockchain: no\n              centralized databases, no middlemen, no ads—just encrypted\n              messages that you own.\n            </p>\n            <ul className={classes.poweredList}>\n              <li>\n                <strong>True Layer-3 Architecture:</strong> Built on Polygon\n                (L2), secured by Ethereum (L1) for mass adoption.\n              </li>\n              <li>\n                <strong>Sub-2 Second Finality:</strong> Programmable finality\n                with instant (~2s), hard (~7-10min), and ultimate security.\n              </li>\n              <li>\n                <strong>Deterministic Micro-Fees:</strong> Predictable\n                transaction costs between $0.0002-$0.001—1000× cheaper than\n                L1/L2 chains.\n              </li>\n              <li>\n                <strong>Ethereum Security Inheritance:</strong> Inherits trust\n                from Ethereum via Polygon checkpoints—economic and cryptographic\n                guarantees.\n              </li>\n              <li>\n                <strong>100% EVM Equivalence:</strong> Fully equivalent, migrate\n                from Polygon/Ethereum with zero code changes.\n              </li>\n              <li>\n                <strong>65,000+ TPS Capacity:</strong> Enterprise-grade\n                throughput with horizontal scaling via multi-instance\n                architecture.\n              </li>\n            </ul>\n            <p>\n              <a\n                href=\"https://www.ramestta.com/\"\n                target=\"_blank\"\n                rel=\"noopener noreferrer\">\n                Learn more at ramestta.com\n              </a>\n            </p>\n          </div>\n        </section>\n\n        <section className={classes.features} id=\"features\">\n          <div className={classes.sectionHeading}>\n            <span className={classes.sectionEyebrow}>Why MumbleChat</span>\n            <h2>Everything you need to own your conversations.</h2>\n            <p>\n              Privacy-first tooling, resilient infrastructure, and UI built for\n              communities who live onchain.\n            </p>\n          </div>\n          <div className={classes.featureGrid}>\n            {featureCards.map((feature) => (\n              <article key={feature.title} className={classes.featureCard}>\n                <h3>{feature.title}</h3>\n                <p>{feature.copy}</p>\n              </article>\n            ))}\n          </div>\n        </section>\n\n        <section className={classes.roadmap} id=\"roadmap\">\n          <div className={classes.sectionHeading}>\n            <span className={classes.sectionEyebrow}>Roadmap</span>\n            <h2>Ship fast, stay decentralized.</h2>\n            <p>\n              The path to a global, wallet-native messaging layer on Ramestta.\n            </p>\n          </div>\n          <div className={classes.roadmapTimeline}>\n            {roadmapPhases.map((phase) => (\n              <article key={phase.title} className={classes.roadmapItem}>\n                <span className={classes.roadmapBadge}>{phase.phase}</span>\n                <h3>{phase.title}</h3>\n                <p>{phase.copy}</p>\n                <span className={classes.roadmapStatus}>{phase.status}</span>\n              </article>\n            ))}\n          </div>\n        </section>\n\n        <section className={classes.tokenomics} id=\"tokenomics\">\n          <div className={classes.sectionHeading}>\n            <span className={classes.sectionEyebrow}>Tokenomics</span>\n            <h2>Transparent allocation for network growth.</h2>\n            <p>\n              The MumbleChat token aligns early adopters, builders, and\n              liquidity providers powering the Ramestta messaging layer.\n            </p>\n          </div>\n          <div className={classes.tokenomicGrid}>\n            {allocations.map((allocation) => (\n              <article key={allocation.label} className={classes.tokenomicCard}>\n                <span className={classes.tokenomicPercent}>\n                  {allocation.percent}\n                </span>\n                <h3>{allocation.label}</h3>\n                <p>{allocation.copy}</p>\n              </article>\n            ))}\n          </div>\n        </section>\n\n        <section className={classes.faqs} id=\"faqs\">\n          <div className={classes.sectionHeading}>\n            <span className={classes.sectionEyebrow}>FAQs</span>\n            <h2>Answers before you connect.</h2>\n          </div>\n          <div className={classes.faqList}>\n            {faqItems.map((faq) => (\n              <article key={faq.question} className={classes.faqItem}>\n                <h3>{faq.question}</h3>\n                <p>{faq.answer}</p>\n              </article>\n            ))}\n          </div>\n        </section>\n\n        <section className={classes.cta}>\n          <h2>Ready to take control of your conversations?</h2>\n          <p>\n            Connect your wallet to start sending encrypted messages on Ramestta.\n            No emails. No phone numbers. Just you and your community.\n          </p>\n          <div className={classes.ctaActions}>\n            <a\n              className={classes.primaryButton}\n              href=\"http://localhost:5173/welcome\">\n              Connect Wallet\n            </a>\n            <a className={classes.secondaryButton} href=\"#powered-by\">\n              Learn more\n            </a>\n          </div>\n        </section>\n\n        <section className={classes.ramesttaInfo} id=\"ramestta-info\">\n          <div className={classes.sectionHeading}>\n            <span className={classes.sectionEyebrow}>\n              Ramestta Layer-3 Blockchain\n            </span>\n            <h2>What is Ramestta?</h2>\n            <p>\n              Ramestta is an institutional-grade Layer-3 blockchain built on\n              Polygon (L2) and aligned with Ethereum (L1). It’s engineered for\n              real-world adoption, delivering sub-2 second finality,\n              deterministic micro-fees, and enterprise-grade scalability—without\n              compromising security, trust, or developer compatibility.\n            </p>\n          </div>\n          <div className={classes.ramesttaGrid}>\n            <div className={classes.ramesttaCard}>\n              <div className={classes.ramesttaCardTitle}>\n                Layered Architecture\n              </div>\n              <div className={classes.ramesttaCardDesc}>\n                <strong>L1: Ethereum</strong> — Settlement & Security\n                <br />\n                <strong>L2: Polygon</strong> — Scalable Execution\n                <br />\n                <strong>L3: Ramestta</strong> — Performance & Adoption\n              </div>\n            </div>\n            <div className={classes.ramesttaCard}>\n              <div className={classes.ramesttaCardTitle}>\n                Network Parameters\n              </div>\n              <div className={classes.ramesttaCardDesc}>\n                <strong>Type:</strong> Layer-3 (L3)\n                <br />\n                <strong>Chain ID:</strong> 1370\n                <br />\n                <strong>Block Time:</strong> ~2 seconds\n                <br />\n                <strong>Throughput:</strong> 65,000+ TPS\n                <br />\n                <strong>Gas Fee:</strong> $0.0002 - $0.001\n                <br />\n                <strong>Security:</strong> Ethereum-aligned PoS\n              </div>\n            </div>\n            <div className={classes.ramesttaCard}>\n              <div className={classes.ramesttaCardTitle}>\n                Endpoints & Explorer\n              </div>\n              <div className={classes.ramesttaCardDesc}>\n                <strong>RPC:</strong> blockchain.ramestta.com\n                <br />\n                <strong>RPC2:</strong> blockchain2.ramestta.com\n                <br />\n                <strong>Explorer:</strong> ramascan.com\n                <br />\n                <strong>Bridge:</strong> ramabridge.com\n                <br />\n                <strong>Swap DApp:</strong> ramaswap.com\n              </div>\n            </div>\n            <div className={classes.ramesttaCard}>\n              <div className={classes.ramesttaCardTitle}>Ready to Build?</div>\n              <div className={classes.ramesttaCardDesc}>\n                Ramestta powers payments, gaming, DeFi, and national digital\n                infrastructure—today.\n                <br />\n                Zero code changes, zero migration friction, Ethereum-level\n                security, and Web2-level performance.\n                <br />\n                <a\n                  href=\"https://www.ramestta.com/\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\">\n                  Learn more at ramestta.com\n                </a>\n              </div>\n            </div>\n          </div>\n        </section>\n      </main>\n\n      <footer className={classes.footer}>\n        <div className={classes.footerBrand}>\n          <img\n            src={Logo}\n            alt=\"MumbleChat Logo\"\n            className={classes.brandIcon}\n            style={{ height: 32, width: 32 }}\n          />\n          <div>\n            <p className={classes.brandLabel}>MumbleChat</p>\n            <p className={classes.footerCopy}>\n              Secure, decentralized messaging powered by the Ramestta\n              blockchain.\n            </p>\n          </div>\n        </div>\n        <div className={classes.footerLinks}>\n          <div>\n            <h3>Product</h3>\n            <a href=\"#features\">Features</a>\n            <a href=\"#roadmap\">Roadmap</a>\n            <a href=\"#tokenomics\">Tokenomics</a>\n          </div>\n          <div>\n            <h3>Resources</h3>\n            <a href=\"https://docs.xmtp.org/\" target=\"_blank\" rel=\"noreferrer\">\n              Documentation\n            </a>\n            <a\n              href=\"https://community.xmtp.org/\"\n              target=\"_blank\"\n              rel=\"noreferrer\">\n              Community\n            </a>\n            <a href=\"#faqs\">FAQs</a>\n          </div>\n        </div>\n        <div className={classes.footerMeta}>\n          <span>\n            © {new Date().getFullYear()} MumbleChat. Built on Ramestta.\n          </span>\n          <div>\n            <a href=\"#powered-by\">Terms</a>\n            <a href=\"#powered-by\">Privacy</a>\n            <a href=\"#powered-by\">Cookies</a>\n          </div>\n        </div>\n      </footer>\n    </div>\n  );\n};\n",
      "size_bytes": 22247
    },
    "sdks/browser-sdk/src/Preferences.ts": {
      "content": "import type { ConsentEntityType, UserPreference } from \"@xmtp/wasm-bindings\";\nimport { v4 } from \"uuid\";\nimport type { SafeConsent } from \"@/utils/conversions\";\nimport {\n  createStream,\n  type StreamCallback,\n  type StreamOptions,\n} from \"@/utils/streams\";\nimport type { Client } from \"./Client\";\n\n/**\n * Manages user preferences and consent states\n *\n * This class is not intended to be initialized directly.\n */\nexport class Preferences<ContentTypes = unknown> {\n  #client: Client<ContentTypes>;\n\n  /**\n   * Creates a new preferences instance\n   *\n   * @param client - The client instance managing preferences\n   */\n  constructor(client: Client<ContentTypes>) {\n    this.#client = client;\n  }\n\n  sync() {\n    return this.#client.sendMessage(\"preferences.sync\", undefined);\n  }\n\n  /**\n   * Retrieves the current inbox state\n   *\n   * @param refreshFromNetwork - Optional flag to force refresh from network\n   * @returns Promise that resolves with the inbox state\n   */\n  async inboxState(refreshFromNetwork?: boolean) {\n    return this.#client.sendMessage(\"preferences.inboxState\", {\n      refreshFromNetwork: refreshFromNetwork ?? false,\n    });\n  }\n\n  /**\n   * Retrieves inbox state for specific inbox IDs\n   *\n   * @param inboxIds - Array of inbox IDs to get state for\n   * @param refreshFromNetwork - Optional flag to force refresh from network\n   * @returns Promise that resolves with the inbox state for the inbox IDs\n   */\n  async inboxStateFromInboxIds(\n    inboxIds: string[],\n    refreshFromNetwork?: boolean,\n  ) {\n    return this.#client.sendMessage(\"preferences.inboxStateFromInboxIds\", {\n      inboxIds,\n      refreshFromNetwork: refreshFromNetwork ?? false,\n    });\n  }\n\n  /**\n   * Gets the latest inbox state for a specific inbox\n   *\n   * @param inboxId - The inbox ID to get state for\n   * @returns Promise that resolves with the latest inbox state\n   */\n  async getLatestInboxState(inboxId: string) {\n    return this.#client.sendMessage(\"preferences.getLatestInboxState\", {\n      inboxId,\n    });\n  }\n\n  /**\n   * Updates consent states for multiple records\n   *\n   * @param records - Array of consent records to update\n   * @returns Promise that resolves when consent states are updated\n   */\n  async setConsentStates(records: SafeConsent[]) {\n    return this.#client.sendMessage(\"preferences.setConsentStates\", {\n      records,\n    });\n  }\n\n  /**\n   * Retrieves consent state for a specific entity\n   *\n   * @param entityType - Type of entity to get consent for\n   * @param entity - Entity identifier\n   * @returns Promise that resolves with the consent state\n   */\n  async getConsentState(entityType: ConsentEntityType, entity: string) {\n    return this.#client.sendMessage(\"preferences.getConsentState\", {\n      entityType,\n      entity,\n    });\n  }\n\n  /**\n   * Creates a stream of consent state updates\n   *\n   * @param options - Optional stream options\n   * @returns Stream instance for consent updates\n   */\n  async streamConsent(options?: StreamOptions<SafeConsent[]>) {\n    const stream = async (\n      callback: StreamCallback<SafeConsent[]>,\n      onFail: () => void,\n    ) => {\n      const streamId = v4();\n      // sync the conversation\n      await this.sync();\n      // start the stream\n      await this.#client.sendMessage(\"preferences.streamConsent\", {\n        streamId,\n      });\n      // handle stream messages\n      return this.#client.handleStreamMessage<SafeConsent[]>(\n        streamId,\n        callback,\n        {\n          ...options,\n          onFail,\n        },\n      );\n    };\n\n    return createStream(stream, undefined, options);\n  }\n\n  /**\n   * Creates a stream of user preference updates\n   *\n   * @param options - Optional stream options\n   * @returns Stream instance for preference updates\n   */\n  async streamPreferences(options?: StreamOptions<UserPreference[]>) {\n    const stream = async (\n      callback: StreamCallback<UserPreference[]>,\n      onFail: () => void,\n    ) => {\n      const streamId = v4();\n      // sync the conversation\n      await this.sync();\n      // start the stream\n      await this.#client.sendMessage(\"preferences.streamPreferences\", {\n        streamId,\n      });\n      // handle stream messages\n      return this.#client.handleStreamMessage<UserPreference[]>(\n        streamId,\n        callback,\n        {\n          ...options,\n          onFail,\n        },\n      );\n    };\n\n    return createStream(stream, undefined, options);\n  }\n}\n",
      "size_bytes": 4413
    },
    "apps/xmtp.chat/src/components/App/App.tsx": {
      "content": "import { Navigate, Route, Routes } from \"react-router\";\nimport { BasicLayout } from \"@/components/App/BasicLayout\";\nimport { Disconnect } from \"@/components/App/Disconnect\";\nimport { ErrorModal } from \"@/components/App/ErrorModal\";\nimport { SelectConversation } from \"@/components/App/SelectConversation\";\nimport { Welcome } from \"@/components/App/Welcome\";\nimport { LoadConversation } from \"@/components/Conversation/LoadConversation\";\nimport { LoadDM } from \"@/components/Conversation/LoadDM\";\nimport { ManageConsentModal } from \"@/components/Conversation/ManageConsentModal\";\nimport { ManageMembersModal } from \"@/components/Conversation/ManageMembersModal\";\nimport { ManageMetadataModal } from \"@/components/Conversation/ManageMetadataModal\";\nimport { ManagePermissionsModal } from \"@/components/Conversation/ManagePermissionsModal\";\nimport { CreateDmModal } from \"@/components/Conversations/CreateDmModal\";\nimport { CreateGroupModal } from \"@/components/Conversations/CreateGroupModal\";\nimport { IdentityModal } from \"@/components/Identity/IdentityModal\";\nimport { InboxTools } from \"@/components/InboxTools/InboxTools\";\nimport { InboxToolsLayout } from \"@/components/InboxTools/InboxToolsLayout\";\nimport { MessageModal } from \"@/components/Messages/MessageModal\";\nimport { MumbleLanding } from \"@/components/Landing/MumbleLanding\";\nimport { useAnalytics } from \"@/hooks/useAnalytics\";\nimport { AppLayout } from \"@/components/App/AppLayout\";\n\nexport const App: React.FC = () => {\n  useAnalytics();\n\n  return (\n    <>\n      <ErrorModal />\n      <Routes>\n        <Route path=\"/\" element={<MumbleLanding />} />\n        <Route path=\"/welcome/*\" element={<BasicLayout />}>\n          <Route index element={<Welcome />} />\n        </Route>\n        <Route path=\"/inbox-tools/*\" element={<InboxToolsLayout />}>\n          <Route index element={<InboxTools />} />\n        </Route>\n        <Route element={<AppLayout />}>\n          <Route path=\"/dm/:address\" element={<LoadDM />} />\n          <Route path=\"/conversations\">\n            <Route index element={<SelectConversation />} />\n            <Route path=\"new-dm\" element={<CreateDmModal />} />\n            <Route path=\"new-group\" element={<CreateGroupModal />} />\n            <Route path=\"identity\" element={<IdentityModal />} />\n            <Route path=\":conversationId\" element={<LoadConversation />}>\n              <Route path=\"new-dm\" element={<CreateDmModal />} />\n              <Route path=\"new-group\" element={<CreateGroupModal />} />\n              <Route path=\"identity\" element={<IdentityModal />} />\n              <Route path=\"message/:messageId\" element={<MessageModal />} />\n              <Route path=\"manage\">\n                <Route path=\"consent\" element={<ManageConsentModal />} />\n                <Route path=\"members\" element={<ManageMembersModal />} />\n                <Route\n                  path=\"permissions\"\n                  element={<ManagePermissionsModal />}\n                />\n                <Route path=\"metadata\" element={<ManageMetadataModal />} />\n              </Route>\n            </Route>\n          </Route>\n          <Route path=\"/disconnect\" element={<Disconnect />} />\n        </Route>\n        <Route path=\"*\" element={<Navigate to=\"/\" replace />} />\n      </Routes>\n    </>\n  );\n};\n",
      "size_bytes": 3269
    },
    "sdks/node-sdk/src/Group.ts": {
      "content": "import type {\n  Identifier,\n  MetadataField,\n  PermissionPolicy,\n  PermissionUpdateType,\n  Conversation as XmtpConversation,\n} from \"@xmtp/node-bindings\";\nimport type { Client } from \"@/Client\";\nimport { Conversation } from \"@/Conversation\";\n\n/**\n * Represents a group conversation between multiple inboxes\n *\n * This class is not intended to be initialized directly.\n */\nexport class Group<ContentTypes = unknown> extends Conversation<ContentTypes> {\n  #conversation: XmtpConversation;\n\n  /**\n   * Creates a new group conversation instance\n   *\n   * @param client - The client instance managing this group conversation\n   * @param conversation - The underlying conversation object\n   * @param isCommitLogForked\n   */\n  constructor(\n    client: Client<ContentTypes>,\n    conversation: XmtpConversation,\n    isCommitLogForked?: boolean | null,\n  ) {\n    super(client, conversation, isCommitLogForked);\n    this.#conversation = conversation;\n  }\n\n  /**\n   * The name of the group\n   */\n  get name() {\n    return this.#conversation.groupName();\n  }\n\n  /**\n   * Updates the group's name\n   *\n   * @param name The new name for the group\n   */\n  async updateName(name: string) {\n    return this.#conversation.updateGroupName(name);\n  }\n\n  /**\n   * The image URL of the group\n   */\n  get imageUrl() {\n    return this.#conversation.groupImageUrlSquare();\n  }\n\n  /**\n   * Updates the group's image URL\n   *\n   * @param imageUrl The new image URL for the group\n   */\n  async updateImageUrl(imageUrl: string) {\n    return this.#conversation.updateGroupImageUrlSquare(imageUrl);\n  }\n\n  /**\n   * The description of the group\n   */\n  get description() {\n    return this.#conversation.groupDescription();\n  }\n\n  /**\n   * Updates the group's description\n   *\n   * @param description The new description for the group\n   */\n  async updateDescription(description: string) {\n    return this.#conversation.updateGroupDescription(description);\n  }\n\n  /**\n   * The permissions of the group\n   */\n  get permissions() {\n    const permissions = this.#conversation.groupPermissions();\n    return {\n      policyType: permissions.policyType(),\n      policySet: permissions.policySet(),\n    };\n  }\n\n  /**\n   * Updates a specific permission policy for the group\n   *\n   * @param permissionType The type of permission to update\n   * @param policy The new permission policy\n   * @param metadataField Optional metadata field for the permission\n   */\n  async updatePermission(\n    permissionType: PermissionUpdateType,\n    policy: PermissionPolicy,\n    metadataField?: MetadataField,\n  ) {\n    return this.#conversation.updatePermissionPolicy(\n      permissionType,\n      policy,\n      metadataField,\n    );\n  }\n\n  /**\n   * The list of admins of the group\n   */\n  get admins() {\n    return this.#conversation.adminList();\n  }\n\n  /**\n   * The list of super admins of the group\n   */\n  get superAdmins() {\n    return this.#conversation.superAdminList();\n  }\n\n  /**\n   * Checks if an inbox is an admin of the group\n   *\n   * @param inboxId The inbox ID to check\n   * @returns Boolean indicating if the inbox is an admin\n   */\n  isAdmin(inboxId: string) {\n    return this.#conversation.isAdmin(inboxId);\n  }\n\n  /**\n   * Checks if an inbox is a super admin of the group\n   *\n   * @param inboxId The inbox ID to check\n   * @returns Boolean indicating if the inbox is a super admin\n   */\n  isSuperAdmin(inboxId: string) {\n    return this.#conversation.isSuperAdmin(inboxId);\n  }\n\n  /**\n   * Adds members to the group using identifiers\n   *\n   * @param identifiers Array of member identifiers to add\n   */\n  async addMembersByIdentifiers(identifiers: Identifier[]) {\n    return this.#conversation.addMembers(identifiers);\n  }\n\n  /**\n   * Adds members to the group using inbox IDs\n   *\n   * @param inboxIds Array of inbox IDs to add\n   */\n  async addMembers(inboxIds: string[]) {\n    return this.#conversation.addMembersByInboxId(inboxIds);\n  }\n\n  /**\n   * Removes members from the group using identifiers\n   *\n   * @param identifiers Array of member identifiers to remove\n   */\n  async removeMembersByIdentifiers(identifiers: Identifier[]) {\n    return this.#conversation.removeMembers(identifiers);\n  }\n\n  /**\n   * Removes members from the group using inbox IDs\n   *\n   * @param inboxIds Array of inbox IDs to remove\n   */\n  async removeMembers(inboxIds: string[]) {\n    return this.#conversation.removeMembersByInboxId(inboxIds);\n  }\n\n  /**\n   * Promotes a group member to admin status\n   *\n   * @param inboxId The inbox ID of the member to promote\n   */\n  async addAdmin(inboxId: string) {\n    return this.#conversation.addAdmin(inboxId);\n  }\n\n  /**\n   * Removes admin status from a group member\n   *\n   * @param inboxId The inbox ID of the admin to demote\n   */\n  async removeAdmin(inboxId: string) {\n    return this.#conversation.removeAdmin(inboxId);\n  }\n\n  /**\n   * Promotes a group member to super admin status\n   *\n   * @param inboxId The inbox ID of the member to promote\n   */\n  async addSuperAdmin(inboxId: string) {\n    return this.#conversation.addSuperAdmin(inboxId);\n  }\n\n  /**\n   * Removes super admin status from a group member\n   *\n   * @param inboxId The inbox ID of the super admin to demote\n   */\n  async removeSuperAdmin(inboxId: string) {\n    return this.#conversation.removeSuperAdmin(inboxId);\n  }\n}\n",
      "size_bytes": 5284
    },
    "apps/xmtp.chat/src/icons/WalletConnectWallet.tsx": {
      "content": "export const WalletConnectWallet = () => {\n  return (\n    <svg\n      width=\"28\"\n      height=\"28\"\n      viewBox=\"0 0 28 28\"\n      fill=\"none\"\n      xmlns=\"http://www.w3.org/2000/svg\">\n      <rect width=\"28\" height=\"28\" fill=\"#3B99FC\" />\n      <path\n        d=\"M8.38969 10.3739C11.4882 7.27538 16.5118 7.27538 19.6103 10.3739L19.9832 10.7468C20.1382 10.9017 20.1382 11.1529 19.9832 11.3078L18.7076 12.5835C18.6301 12.6609 18.5045 12.6609 18.4271 12.5835L17.9139 12.0703C15.7523 9.9087 12.2477 9.9087 10.0861 12.0703L9.53655 12.6198C9.45909 12.6973 9.3335 12.6973 9.25604 12.6198L7.98039 11.3442C7.82547 11.1893 7.82547 10.9381 7.98039 10.7832L8.38969 10.3739ZM22.2485 13.012L23.3838 14.1474C23.5387 14.3023 23.5387 14.5535 23.3838 14.7084L18.2645 19.8277C18.1096 19.9827 17.8584 19.9827 17.7035 19.8277C17.7035 19.8277 17.7035 19.8277 17.7035 19.8277L14.0702 16.1944C14.0314 16.1557 13.9686 16.1557 13.9299 16.1944C13.9299 16.1944 13.9299 16.1944 13.9299 16.1944L10.2966 19.8277C10.1417 19.9827 9.89053 19.9827 9.73561 19.8278C9.7356 19.8278 9.7356 19.8277 9.7356 19.8277L4.61619 14.7083C4.46127 14.5534 4.46127 14.3022 4.61619 14.1473L5.75152 13.012C5.90645 12.857 6.15763 12.857 6.31255 13.012L9.94595 16.6454C9.98468 16.6841 10.0475 16.6841 10.0862 16.6454C10.0862 16.6454 10.0862 16.6454 10.0862 16.6454L13.7194 13.012C13.8743 12.857 14.1255 12.857 14.2805 13.012C14.2805 13.012 14.2805 13.012 14.2805 13.012L17.9139 16.6454C17.9526 16.6841 18.0154 16.6841 18.0541 16.6454L21.6874 13.012C21.8424 12.8571 22.0936 12.8571 22.2485 13.012Z\"\n        fill=\"white\"\n      />\n    </svg>\n  );\n};\n",
      "size_bytes": 1589
    },
    "content-types/content-type-reply/vitest.config.ts": {
      "content": "import { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    globalSetup: [\"./vitest.setup.ts\"],\n  },\n});\n",
      "size_bytes": 155
    },
    "apps/xmtp.chat/src/layouts/MainLayout.module.css": {
      "content": "/* =============================\n   Global Layout Variables\n============================= */\n:root {\n  --layout-padding: clamp(1px, 1vw, 1px);\n  --main-width: 100%;\n  --nav-width: 350px;\n  --header-padding: 1.2rem;\n  --header-button-height: 36px;\n  --main-border-width: 1px;\n  --main-border-color: rgba(10, 255, 241, 0.18);\n\n  /* Derived */\n  --nav-dynamic-width: max(\n    calc((100dvw - var(--main-width)) / 2),\n    var(--nav-width)\n  );\n  --header-height: calc(\n    var(--header-padding) * 2 + var(--header-button-height) +\n      var(--main-border-width)\n  );\n}\n\n/* =============================\n   Root Layout Container\n============================= */\n.root {\n  display: flex;\n  flex-direction: column;\n  min-height: 100dvh;\n  padding: var(--layout-padding);\n  box-sizing: border-box;\n  color: #ffffff;\n  background:\n    radial-gradient(\n      circle at top left,\n      rgba(10, 255, 241, 0.2),\n      transparent 55%\n    ),\n    radial-gradient(\n      circle at bottom right,\n      rgba(151, 114, 251, 0.2),\n      transparent 60%\n    ),\n    #04060f;\n}\n\n/* =============================\n   Header\n============================= */\n.header {\n  height: var(--header-height);\n  padding: var(--header-padding) 0;\n  max-width: var(--main-width);\n  margin-left: var(--nav-dynamic-width);\n  flex-shrink: 0;\n  position: relative;\n  z-index: 1;\n  border: 1px solid var(--main-border-color);\n  border-radius: 10px;\n  background: rgba(10, 13, 25, 0.9);\n  /* box-shadow: 0 28px 52px rgba(5, 10, 24, 0.45); */\n  backdrop-filter: blur(0px);\n}\n\n.headerContent {\n  padding: 0 var(--header-padding);\n}\n\n/* =============================\n   Main Content Area\n============================= */\n.main {\n  position: relative;\n  z-index: 1;\n  max-width: var(--main-width);\n  margin-left: var(--nav-dynamic-width);\n  flex-grow: 1;\n  display: flex;\n  flex-direction: column;\n  border: 1px solid rgba(10, 255, 241, 0.12);\n  border-radius: 10px;\n  background:\n    linear-gradient(160deg, rgba(6, 9, 20, 0.9), rgba(6, 9, 20, 0.76)),\n    radial-gradient(\n      circle at top right,\n      rgba(10, 255, 241, 0.08),\n      transparent 45%\n    ),\n    radial-gradient(\n      circle at bottom left,\n      rgba(151, 114, 251, 0.1),\n      transparent 60%\n    );\n  box-shadow: 0 36px 60px rgba(4, 8, 20, 0.5);\n  overflow: hidden;\n  backdrop-filter: blur(10px);\n}\n\n.mainContent {\n  flex-grow: 1;\n  display: flex;\n  flex-direction: column;\n}\n\n/* =============================\n   Sidebar (Aside)\n============================= */\n.aside {\n  position: fixed;\n  top: var(--header-height);\n  bottom: 0;\n  left: 0;\n  width: var(--nav-dynamic-width);\n  z-index: 100;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n  border-right: 1px solid rgba(10, 255, 241, 0.12);\n  border-radius: 20px;\n  box-shadow: 0 24px 50px rgba(4, 8, 20, 0.45);\n  background:\n    linear-gradient(165deg, rgba(6, 9, 20, 0.95), rgba(6, 9, 20, 0.82)),\n    radial-gradient(circle at top, rgba(10, 255, 241, 0.18), transparent 75%);\n  backdrop-filter: blur(10px);\n  transition:\n    transform 0.3s ease-out,\n    box-shadow 0.2s ease-out;\n}\n\n.asideNav {\n  width: var(--nav-width);\n  flex-grow: 1;\n  display: flex;\n  flex-direction: column;\n  padding: 1rem;\n  box-sizing: border-box;\n}\n\n.showNavbar {\n  transform: translateX(0) !important;\n}\n\n/* =============================\n   Footer\n============================= */\n.footer {\n  flex-shrink: 0;\n  max-width: var(--main-width);\n  margin-left: var(--nav-dynamic-width);\n  z-index: 1;\n  background: transparent;\n  padding: 1rem 0;\n}\n\n.footerContent {\n  padding: 0 1rem;\n}\n\n/* =============================\n   Overlay (Mobile)\n============================= */\n.overlay {\n  position: fixed;\n  inset: 0;\n  background: rgba(4, 8, 20, 0.55);\n  backdrop-filter: blur(2px);\n  opacity: 0;\n  pointer-events: none;\n  transition: opacity 0.2s ease-out;\n  z-index: 90;\n}\n\n.overlayVisible {\n  opacity: 1;\n  pointer-events: all;\n}\n\n/* =============================\n   Responsive Breakpoints\n============================= */\n\n/* --- Large Tablets & Small Desktops --- */\n@media screen and (max-width: 1080px) {\n  .aside {\n    transform: translateX(-100%);\n    border-radius: 0 18px 18px 0;\n  }\n\n  .header,\n  .main,\n  .footer {\n    margin-left: 0;\n    max-width: none;\n    border-radius: 10px;\n  }\n\n  .asideNav {\n    width: 100%;\n  }\n}\n\n/* --- Tablets --- */\n@media screen and (max-width: 768px) {\n  :root {\n    --layout-padding: clamp(10px, 3vw, 24px);\n    --nav-width: min(300px, 85vw);\n    --header-padding: 0.9rem;\n  }\n\n  .root {\n    padding: var(--layout-padding);\n  }\n\n  .header,\n  .main {\n    border-radius: 20px;\n  }\n\n  .aside {\n    top: 0;\n    bottom: 0;\n    width: min(85vw, 320px);\n    transform: translateX(-105%);\n    box-shadow: 0 18px 42px rgba(4, 8, 20, 0.45);\n  }\n\n  .showNavbar {\n    transform: translateX(0);\n  }\n\n  .footer {\n    padding: 0.8rem 0;\n  }\n}\n\n/* --- Large Phones --- */\n@media screen and (max-width: 640px) {\n  :root {\n    --layout-padding: clamp(8px, 3vw, 18px);\n  }\n\n  .header {\n    --header-button-height: 32px;\n    border-radius: 18px;\n  }\n\n  .main {\n    border-radius: 18px;\n  }\n\n  .aside {\n    width: 100%;\n    transform: translateX(-110%);\n    height: 100dvh;\n    border-radius: 0;\n  }\n\n  .footer {\n    padding: 0.6rem 0;\n  }\n}\n\n/* --- Small Phones --- */\n@media screen and (max-width: 480px) {\n  :root {\n    --layout-padding: clamp(6px, 2.5vw, 12px);\n  }\n\n  .header {\n    border-radius: 14px;\n    padding: 0.4rem 0;\n  }\n\n  .main {\n    border-radius: 14px;\n  }\n\n  .footer {\n    padding: 0.4rem 0;\n  }\n}\n\n/* --- Extra Small Devices (≤360px) --- */\n@media screen and (max-width: 360px) {\n  .header,\n  .main {\n    border-radius: 12px;\n  }\n\n  .root {\n    padding: 4px;\n  }\n}\n",
      "size_bytes": 5686
    },
    "sdks/agent-sdk/src/middleware.ts": {
      "content": "export * from \"./middleware/index.js\";\n",
      "size_bytes": 39
    },
    "content-types/content-type-reaction/README.md": {
      "content": "# Reaction content type\n\nThis package provides an XMTP content type to support reactions to messages.\n\n> **Open for feedback**  \n> You are welcome to provide feedback on this implementation by commenting on [XIP-20: Reactions content type](https://community.xmtp.org/t/xip-20-reactions-content-type/524).\n\n## What’s a reaction?\n\nA reaction is a quick and often emoji-based way to respond to a message. Reactions are usually limited to a predefined set of emojis or symbols provided by the messaging app.\n\n## Why reactions?\n\nProviding message reactions in your app enables users to easily express a general sentiment or emotion toward a message. It also provides a handy way to acknowledge a message or show a particular emotional reaction without engaging in a detailed response.\n\n## Install the package\n\n```bash\n# npm\nnpm i @xmtp/content-type-reaction\n\n# yarn\nyarn add @xmtp/content-type-reaction\n\n# pnpm\npnpm i @xmtp/content-type-reaction\n```\n\n## Create a reaction\n\nWith XMTP, reactions are represented as objects with the following keys:\n\n- `reference`: The message ID for the message that is being reacted to\n- `action`: The action of the reaction (`added` or `removed`)\n- `content`: A string representation of a reaction (e.g. `smile`) to be interpreted by clients\n\n```tsx\nconst reaction: Reaction = {\n  reference: someMessageID,\n  action: \"added\",\n  content: \"smile\",\n};\n```\n\n## Send a reaction\n\nNow that you have a reaction, you can send it:\n\n```tsx\nawait conversation.messages.send(reaction, {\n  contentType: ContentTypeReaction,\n});\n```\n\n> **Note**  \n> `contentFallback` text is provided by the codec and gives clients that _don't_ support a content type the option to display some useful context. For cases where clients *do* support the content type, they can use the content fallback as alt text for accessibility purposes.\n\n## Receive a reaction\n\nNow that you can send a reaction, you need a way to receive a reaction. For example:\n\n```tsx\n// Assume `loadLastMessage` is a thing you have\nconst message: DecodedMessage = await loadLastMessage();\n\nif (!message.contentType.sameAs(ContentTypeReaction)) {\n  // We do not have a reaction. A topic for another blog post.\n  return;\n}\n\n// We've got a reaction.\nconst reaction: Reaction = message.content;\n```\n\n## Display the reaction\n\nGenerally, reactions should be interpreted as emoji. So, `smile` would translate to :smile: in UI clients. That being said, how you ultimately choose to render a reaction in your app is up to you.\n\n## Developing\n\nRun `yarn dev` to build the content type and watch for changes, which will trigger a rebuild.\n\nFor more information on contributing to this repository, see our [contributing guidelines](../../CONTRIBUTING.md).\n",
      "size_bytes": 2716
    },
    "README.md": {
      "content": "This is the official repository for XMTP client SDKs and content types for browsers and Node, written in TypeScript.\n\nTo learn more about the contents of this repository, see this README and the READMEs provided in each workspace directory.\n\n## What's inside?\n\n### Apps\n\n- [`xmtp.chat`](apps/xmtp.chat): A [web app for developers](https://xmtp.chat/) to experiment with XMTP\n- [`xmtp.chat-api-service`](apps/xmtp.chat-api-service/): An API to use [Pinata's file storage](https://pinata.cloud/)\n\n### SDKs\n\n- [`agent-sdk`](sdks/agent-sdk): XMTP agent SDK for Node\n- [`browser-sdk`](sdks/browser-sdk): XMTP client SDK for browsers\n- [`node-sdk`](sdks/node-sdk): XMTP client SDK for Node\n\n### Content types\n\n- [`content-type-primitives`](content-types/content-type-primitives): Primitives for building custom XMTP content types\n- [`content-type-group-updated`](content-types/content-type-group-updated): Content type for group update messages\n- [`content-type-reaction`](content-types/content-type-reaction): Content type for reactions to messages\n- [`content-type-read-receipt`](content-types/content-type-read-receipt): Content type for read receipts for messages\n- [`content-type-remote-attachment`](content-types/content-type-remote-attachment): Content type for sending file attachments that are stored off-network\n- [`content-type-reply`](content-types/content-type-reply): Content type for direct replies to messages\n- [`content-type-text`](content-types/content-type-text): Content type for plain text messages\n- [`content-type-transaction-reference`](content-types/content-type-transaction-reference): Content type for on-chain transaction references\n\n## Contributing\n\nSee our [contribution guide](./CONTRIBUTING.md) to learn more about contributing to this project.\n# Mumble_chat_DApp\n",
      "size_bytes": 1794
    },
    "content-types/content-type-markdown/src/Markdown.test.ts": {
      "content": "import { describe, expect, it } from \"vitest\";\nimport { ContentTypeMarkdown, Encoding, MarkdownCodec } from \"./Markdown\";\n\ndescribe(\"ContentTypeMarkdown\", () => {\n  it(\"can encode/decode markdown\", () => {\n    const markdown = \"*italic*\";\n    const codec = new MarkdownCodec();\n    const ec = codec.encode(markdown);\n    expect(ec.type.sameAs(ContentTypeMarkdown)).toBe(true);\n    expect(ec.parameters.encoding).toEqual(Encoding.utf8);\n    const markdown2 = codec.decode(ec);\n    expect(markdown2).toEqual(markdown);\n  });\n\n  it(\"defaults to utf-8\", () => {\n    const markdown = \"**bold**\";\n    const codec = new MarkdownCodec();\n    const ec = codec.encode(markdown);\n    expect(ec.type.sameAs(ContentTypeMarkdown)).toBe(true);\n    expect(ec.parameters.encoding).toEqual(Encoding.utf8);\n    const markdown2 = codec.decode(ec);\n    expect(markdown2).toEqual(markdown);\n  });\n\n  it(\"throws on invalid input\", () => {\n    const codec = new MarkdownCodec();\n    const ec = {\n      type: ContentTypeMarkdown,\n      parameters: {\n        encoding: Encoding.utf8,\n      },\n      content: {} as Uint8Array,\n    };\n    expect(() => codec.decode(ec)).toThrow();\n  });\n\n  it(\"throws on unknown encoding\", () => {\n    const codec = new MarkdownCodec();\n    const ec = {\n      type: ContentTypeMarkdown,\n      parameters: { encoding: \"UTF-16\" } as unknown as { encoding: Encoding },\n      content: new Uint8Array(0),\n    };\n    expect(() => codec.decode(ec)).toThrow(\"unrecognized encoding UTF-16\");\n  });\n});\n",
      "size_bytes": 1498
    },
    "sdks/browser-sdk/src/DecodedMessage.ts": {
      "content": "import type { ContentTypeId } from \"@xmtp/content-type-primitives\";\nimport { DeliveryStatus, GroupMessageKind } from \"@xmtp/wasm-bindings\";\nimport type { Client } from \"@/Client\";\nimport { fromSafeContentTypeId, type SafeMessage } from \"@/utils/conversions\";\n\nexport type MessageKind = \"application\" | \"membership_change\";\nexport type MessageDeliveryStatus = \"unpublished\" | \"published\" | \"failed\";\n\n/**\n * Represents a decoded XMTP message\n *\n * This class transforms network messages into a structured format with\n * content decoding.\n *\n * @class\n * @property {any} content - The decoded content of the message\n * @property {ContentTypeId} contentType - The content type of the message content\n * @property {string} conversationId - Unique identifier for the conversation\n * @property {MessageDeliveryStatus} deliveryStatus - Current delivery status of the message (\"unpublished\" | \"published\" | \"failed\")\n * @property {string} [fallback] - Optional fallback text for the message\n * @property {number} [compression] - Optional compression level applied to the message\n * @property {string} id - Unique identifier for the message\n * @property {MessageKind} kind - Type of message (\"application\" | \"membership_change\")\n * @property {Map<string, string>} parameters - Additional parameters associated with the message\n * @property {SafeMessage[\"content\"]} encodedContent - Raw encoded content of the message\n * @property {string} senderInboxId - Identifier for the sender's inbox\n * @property {bigint} sentAtNs - Timestamp when the message was sent (in nanoseconds)\n */\nexport class DecodedMessage<ContentTypes = unknown> {\n  #client: Client<ContentTypes>;\n  content: ContentTypes | undefined;\n  contentType: ContentTypeId;\n  conversationId: string;\n  deliveryStatus: MessageDeliveryStatus;\n  fallback?: string;\n  compression?: number;\n  id: string;\n  kind: MessageKind;\n  parameters: Map<string, string>;\n  encodedContent: SafeMessage[\"content\"];\n  senderInboxId: string;\n  sentAtNs: bigint;\n\n  constructor(client: Client<ContentTypes>, message: SafeMessage) {\n    this.#client = client;\n    this.id = message.id;\n    this.sentAtNs = message.sentAtNs;\n    this.conversationId = message.convoId;\n    this.senderInboxId = message.senderInboxId;\n    this.encodedContent = message.content;\n\n    switch (message.kind) {\n      case GroupMessageKind.Application:\n        this.kind = \"application\";\n        break;\n      case GroupMessageKind.MembershipChange:\n        this.kind = \"membership_change\";\n        break;\n      // no default\n    }\n\n    switch (message.deliveryStatus) {\n      case DeliveryStatus.Unpublished:\n        this.deliveryStatus = \"unpublished\";\n        break;\n      case DeliveryStatus.Published:\n        this.deliveryStatus = \"published\";\n        break;\n      case DeliveryStatus.Failed:\n        this.deliveryStatus = \"failed\";\n        break;\n      // no default\n    }\n\n    this.contentType = fromSafeContentTypeId(message.content.type);\n    this.parameters = new Map(Object.entries(message.content.parameters));\n    this.fallback = message.content.fallback;\n    this.compression = message.content.compression;\n\n    try {\n      this.content = this.#client.decodeContent<ContentTypes>(\n        message,\n        this.contentType,\n      );\n    } catch {\n      this.content = undefined;\n    }\n  }\n}\n",
      "size_bytes": 3309
    },
    "apps/xmtp.chat/src/helpers/errors.ts": {
      "content": "export class ClientNotFoundError extends Error {\n  constructor(context: string) {\n    super(`XMTP client is required when ${context}`);\n  }\n}\n",
      "size_bytes": 142
    },
    "sdks/node-sdk/src/utils/inboxId.ts": {
      "content": "import {\n  generateInboxId as generateInboxIdBinding,\n  getInboxIdForIdentifier as getInboxIdForIdentifierBinding,\n  type Identifier,\n} from \"@xmtp/node-bindings\";\nimport { ApiUrls } from \"@/constants\";\nimport type { XmtpEnv } from \"@/types\";\n\nexport const generateInboxId = (identifier: Identifier): string => {\n  return generateInboxIdBinding(identifier);\n};\n\nexport const getInboxIdForIdentifier = async (\n  identifier: Identifier,\n  env: XmtpEnv = \"dev\",\n) => {\n  const host = ApiUrls[env];\n  const isSecure = host.startsWith(\"https\");\n  return getInboxIdForIdentifierBinding(host, isSecure, identifier);\n};\n",
      "size_bytes": 612
    },
    "sdks/agent-sdk/src/demo.ts": {
      "content": "import { loadEnvFile } from \"node:process\";\nimport { TextCodec } from \"@xmtp/content-type-text\";\nimport { Agent, AgentError } from \"./core/index.js\";\nimport { getTestUrl } from \"./debug/log.js\";\nimport { CommandRouter } from \"./middleware/CommandRouter.js\";\nimport { createNameResolver } from \"./user.js\";\nimport { createSigner, createUser } from \"./user/User.js\";\n\ntry {\n  loadEnvFile(\".env\");\n  console.info(`Loaded keys from \".env\" file.`);\n} catch {}\n\nconst agent = process.env.XMTP_WALLET_KEY\n  ? await Agent.createFromEnv()\n  : await Agent.create(createSigner(createUser()), {\n      dbPath: null,\n    });\n\nconst router = new CommandRouter();\n\nrouter.command(\"/version\", async (ctx) => {\n  await ctx.conversation.send(`v${process.env.npm_package_version}`);\n});\n\nagent.use(router.middleware());\n\nagent.on(\"attachment\", (ctx) => {\n  console.log(\"Got attachment:\", ctx.message.content);\n});\n\nagent.on(\"text\", (ctx) => {\n  console.log(\"Got text:\", ctx.message.content);\n});\n\nagent.on(\"reaction\", (ctx) => {\n  console.log(\"Got reaction:\", ctx.message.content);\n});\n\nagent.on(\"reply\", (ctx) => {\n  console.log(\"Got reply:\", ctx.message.content);\n});\n\nagent.on(\"text\", async (ctx) => {\n  if (ctx.message.content.startsWith(\"@agent\")) {\n    await ctx.conversation.send(\"How can I help you?\");\n  }\n});\n\nconst errorHandler = (error: unknown) => {\n  if (error instanceof AgentError) {\n    console.log(`Caught error ID \"${error.code}\"`, error);\n    console.log(\"Original error\", error.cause);\n  } else {\n    console.log(`Caught error`, error);\n  }\n};\n\nagent.on(\"unhandledError\", errorHandler);\n\nagent.on(\"start\", (ctx) => {\n  console.log(`We are online: ${getTestUrl(ctx.client)}`);\n});\n\nagent.on(\"stop\", (ctx) => {\n  console.log(\"Agent stopped\", ctx);\n});\n\nagent.on(\"unknownMessage\", (ctx) => {\n  // Narrow down by codec\n  if (ctx.usesCodec(TextCodec)) {\n    const content = ctx.message.content;\n    console.log(`Text content: ${content.toUpperCase()}`);\n  }\n});\n\nawait agent.start();\nconsole.log(\"Agent has started.\");\n\nconst resolveName = createNameResolver(process.env.WEB3BIO_API_KEY);\nconsole.log(await resolveName(\"vitalik.eth\"));\n",
      "size_bytes": 2132
    },
    "content-types/content-type-text/vitest.config.ts": {
      "content": "import { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n  },\n});\n",
      "size_bytes": 115
    },
    "sdks/agent-sdk/src/bin/generateKeys.ts": {
      "content": "#!/usr/bin/env node\nimport { getRandomValues } from \"node:crypto\";\nimport { writeFileSync } from \"node:fs\";\nimport { join } from \"node:path\";\nimport { generatePrivateKey } from \"viem/accounts\";\n\nconst generateClientKeys = () => {\n  const randomValues = getRandomValues(new Uint8Array(32));\n  const dbEncryptionKey = Buffer.from(randomValues).toString(\"hex\");\n  return {\n    XMTP_DB_ENCRYPTION_KEY: dbEncryptionKey,\n    XMTP_WALLET_KEY: generatePrivateKey(),\n  };\n};\n\n/**\n * Generates client keys and saves them to a .env file in the project root.\n * This script creates the necessary environment variables for XMTP agent initialization.\n */\nfunction main() {\n  try {\n    // Generate the client keys\n    const keys = generateClientKeys();\n\n    // Create the .env file content\n    const envContent =\n      Object.entries(keys)\n        .map(([key, value]) => `${key}=${value}`)\n        .join(\"\\n\") + \"\\n\";\n\n    if (!process.env.INIT_CWD) {\n      throw new Error(\n        `Cannot invoke script because \"process.env.INIT_CWD\" wasn't found.`,\n      );\n    }\n    const envFilePath = join(process.env.INIT_CWD, \".env\");\n\n    writeFileSync(envFilePath, envContent, \"utf8\");\n\n    console.log(\"✅ Successfully generated client keys and saved to .env file\");\n    console.log(`📁 File location: ${envFilePath}`);\n    console.log(\"🔑 Generated keys:\");\n    Object.keys(keys).forEach((key) => {\n      console.log(`   - ${key}`);\n    });\n  } catch (error) {\n    console.error(\"❌ Error generating client keys:\", error);\n    process.exit(1);\n  }\n}\n\nmain();\n",
      "size_bytes": 1546
    },
    "sdks/agent-sdk/src/user/NameResolver.test.ts": {
      "content": "import { afterEach, beforeEach, describe, expect, it, vi } from \"vitest\";\nimport { createNameResolver } from \"./NameResolver.js\";\n\nconst mockFetch = vi.fn();\nglobal.fetch = mockFetch;\n\ndescribe(\"NameResolver\", () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe(\"caching behavior\", () => {\n    it(\"should return address immediately without API call for valid addresses\", async () => {\n      const nameResolver = createNameResolver();\n      const validAddress = \"0x1234567890123456789012345678901234567890\";\n\n      const result = await nameResolver(validAddress);\n      expect(result).toBe(validAddress);\n      expect(mockFetch).not.toHaveBeenCalled();\n    });\n\n    it(\"should cache resolved names and not make duplicate API calls\", async () => {\n      const mockResponse = [\n        { address: \"0x1234567890123456789012345678901234567890\" },\n      ];\n\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: () => Promise.resolve(mockResponse),\n      });\n\n      const nameResolver = createNameResolver();\n      const testName = \"test.eth\";\n\n      const firstRequest = await nameResolver(testName);\n      expect(firstRequest).toBe(\"0x1234567890123456789012345678901234567890\");\n      expect(\n        mockFetch,\n        \"First call should make an API request\",\n      ).toHaveBeenCalledTimes(1);\n\n      const secondRequest = await nameResolver(testName);\n      expect(secondRequest).toBe(\"0x1234567890123456789012345678901234567890\");\n      expect(mockFetch, \"Still only 1 call\").toHaveBeenCalledTimes(1);\n    });\n  });\n});\n",
      "size_bytes": 1605
    },
    "sdks/browser-sdk/src/WorkerPreferences.ts": {
      "content": "import {\n  type Client,\n  type Consent,\n  type ConsentEntityType,\n  type Conversations,\n  type UserPreference,\n} from \"@xmtp/wasm-bindings\";\nimport { fromSafeConsent, type SafeConsent } from \"@/utils/conversions\";\nimport type { StreamCallback } from \"@/utils/streams\";\n\nexport class WorkerPreferences {\n  #client: Client;\n  #conversations: Conversations;\n\n  constructor(client: Client, conversations: Conversations) {\n    this.#client = client;\n    this.#conversations = conversations;\n  }\n\n  sync() {\n    return this.#client.syncPreferences();\n  }\n\n  async inboxState(refreshFromNetwork: boolean) {\n    return this.#client.inboxState(refreshFromNetwork);\n  }\n\n  async inboxStateFromInboxIds(\n    inboxIds: string[],\n    refreshFromNetwork?: boolean,\n  ) {\n    return this.#client.inboxStateFromInboxIds(\n      inboxIds,\n      refreshFromNetwork ?? false,\n    );\n  }\n\n  async getLatestInboxState(inboxId: string) {\n    return this.#client.getLatestInboxState(inboxId);\n  }\n\n  async setConsentStates(records: SafeConsent[]) {\n    return this.#client.setConsentStates(records.map(fromSafeConsent));\n  }\n\n  async getConsentState(entityType: ConsentEntityType, entity: string) {\n    return this.#client.getConsentState(entityType, entity);\n  }\n\n  streamConsent(callback: StreamCallback<Consent[]>, onFail: () => void) {\n    const on_consent_update = (consent: Consent[]) => {\n      callback(null, consent);\n    };\n    const on_error = (error: Error | null) => {\n      callback(error, undefined);\n    };\n    const on_close = () => {\n      onFail();\n    };\n    return this.#conversations.streamConsent({\n      on_consent_update,\n      on_error,\n      on_close,\n    });\n  }\n\n  streamPreferences(\n    callback: StreamCallback<UserPreference[]>,\n    onFail: () => void,\n  ) {\n    const on_user_preference_update = (preferences: UserPreference[]) => {\n      callback(null, preferences);\n    };\n    const on_error = (error: Error | null) => {\n      callback(error, undefined);\n    };\n    const on_close = () => {\n      onFail();\n    };\n    return this.#conversations.streamPreferences({\n      on_user_preference_update,\n      on_error,\n      on_close,\n    });\n  }\n}\n",
      "size_bytes": 2155
    },
    "sdks/agent-sdk/src/core/index.ts": {
      "content": "export * from \"./Agent.js\";\nexport * from \"./AgentError.js\";\nexport * from \"./ClientContext.js\";\nexport * from \"./ConversationContext.js\";\nexport * from \"./filter.js\";\nexport * from \"./MessageContext.js\";\n",
      "size_bytes": 205
    },
    "apps/xmtp.chat/src/components/BadgeWithCopy.module.css": {
      "content": ".badge {\n  background-color: light-dark(\n    var(--mantine-color-gray-1),\n    var(--mantine-color-dark-5)\n  );\n  color: light-dark(var(--mantine-color-light-4), var(--mantine-color-dark-1));\n}\n\n.button {\n  color: light-dark(var(--mantine-color-light-4), var(--mantine-color-dark-1));\n}\n",
      "size_bytes": 286
    },
    "content-types/content-type-remote-attachment/vitest.setup.ts": {
      "content": "import { unlink } from \"node:fs/promises\";\nimport { dirname, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { glob } from \"fast-glob\";\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nexport const teardown = async () => {\n  const files = await glob(\"**/*.db3*\", { cwd: __dirname });\n  await Promise.all(files.map((file) => unlink(join(__dirname, file))));\n};\n",
      "size_bytes": 398
    },
    "content-types/content-type-reaction/CHANGELOG.md": {
      "content": "# @xmtp/content-type-reaction\n\n## 2.0.2\n\n### Patch Changes\n\n- Updated dependencies [779fd0c]\n  - @xmtp/content-type-primitives@2.0.2\n\n## 2.0.1\n\n### Patch Changes\n\n- Updated dependencies [340fcf4]\n  - @xmtp/content-type-primitives@2.0.1\n\n## 2.0.0\n\n### Major Changes\n\n- 1777a23: Dropped support for CommonJS\n\n### Patch Changes\n\n- Updated dependencies [1777a23]\n  - @xmtp/content-type-primitives@2.0.0\n\n## 1.1.12\n\n### Patch Changes\n\n- c27eb2e: Set `shouldPush` to `false`\n\n## 1.1.11\n\n### Patch Changes\n\n- Updated dependencies [63e5276]\n  - @xmtp/content-type-primitives@1.0.3\n\n## 1.1.10\n\n### Patch Changes\n\n- 9addb1c:\n  - Updated `ReactionCodec` type to include parameters type\n  - Added and exported `LegacyReactionParameters` type\n- Updated dependencies [9addb1c]\n  - @xmtp/content-type-primitives@1.0.2\n\n## 1.1.9\n\n### Patch Changes\n\n- [#75](https://github.com/xmtp/xmtp-js-content-types/pull/75) [`da0bd85`](https://github.com/xmtp/xmtp-js-content-types/commit/da0bd8578d5f5032b221e25f02e8492b27929d6c)\n  - Use primitives package for types\n\n## 1.1.8\n\n### Patch Changes\n\n- [#68](https://github.com/xmtp/xmtp-js-content-types/pull/68) [`8896b33`](https://github.com/xmtp/xmtp-js-content-types/commit/8896b33501b2860d68ea8be5e33a9cca5dd9315c)\n  - Add optional referenceInboxId\n\n## 1.1.7\n\n### Patch Changes\n\n- [#65](https://github.com/xmtp/xmtp-js-content-types/pull/65) [`c4d43dc`](https://github.com/xmtp/xmtp-js-content-types/commit/c4d43dc948231de5c7f730e06f0931076de0673b)\n  - Add `shouldPush` to all content codecs\n\n## 1.1.6\n\n### Patch Changes\n\n- [#60](https://github.com/xmtp/xmtp-js-content-types/pull/60) [`5b9310a`](https://github.com/xmtp/xmtp-js-content-types/commit/5b9310ac89fd23e5cfd74903894073b6ef8af7c3)\n  - Upgraded JS SDK to `11.3.12`\n\n## 1.1.5\n\n### Patch Changes\n\n- [#54](https://github.com/xmtp/xmtp-js-content-types/pull/54) [`718cb9f`](https://github.com/xmtp/xmtp-js-content-types/commit/718cb9fec51f74bf2402f3f22160687cae35dda8)\n  - Updated Turbo config to remove `generate:types` command and instead rely on `build`\n  - Removed all `generate:types` commands from `package.json` files\n  - Updated shared ESLint config and local ESLint configs\n  - Updated `include` field of `tsconfig.json` and `tsconfig.eslint.json` files\n  - Replaced `tsup` with `rollup`\n\n## 1.1.4\n\n### Patch Changes\n\n- [#51](https://github.com/xmtp/xmtp-js-content-types/pull/51) [`aeb6db7`](https://github.com/xmtp/xmtp-js-content-types/commit/aeb6db73a63409a33c7d3d3431e33682b0ce4c4d)\n  - Only publish files in the `/dist` directory\n\n## 1.1.3\n\n### Patch Changes\n\n- Upgraded `@xmtp/proto` package\n- Upgraded `@xmtp/xmtp-js` package\n\n## 1.1.2\n\n### Patch Changes\n\n- Upgrade to JS SDK v11\n- Update client initialization for tests to use `codecs` option for proper types\n\n## 1.1.1\n\n### Patch Changes\n\n- [#30](https://github.com/xmtp/xmtp-js-content-types/pull/30) [`41fe976`](https://github.com/xmtp/xmtp-js-content-types/commit/41fe976c009af8daa415e29b6820166675a8c77b)\n  - fix: update the copy for the default fallbacks\n\n## 1.1.0\n\n### Minor Changes\n\n- [#25](https://github.com/xmtp/xmtp-js-content-types/pull/25) [`3c531b7`](https://github.com/xmtp/xmtp-js-content-types/commit/3c531b7dc057a9f7907a9289a0a35f0da3a48e44)\n  - Add dummy fallback field to all content types\n\n## 1.0.2\n\n### Patch Changes\n\n- Normalize Reaction content type encoding, support legacy format\n\n## 1.0.1\n\n### Patch Changes\n\n- Add schema to Reaction content type\n",
      "size_bytes": 3424
    },
    "apps/xmtp.chat/src/components/App/WalletConnect.tsx": {
      "content": "import { Group, Paper, Stack } from \"@mantine/core\";\nimport { BlockchainSelect } from \"@/components/App/BlockchainSelect\";\nimport { ConnectorSelect } from \"@/components/App/ConnectorSelect\";\nimport { ConnectWallet } from \"@/components/App/ConnectWallet\";\nimport { UseEphemeral } from \"@/components/App/UseEphemeral\";\nimport { UseSCW } from \"@/components/App/UseSCW\";\n\nexport const WalletConnect = () => {\n  return (\n    <Paper withBorder radius=\"md\">\n      <Stack gap={0}>\n        <Group gap=\"sm\" align=\"center\" justify=\"center\" flex={1} p=\"md\">\n          <UseSCW />\n          <BlockchainSelect />\n        </Group>\n        <ConnectorSelect />\n        <Group align=\"center\" justify=\"space-between\" flex={1} p=\"md\">\n          <UseEphemeral />\n          <ConnectWallet />\n        </Group>\n      </Stack>\n    </Paper>\n  );\n};\n",
      "size_bytes": 822
    },
    "sdks/node-sdk/test/Preferences.test.ts": {
      "content": "import { ConsentEntityType, ConsentState } from \"@xmtp/node-bindings\";\nimport { v4 } from \"uuid\";\nimport { describe, expect, it } from \"vitest\";\nimport {\n  createClient,\n  createRegisteredClient,\n  createSigner,\n  createUser,\n  sleep,\n} from \"@test/helpers\";\n\ndescribe(\"Preferences\", () => {\n  it(\"should return the correct inbox state\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const inboxState = await client.preferences.inboxState();\n    expect(inboxState.inboxId).toBe(client.inboxId);\n    expect(inboxState.installations.map((install) => install.id)).toEqual([\n      client.installationId,\n    ]);\n    expect(inboxState.identifiers).toEqual([await signer.getIdentifier()]);\n    expect(inboxState.recoveryIdentifier).toStrictEqual(\n      await signer.getIdentifier(),\n    );\n\n    const user2 = createUser();\n    const signer2 = createSigner(user2);\n    const client2 = await createClient(signer2);\n    const inboxState2 = await client2.preferences.getLatestInboxState(\n      client.inboxId,\n    );\n    expect(inboxState2.inboxId).toBe(client.inboxId);\n    expect(inboxState.installations.length).toBe(1);\n    expect(inboxState.installations[0].id).toBe(client.installationId);\n    expect(inboxState2.identifiers).toEqual([await signer.getIdentifier()]);\n    expect(inboxState2.recoveryIdentifier).toStrictEqual(\n      await signer.getIdentifier(),\n    );\n  });\n\n  it(\"should get inbox states from inbox IDs\", async () => {\n    const user = createUser();\n    const user2 = createUser();\n    const signer = createSigner(user);\n    const signer2 = createSigner(user2);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer2);\n    const inboxStates = await client.preferences.inboxStateFromInboxIds([\n      client.inboxId,\n    ]);\n    expect(inboxStates.length).toBe(1);\n    expect(inboxStates[0].inboxId).toBe(client.inboxId);\n    expect(inboxStates[0].identifiers).toEqual([await signer.getIdentifier()]);\n\n    const inboxStates2 = await client2.preferences.inboxStateFromInboxIds(\n      [client2.inboxId],\n      true,\n    );\n    expect(inboxStates2.length).toBe(1);\n    expect(inboxStates2[0].inboxId).toBe(client2.inboxId);\n    expect(inboxStates2[0].identifiers).toEqual([\n      await signer2.getIdentifier(),\n    ]);\n  });\n\n  it(\"should manage consent states\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const group = await client1.conversations.newGroup([client2.inboxId]);\n\n    await client2.conversations.sync();\n    const group2 = await client2.conversations.getConversationById(group.id);\n\n    expect(group2).not.toBeNull();\n\n    expect(\n      await client2.preferences.getConsentState(\n        ConsentEntityType.GroupId,\n        group2!.id,\n      ),\n    ).toBe(ConsentState.Unknown);\n\n    await client2.preferences.setConsentStates([\n      {\n        entityType: ConsentEntityType.GroupId,\n        entity: group2!.id,\n        state: ConsentState.Allowed,\n      },\n    ]);\n\n    expect(\n      await client2.preferences.getConsentState(\n        ConsentEntityType.GroupId,\n        group2!.id,\n      ),\n    ).toBe(ConsentState.Allowed);\n\n    expect(group2!.consentState).toBe(ConsentState.Allowed);\n\n    group2!.updateConsentState(ConsentState.Denied);\n\n    expect(\n      await client2.preferences.getConsentState(\n        ConsentEntityType.GroupId,\n        group2!.id,\n      ),\n    ).toBe(ConsentState.Denied);\n  });\n\n  it(\"should stream consent updates\", async () => {\n    const user = createUser();\n    const user2 = createUser();\n    const signer = createSigner(user);\n    const signer2 = createSigner(user2);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer2);\n    const group = await client.conversations.newGroup([client2.inboxId]);\n    const stream = await client.preferences.streamConsent();\n\n    await sleep(1000);\n    group.updateConsentState(ConsentState.Denied);\n\n    await sleep(1000);\n    await client.preferences.setConsentStates([\n      {\n        entity: group.id,\n        entityType: ConsentEntityType.GroupId,\n        state: ConsentState.Allowed,\n      },\n    ]);\n\n    await sleep(1000);\n    await client.preferences.setConsentStates([\n      {\n        entity: group.id,\n        entityType: ConsentEntityType.GroupId,\n        state: ConsentState.Denied,\n      },\n      {\n        entity: client2.inboxId,\n        entityType: ConsentEntityType.InboxId,\n        state: ConsentState.Allowed,\n      },\n    ]);\n\n    setTimeout(() => {\n      void stream.end();\n    }, 2000);\n\n    let count = 0;\n    for await (const updates of stream) {\n      count++;\n      if (count === 1) {\n        expect(updates.length).toBe(1);\n        expect(updates[0].state).toBe(ConsentState.Denied);\n        expect(updates[0].entity).toBe(group.id);\n        expect(updates[0].entityType).toBe(ConsentEntityType.GroupId);\n      } else if (count === 2) {\n        expect(updates.length).toBe(1);\n        expect(updates[0].state).toBe(ConsentState.Allowed);\n        expect(updates[0].entity).toBe(group.id);\n        expect(updates[0].entityType).toBe(ConsentEntityType.GroupId);\n      } else if (count === 3) {\n        expect(updates.length).toBe(2);\n        expect(updates[0].state).toBe(ConsentState.Denied);\n        expect(updates[0].entity).toBe(group.id);\n        expect(updates[0].entityType).toBe(ConsentEntityType.GroupId);\n        expect(updates[1].state).toBe(ConsentState.Allowed);\n        expect(updates[1].entity).toBe(client2.inboxId);\n        expect(updates[1].entityType).toBe(ConsentEntityType.InboxId);\n      }\n    }\n    expect(count).toBe(3);\n  });\n\n  it(\"should stream preferences\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const stream = await client.preferences.streamPreferences();\n\n    await sleep(2000);\n\n    const client2 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    const client3 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    await client3.conversations.syncAll();\n    await sleep(2000);\n    await client.conversations.syncAll();\n    await sleep(2000);\n    await client2.conversations.syncAll();\n    await sleep(2000);\n\n    setTimeout(() => {\n      void stream.end();\n    }, 2000);\n\n    let count = 0;\n    for await (const preferences of stream) {\n      count++;\n      expect(preferences).toBeDefined();\n      expect(preferences.type).toBeDefined();\n      expect(preferences.HmacKeyUpdate).toBeDefined();\n      expect(preferences.HmacKeyUpdate?.key).toBeDefined();\n    }\n    expect(count).toBe(2);\n  });\n});\n",
      "size_bytes": 6984
    },
    "apps/xmtp.chat/src/components/Messages/WalletSendCallsContent.tsx": {
      "content": "import { Box, Button, List, Space, Text } from \"@mantine/core\";\nimport {\n  ContentTypeTransactionReference,\n  type TransactionReference,\n} from \"@xmtp/content-type-transaction-reference\";\nimport type { WalletSendCallsParams } from \"@xmtp/content-type-wallet-send-calls\";\nimport { useCallback } from \"react\";\nimport { useChainId, useSendTransaction, useSwitchChain } from \"wagmi\";\nimport { useClient } from \"@/contexts/XMTPContext\";\n\nexport type WalletSendCallsContentProps = {\n  content: WalletSendCallsParams;\n  conversationId: string;\n};\n\nexport const WalletSendCallsContent: React.FC<WalletSendCallsContentProps> = ({\n  content,\n  conversationId,\n}) => {\n  const client = useClient();\n  const { sendTransactionAsync } = useSendTransaction();\n  const { switchChainAsync } = useSwitchChain();\n  const wagmiChainId = useChainId();\n\n  const handleSubmit = useCallback(async () => {\n    const chainId = parseInt(content.chainId, 16);\n    if (chainId !== wagmiChainId) {\n      console.log(\n        `Current Chain Id (${wagmiChainId}) doesn't match; switching to Chain Id ${chainId}.`,\n      );\n      await switchChainAsync({ chainId });\n      await new Promise((r) => setTimeout(r, 300)); // Metamask requires some delay\n    }\n    for (const call of content.calls) {\n      const wagmiTxData = {\n        ...call,\n        value: BigInt(parseInt(call.value || \"0x0\", 16)),\n        chainId,\n        gas: call.gas ? BigInt(parseInt(call.gas, 16)) : undefined,\n      };\n      const txHash = await sendTransactionAsync(wagmiTxData, {\n        onError(error) {\n          console.error(error);\n        },\n      });\n      const transactionReference: TransactionReference = {\n        networkId: content.chainId,\n        reference: txHash,\n      };\n      const conversation =\n        await client.conversations.getConversationById(conversationId);\n      if (!conversation) {\n        console.error(\"Couldn't find conversation by Id\");\n        return;\n      }\n      await conversation.send(\n        transactionReference,\n        ContentTypeTransactionReference,\n      );\n    }\n  }, [content, sendTransactionAsync, client, conversationId]);\n\n  return (\n    <Box flex=\"flex\">\n      <Text size=\"sm\">Review the following transactions:</Text>\n      <List size=\"sm\">\n        {content.calls.map((call, idx) => (\n          <List.Item key={idx}>{call.metadata?.description}</List.Item>\n        ))}\n      </List>\n      <Space h=\"md\" />\n      <Button\n        fullWidth\n        onClick={(event) => {\n          event.stopPropagation();\n          void handleSubmit();\n        }}>\n        Submit\n      </Button>\n    </Box>\n  );\n};\n",
      "size_bytes": 2598
    },
    "sdks/node-sdk/vitest.setup.ts": {
      "content": "import { unlink } from \"node:fs/promises\";\nimport { dirname, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { glob } from \"fast-glob\";\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nexport const teardown = async () => {\n  const files = await glob(\"**/*.db3*\", { cwd: __dirname });\n  await Promise.all(files.map((file) => unlink(join(__dirname, file))));\n};\n",
      "size_bytes": 398
    },
    "apps/xmtp.chat/src/components/App/SelectConversation.tsx": {
      "content": "import { Button, Divider, Stack, Text } from \"@mantine/core\";\nimport { useNavigate } from \"react-router\";\nimport { ContentLayout } from \"@/layouts/ContentLayout\";\n\nexport const SelectConversation = () => {\n  const navigate = useNavigate();\n  return (\n    <ContentLayout title=\"No conversation selected\">\n      <Stack gap=\"lg\" align=\"center\" py=\"xl\">\n        <Text>\n          Select a conversation in the left sidebar to display its messages.\n        </Text>\n        <Divider\n          label=\"or\"\n          w=\"80%\"\n          styles={{\n            label: {\n              fontSize: \"var(--mantine-font-size-md)\",\n              color: \"var(--mantine-color-text)\",\n            },\n          }}\n        />\n        <Stack gap=\"xs\">\n          <Button\n            size=\"xs\"\n            onClick={() => {\n              void navigate(\"/conversations/new-group\");\n            }}>\n            Create a new group\n          </Button>\n          <Button\n            size=\"xs\"\n            onClick={() => {\n              void navigate(\"/conversations/new-dm\");\n            }}>\n            Create a new direct message\n          </Button>\n        </Stack>\n      </Stack>\n    </ContentLayout>\n  );\n};\n",
      "size_bytes": 1177
    },
    "sdks/node-sdk/src/utils/date.ts": {
      "content": "export function nsToDate(ns: number): Date {\n  return new Date(ns / 1_000_000);\n}\n",
      "size_bytes": 82
    },
    "sdks/browser-sdk/src/types/actions/utils.ts": {
      "content": "import type { Identifier } from \"@xmtp/wasm-bindings\";\nimport type { XmtpEnv } from \"@/types/options\";\nimport type { SafeInboxState } from \"@/utils/conversions\";\nimport type { SafeSigner } from \"@/utils/signer\";\n\nexport type UtilsWorkerAction =\n  | {\n      action: \"utils.init\";\n      id: string;\n      result: undefined;\n      data: {\n        enableLogging: boolean;\n      };\n    }\n  | {\n      action: \"utils.generateInboxId\";\n      id: string;\n      result: string;\n      data: {\n        identifier: Identifier;\n      };\n    }\n  | {\n      action: \"utils.getInboxIdForIdentifier\";\n      id: string;\n      result: string | undefined;\n      data: {\n        identifier: Identifier;\n        env?: XmtpEnv;\n      };\n    }\n  | {\n      action: \"utils.revokeInstallationsSignatureText\";\n      id: string;\n      result: {\n        signatureText: string;\n        signatureRequestId: string;\n      };\n      data: {\n        env?: XmtpEnv;\n        identifier: Identifier;\n        inboxId: string;\n        installationIds: Uint8Array[];\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"utils.revokeInstallations\";\n      id: string;\n      result: undefined;\n      data: {\n        env?: XmtpEnv;\n        signer: SafeSigner;\n        signatureRequestId: string;\n      };\n    }\n  | {\n      action: \"utils.inboxStateFromInboxIds\";\n      id: string;\n      result: SafeInboxState[];\n      data: {\n        inboxIds: string[];\n        env?: XmtpEnv;\n      };\n    };\n",
      "size_bytes": 1465
    },
    "apps/xmtp.chat/src/stores/profiles.ts": {
      "content": "import { useMemo } from \"react\";\nimport { createStore, useStore } from \"zustand\";\nimport { useShallow } from \"zustand/react/shallow\";\n\nexport type Platform = \"unknown\" | \"ens\" | \"basenames\";\n\nconst VALID_PLATFORMS: Platform[] = [\"ens\", \"basenames\"];\n\nexport type Profile = {\n  address: string;\n  avatar: string | null;\n  description: string | null;\n  displayName: string | null;\n  platform: Platform | null;\n  identity: string | null;\n};\n\nexport const createEmptyProfile = (address: string): Profile => ({\n  address,\n  avatar: null,\n  description: null,\n  displayName: null,\n  platform: null,\n  identity: null,\n});\n\n// alias types for clarity\ntype DisplayName = string;\ntype Address = string;\n\nexport type ProfilesState = {\n  profiles: Map<Address, Profile[]>;\n  names: Map<DisplayName, Address>;\n};\n\nexport type ProfilesActions = {\n  addProfile: (profile: Profile) => void;\n  addProfiles: (profiles: Profile[]) => void;\n  findProfiles: (addresses: string[]) => Map<string, Profile[]>;\n  getProfiles: (address: string) => Profile[];\n  hasProfile: (address: string) => boolean;\n  getProfilesByName: (name: string) => Profile[];\n  reset: () => void;\n};\n\nconst EMPTY_PROFILES: Profile[] = [];\n\nexport const profilesStore = createStore<ProfilesState & ProfilesActions>()(\n  (set, get, store) => ({\n    profiles: new Map(),\n    names: new Map(),\n    addProfile: (profile: Profile) => {\n      if (!profile.platform || !VALID_PLATFORMS.includes(profile.platform)) {\n        return;\n      }\n      const state = get();\n      const newNames = new Map(state.names);\n      const newProfiles = new Map(state.profiles);\n      const existingProfiles = state.profiles.get(profile.address) ?? [];\n      newProfiles.set(profile.address, [...existingProfiles, profile]);\n      if (profile.identity) {\n        newNames.set(profile.identity, profile.address);\n      }\n      set(() => ({\n        profiles: newProfiles,\n        names: newNames,\n      }));\n    },\n    addProfiles: (profiles: Profile[]) => {\n      const state = get();\n      const newNames = new Map(state.names);\n      const newProfiles = new Map(state.profiles);\n      for (const profile of profiles) {\n        if (!profile.platform || !VALID_PLATFORMS.includes(profile.platform)) {\n          continue;\n        }\n        const existingProfiles = state.profiles.get(profile.address) ?? [];\n        newProfiles.set(profile.address, [...existingProfiles, profile]);\n        if (profile.identity) {\n          newNames.set(profile.identity, profile.address);\n        }\n      }\n      set(() => ({\n        profiles: newProfiles,\n        names: newNames,\n      }));\n    },\n    findProfiles: (addresses: string[]) => {\n      const entries = addresses\n        .map((address) => [address, get().profiles.get(address)])\n        .filter(\n          (entry): entry is [string, Profile[]] => entry[1] !== undefined,\n        );\n      return new Map(entries);\n    },\n    getProfiles: (address: string) => {\n      return get().profiles.get(address) ?? EMPTY_PROFILES;\n    },\n    hasProfile: (address: string) => {\n      return get().profiles.has(address);\n    },\n    getProfilesByName: (name: string) => {\n      const address = get().names.get(name);\n      return address ? get().getProfiles(address) : EMPTY_PROFILES;\n    },\n    reset: () => {\n      set(store.getInitialState());\n    },\n  }),\n);\n\n/**\n * Combines multiple profiles into a single profile.\n * Optionally, provide a valid display name to use for the profile.\n *\n * The provided display name must exist in one of the profiles, or it will be\n * ignored.\n *\n * @param address - the address of the profile\n * @param profiles - the profiles to combine\n * @param displayName - optional display name to use for the profile\n * @returns the combined profile\n */\nexport const combineProfiles = (\n  address: string,\n  profiles: Profile[],\n  identity?: string,\n) => {\n  const forcedProfile = profiles.find(\n    (profile) => profile.identity === identity,\n  );\n  return profiles.reduce((profile, value) => {\n    return {\n      ...profile,\n      displayName: forcedProfile\n        ? forcedProfile.displayName\n        : (profile.displayName ?? value.displayName),\n      avatar: profile.avatar ?? value.avatar,\n      description: profile.description ?? value.description,\n      platform: profile.platform ?? value.platform,\n      identity: profile.identity ?? value.identity,\n    };\n  }, createEmptyProfile(address));\n};\n\nexport const useProfile = (address: string) => {\n  const profiles = useStore(\n    profilesStore,\n    useShallow((state) => state.getProfiles(address)),\n  );\n  const profile = useMemo(\n    () => combineProfiles(address, profiles),\n    [address, profiles],\n  );\n  return profile;\n};\n\nexport const useAllProfiles = () => {\n  return useStore(\n    profilesStore,\n    useShallow((state) => state.profiles),\n  );\n};\n\nexport const useProfileActions = () => {\n  const addProfile = useStore(profilesStore, (state) => state.addProfile);\n  const addProfiles = useStore(profilesStore, (state) => state.addProfiles);\n  const findProfiles = useStore(profilesStore, (state) => state.findProfiles);\n  const getProfiles = useStore(profilesStore, (state) => state.getProfiles);\n  const hasProfile = useStore(profilesStore, (state) => state.hasProfile);\n  const getProfilesByName = useStore(\n    profilesStore,\n    (state) => state.getProfilesByName,\n  );\n  const reset = useStore(profilesStore, (state) => state.reset);\n  return {\n    addProfile,\n    addProfiles,\n    findProfiles,\n    getProfiles,\n    hasProfile,\n    getProfilesByName,\n    reset,\n  };\n};\n",
      "size_bytes": 5533
    },
    "sdks/node-sdk/src/constants.ts": {
      "content": "/**\n * Pre-configured URLs for the XMTP network based on the environment\n *\n * @constant\n * @property {string} local - The local URL for the XMTP network\n * @property {string} dev - The development URL for the XMTP network\n * @property {string} production - The production URL for the XMTP network\n */\nexport const ApiUrls = {\n  local: \"http://localhost:5556\",\n  dev: \"https://grpc.dev.xmtp.network:443\",\n  production: \"https://grpc.production.xmtp.network:443\",\n} as const;\n\n/**\n * Pre-configured URLs for the XMTP history sync service based on the environment\n *\n * @constant\n * @property {string} local - The local URL for the XMTP history sync service\n * @property {string} dev - The development URL for the XMTP history sync service\n * @property {string} production - The production URL for the XMTP history sync service\n */\nexport const HistorySyncUrls = {\n  local: \"http://localhost:5558\",\n  dev: \"https://message-history.dev.ephemera.network\",\n  production: \"https://message-history.production.ephemera.network\",\n} as const;\n",
      "size_bytes": 1033
    },
    "apps/xmtp.chat/src/components/Conversation/ConversationMenu.tsx": {
      "content": "import { ActionIcon, Menu } from \"@mantine/core\";\nimport { useMemo } from \"react\";\nimport { useNavigate } from \"react-router\";\nimport { useClientPermissions } from \"@/hooks/useClientPermissions\";\nimport { IconDots } from \"@/icons/IconDots\";\n\nexport type ConversationMenuProps = {\n  conversationId: string;\n  type: \"group\" | \"dm\";\n  onSync: () => void;\n  disabled?: boolean;\n};\n\nexport const ConversationMenu: React.FC<ConversationMenuProps> = ({\n  conversationId,\n  type,\n  onSync,\n  disabled,\n}) => {\n  const navigate = useNavigate();\n  const clientPermissions = useClientPermissions(conversationId);\n  const canManageMembers = useMemo(() => {\n    return (\n      clientPermissions.canAddMembers || clientPermissions.canRemoveMembers\n    );\n  }, [clientPermissions]);\n  const canManageMetadata = useMemo(() => {\n    return (\n      clientPermissions.canChangeGroupName ||\n      clientPermissions.canChangeGroupDescription ||\n      clientPermissions.canChangeGroupImage\n    );\n  }, [clientPermissions]);\n\n  return (\n    <Menu shadow=\"md\" disabled={disabled} position=\"bottom-end\">\n      <Menu.Target>\n        <ActionIcon variant=\"default\">\n          <IconDots />\n        </ActionIcon>\n      </Menu.Target>\n      <Menu.Dropdown miw={200}>\n        <Menu.Label>Manage</Menu.Label>\n        <Menu.Item onClick={() => void navigate(\"manage/consent\")}>\n          Consent\n        </Menu.Item>\n        {type === \"group\" &&\n          (canManageMembers ||\n            canManageMetadata ||\n            clientPermissions.canChangePermissionsPolicy) && (\n            <>\n              {canManageMembers && (\n                <Menu.Item onClick={() => void navigate(\"manage/members\")}>\n                  Members\n                </Menu.Item>\n              )}\n              {canManageMetadata && (\n                <Menu.Item onClick={() => void navigate(\"manage/metadata\")}>\n                  Metadata\n                </Menu.Item>\n              )}\n              {clientPermissions.canChangePermissionsPolicy && (\n                <Menu.Item onClick={() => void navigate(\"manage/permissions\")}>\n                  Permissions\n                </Menu.Item>\n              )}\n            </>\n          )}\n        <Menu.Label>Actions</Menu.Label>\n        <Menu.Item onClick={onSync}>Sync</Menu.Item>\n      </Menu.Dropdown>\n    </Menu>\n  );\n};\n",
      "size_bytes": 2314
    },
    "apps/xmtp.chat/src/components/App/AppHeader.module.css": {
      "content": ".shell {\n  width: 100%;\n  padding: 16px 24px;\n  box-sizing: border-box;\n  background: rgba(4, 7, 15, 0.6);\n  box-shadow: 0 8px 32px rgba(10, 255, 241, 0.12);\n  backdrop-filter: blur(12px);\n}\n\n.brandGroup {\n  align-items: center;\n}\n\n.brandIcon {\n  width: 50px;\n  height: 50px;\n  border-radius: 30px;\n  background: linear-gradient(\n    135deg,\n    rgba(10, 255, 241, 0.35),\n    rgba(151, 114, 251, 0.4)\n  );\n  color: #9aabdb;\n  font-weight: 700;\n  letter-spacing: 0.08em;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 0.9rem;\n  box-shadow: 0 14px 30px rgba(10, 255, 241, 0.25);\n}\n\n.brandText {\n  margin-top: 2px;\n}\n\n.brandName {\n  font-size: 15px;\n  font-weight: 700;\n  color: #f4f6ff;\n}\n\n.brandTagline {\n  font-size: 0.7rem;\n  letter-spacing: 0.22em;\n  text-transform: uppercase;\n  color: rgba(226, 232, 240, 0.6);\n}\n\n.controls {\n  flex-wrap: nowrap;\n}\n\n.environment {\n  background: rgba(10, 255, 241, 0.12);\n  color: #0afff1;\n  border: 1px solid rgba(10, 255, 241, 0.3);\n  padding: 6px 10px;\n  display: inline-flex;\n  align-items: center;\n  gap: 6px;\n  box-shadow: 0 12px 24px rgba(10, 255, 241, 0.18);\n}\n\n.account {\n  padding: 10px 16px;\n  border-radius: 16px;\n  background: linear-gradient(\n    120deg,\n    rgba(10, 255, 241, 0.18),\n    rgba(151, 114, 251, 0.22)\n  );\n  border: 1px solid rgba(10, 255, 241, 0.25);\n  color: #e8f7ff;\n  font-weight: 600;\n  letter-spacing: 0.05em;\n  cursor: pointer;\n  transition:\n    transform 120ms ease,\n    box-shadow 120ms ease;\n  user-select: none;\n}\n\n.account:hover {\n  transform: translateY(-1px);\n  box-shadow: 0 16px 32px rgba(10, 255, 241, 0.25);\n}\n\n.account:focus-visible {\n  outline: 2px solid rgba(10, 255, 241, 0.6);\n  outline-offset: 2px;\n}\n\n.burger {\n  display: none;\n}\n\n@media screen and (max-width: 1080px) {\n  .burger {\n    display: block;\n  }\n\n  .brandName {\n    font-size: 1.1rem;\n  }\n\n  .brandTagline {\n    letter-spacing: 0.16em;\n  }\n}\n",
      "size_bytes": 1926
    },
    "sdks/browser-sdk/src/WorkerConversations.ts": {
      "content": "import {\n  ConversationType,\n  type ConsentState,\n  type Conversation,\n  type ConversationListItem,\n  type Conversations,\n  type Identifier,\n  type Message,\n} from \"@xmtp/wasm-bindings\";\nimport {\n  fromSafeCreateDmOptions,\n  fromSafeCreateGroupOptions,\n  fromSafeListConversationsOptions,\n  type HmacKeys,\n  type SafeCreateDmOptions,\n  type SafeCreateGroupOptions,\n  type SafeListConversationsOptions,\n} from \"@/utils/conversions\";\nimport type { StreamCallback } from \"@/utils/streams\";\nimport type { WorkerClient } from \"@/WorkerClient\";\nimport { WorkerConversation } from \"@/WorkerConversation\";\n\nexport class WorkerConversations {\n  #client: WorkerClient;\n\n  #conversations: Conversations;\n\n  constructor(client: WorkerClient, conversations: Conversations) {\n    this.#client = client;\n    this.#conversations = conversations;\n  }\n\n  async sync() {\n    return this.#conversations.sync();\n  }\n\n  async syncAll(consentStates?: ConsentState[]) {\n    return this.#conversations.syncAllConversations(consentStates);\n  }\n\n  getConversationById(id: string) {\n    try {\n      const group = this.#conversations.findGroupById(id);\n      // findGroupById will throw if group is not found\n      return new WorkerConversation(this.#client, group);\n    } catch {\n      return undefined;\n    }\n  }\n\n  getMessageById(id: string) {\n    try {\n      // findMessageById will throw if message is not found\n      return this.#conversations.findMessageById(id);\n    } catch {\n      return undefined;\n    }\n  }\n\n  getDmByInboxId(inboxId: string) {\n    try {\n      const group = this.#conversations.findDmByTargetInboxId(inboxId);\n      return new WorkerConversation(this.#client, group);\n    } catch {\n      return undefined;\n    }\n  }\n\n  list(options?: SafeListConversationsOptions) {\n    const groups = this.#conversations.list(\n      options ? fromSafeListConversationsOptions(options) : undefined,\n    ) as ConversationListItem[];\n    return groups.map(\n      (item) =>\n        new WorkerConversation(\n          this.#client,\n          item.conversation,\n          item.isCommitLogForked,\n        ),\n    );\n  }\n\n  listGroups(\n    options?: Omit<SafeListConversationsOptions, \"conversation_type\">,\n  ) {\n    const groups = this.#conversations.list(\n      fromSafeListConversationsOptions({\n        ...(options ?? {}),\n        conversationType: ConversationType.Group,\n      }),\n    ) as ConversationListItem[];\n    return groups.map(\n      (item) =>\n        new WorkerConversation(\n          this.#client,\n          item.conversation,\n          item.isCommitLogForked,\n        ),\n    );\n  }\n\n  listDms(options?: Omit<SafeListConversationsOptions, \"conversation_type\">) {\n    const groups = this.#conversations.list(\n      fromSafeListConversationsOptions({\n        ...(options ?? {}),\n        conversationType: ConversationType.Dm,\n      }),\n    ) as ConversationListItem[];\n    return groups.map(\n      (item) =>\n        new WorkerConversation(\n          this.#client,\n          item.conversation,\n          item.isCommitLogForked,\n        ),\n    );\n  }\n\n  newGroupOptimistic(options?: SafeCreateGroupOptions) {\n    const group = this.#conversations.createGroupOptimistic(\n      options ? fromSafeCreateGroupOptions(options) : undefined,\n    );\n    return new WorkerConversation(this.#client, group);\n  }\n\n  async newGroupWithIdentifiers(\n    identifiers: Identifier[],\n    options?: SafeCreateGroupOptions,\n  ) {\n    const group = await this.#conversations.createGroup(\n      identifiers,\n      options ? fromSafeCreateGroupOptions(options) : undefined,\n    );\n    return new WorkerConversation(this.#client, group);\n  }\n\n  async newGroup(inboxIds: string[], options?: SafeCreateGroupOptions) {\n    const group = await this.#conversations.createGroupByInboxIds(\n      inboxIds,\n      options ? fromSafeCreateGroupOptions(options) : undefined,\n    );\n    return new WorkerConversation(this.#client, group);\n  }\n\n  async newDmWithIdentifier(\n    identifier: Identifier,\n    options?: SafeCreateDmOptions,\n  ) {\n    const group = await this.#conversations.createDm(\n      identifier,\n      options ? fromSafeCreateDmOptions(options) : undefined,\n    );\n    return new WorkerConversation(this.#client, group);\n  }\n\n  async newDm(inboxId: string, options?: SafeCreateDmOptions) {\n    const group = await this.#conversations.createDmByInboxId(\n      inboxId,\n      options ? fromSafeCreateDmOptions(options) : undefined,\n    );\n    return new WorkerConversation(this.#client, group);\n  }\n\n  getHmacKeys() {\n    return this.#conversations.getHmacKeys() as HmacKeys;\n  }\n\n  stream(\n    callback: StreamCallback<Conversation>,\n    onFail: () => void,\n    conversationType?: ConversationType,\n  ) {\n    const on_conversation = (conversation: Conversation) => {\n      callback(null, conversation);\n    };\n    const on_error = (error: Error | null) => {\n      callback(error, undefined);\n    };\n    const on_close = () => {\n      onFail();\n    };\n    return this.#conversations.stream(\n      { on_conversation, on_error, on_close },\n      conversationType,\n    );\n  }\n\n  streamGroups(callback: StreamCallback<Conversation>, onFail: () => void) {\n    return this.stream(callback, onFail, ConversationType.Group);\n  }\n\n  streamDms(callback: StreamCallback<Conversation>, onFail: () => void) {\n    return this.stream(callback, onFail, ConversationType.Dm);\n  }\n\n  streamAllMessages(\n    callback: StreamCallback<Message>,\n    onFail: () => void,\n    conversationType?: ConversationType,\n    consentStates?: ConsentState[],\n  ) {\n    const on_message = (message: Message) => {\n      callback(null, message);\n    };\n    const on_error = (error: Error | null) => {\n      callback(error, undefined);\n    };\n    const on_close = () => {\n      onFail();\n    };\n    return this.#conversations.streamAllMessages(\n      { on_message, on_error, on_close },\n      conversationType,\n      consentStates,\n    );\n  }\n}\n",
      "size_bytes": 5874
    },
    "apps/xmtp.chat-api-service/src/helpers/web3.bio.ts": {
      "content": "import { escape } from \"node:querystring\";\nimport type { NSResponse, ProfileResponse } from \"web3bio-profile-kit/types\";\nimport { isValidEthereumAddress } from \"web3bio-profile-kit/utils\";\nimport { z } from \"zod\";\n\nconst WEB3BIO_API_ENDPOINT = \"https://api.web3.bio\";\nconst WEB3BIO_BATCH_SIZE = 30;\n\nconst validateName = (name: string) => {\n  return name.endsWith(\".eth\") || name.endsWith(\".base.eth\");\n};\n\nconst web3BioErrorResponseSchema = z.object({\n  status: z.number(),\n  statusText: z.string(),\n});\n\nconst isWeb3BioErrorResponse = (\n  response: unknown,\n): response is z.infer<typeof web3BioErrorResponseSchema> => {\n  return web3BioErrorResponseSchema.safeParse(response).success;\n};\n\nconst fetchFromWeb3Bio = async <T>(path: string) => {\n  const endpoint = `${WEB3BIO_API_ENDPOINT}${path}`;\n  try {\n    const response = await fetch(endpoint, {\n      method: \"GET\",\n      headers: {\n        \"X-API-KEY\": `Bearer ${process.env.WEB3BIO_API_KEY}`,\n      },\n    });\n\n    if (!response.ok) {\n      return {\n        status: response.status,\n        statusText: response.statusText,\n      };\n    }\n\n    return (await response.json()) as T;\n  } catch {\n    return null;\n  }\n};\n\nexport const fetchProfiles = async (input: string[]) => {\n  // validate input\n  const identities = input.filter(isValidNameInput);\n\n  // if no identities, return empty array\n  if (identities.length === 0) {\n    return [];\n  }\n\n  const escapedIdentities = escape(JSON.stringify(identities));\n  return (\n    (await fetchFromWeb3Bio<ProfileResponse[]>(\n      `/profile/batch/${escapedIdentities}`,\n    )) ?? []\n  );\n};\n\nexport const batchFetchProfiles = async (input: string[]) => {\n  // validate input\n  const identities = input.filter(isValidNameInput);\n\n  // if no identities, return empty array\n  if (identities.length === 0) {\n    return [];\n  }\n\n  const profiles: ProfileResponse[] = [];\n\n  // fetch profiles in batches\n  while (identities.length > 0) {\n    const batch = identities.splice(0, WEB3BIO_BATCH_SIZE);\n    const batchProfiles = await fetchProfiles(batch);\n    if (isWeb3BioErrorResponse(batchProfiles)) {\n      console.error(\n        `Error fetching profiles: ${batchProfiles.status} ${batchProfiles.statusText}`,\n      );\n      continue;\n    }\n    profiles.push(...batchProfiles);\n  }\n\n  return profiles;\n};\n\nexport const fetchProfile = async (identity: string) => {\n  if (!identity) {\n    return null;\n  }\n  return await fetchFromWeb3Bio<ProfileResponse>(\n    `/profile/${escape(identity)}`,\n  );\n};\n\nexport const fetchProfilesFromName = async (name: string) => {\n  if (!name || !validateName(name)) {\n    return null;\n  }\n  const response = await fetchFromWeb3Bio<NSResponse[]>(`/ns/${escape(name)}`);\n  if (isWeb3BioErrorResponse(response)) {\n    console.error(\n      `Error fetching address: ${response.status} ${response.statusText}`,\n    );\n    return null;\n  }\n  return response;\n};\n\nexport const isValidNameInput = (input: string) => {\n  const [type, address] = input.split(\",\");\n  return (\n    (type === \"ens\" || type === \"basenames\") && isValidEthereumAddress(address)\n  );\n};\n\nexport const fetchNames = async (input: string[]) => {\n  // validate input\n  const identities = input.filter(isValidNameInput);\n\n  // if no identities, return empty array\n  if (identities.length === 0) {\n    return [];\n  }\n\n  const escapedNames = escape(JSON.stringify(identities));\n  return (\n    (await fetchFromWeb3Bio<NSResponse[]>(`/ns/batch/${escapedNames}`)) ?? []\n  );\n};\n\nexport const batchFetchNames = async (input: string[]) => {\n  // validate input\n  const identities = input.filter(isValidNameInput);\n\n  // if no identities, return empty array\n  if (identities.length === 0) {\n    return [];\n  }\n\n  const names: NSResponse[] = [];\n\n  // fetch names in batches\n  while (identities.length > 0) {\n    const batch = identities.splice(0, WEB3BIO_BATCH_SIZE);\n    const batchNames = await fetchNames(batch);\n    if (isWeb3BioErrorResponse(batchNames)) {\n      console.error(\n        `Error fetching names: ${batchNames.status} ${batchNames.statusText}`,\n      );\n      continue;\n    }\n    names.push(...batchNames);\n  }\n\n  return names;\n};\n",
      "size_bytes": 4128
    },
    "apps/xmtp.chat/src/layouts/ContentLayout.tsx": {
      "content": "import {\n  Box,\n  Group,\n  LoadingOverlay,\n  ScrollArea,\n  Stack,\n  Text,\n  type MantineStyleProps,\n} from \"@mantine/core\";\nimport classes from \"./ContentLayout.module.css\";\n\nexport type ContentLayoutProps = React.PropsWithChildren<{\n  aside?: React.ReactNode;\n  asideOpened?: boolean;\n  footer?: React.ReactNode;\n  headerActions?: React.ReactNode;\n  loading?: boolean;\n  maxHeight?: MantineStyleProps[\"mah\"];\n  title?: React.ReactNode;\n  withBorders?: boolean;\n  withScrollArea?: boolean;\n  withScrollAreaPadding?: boolean;\n  withScrollFade?: boolean;\n  className?: string;\n  headerClassName?: string;\n  contentClassName?: string;\n  footerClassName?: string;\n  asideClassName?: string;\n}>;\n\nexport type ContentLayoutHeaderProps = Pick<\n  ContentLayoutProps,\n  \"title\" | \"headerActions\" | \"withBorders\" | \"headerClassName\"\n>;\n\nexport const ContentLayoutHeader: React.FC<ContentLayoutHeaderProps> = ({\n  headerActions,\n  title,\n  withBorders,\n  headerClassName,\n}) => {\n  const headerClassNames = [\n    classes.header,\n    withBorders && classes.withBorders,\n    headerClassName,\n  ].filter(Boolean);\n  return (\n    <Group\n      align=\"center\"\n      gap=\"xs\"\n      p=\"md\"\n      wrap=\"nowrap\"\n      className={headerClassNames.join(\" \")}>\n      {typeof title === \"string\" ? (\n        <Text fw={700} size=\"lg\" truncate>\n          {title}\n        </Text>\n      ) : (\n        title\n      )}\n      {headerActions && (\n        <Box className={classes.headerActions}>{headerActions}</Box>\n      )}\n    </Group>\n  );\n};\n\nexport type ContentLayoutContentProps = Pick<\n  ContentLayoutProps,\n  | \"children\"\n  | \"footer\"\n  | \"maxHeight\"\n  | \"withBorders\"\n  | \"withScrollArea\"\n  | \"withScrollAreaPadding\"\n  | \"withScrollFade\"\n  | \"className\"\n>;\n\nexport const ContentLayoutContent: React.FC<ContentLayoutContentProps> = ({\n  children,\n  footer,\n  maxHeight,\n  withBorders,\n  withScrollArea,\n  withScrollAreaPadding,\n  withScrollFade,\n  className,\n}) => {\n  const contentClassNames = [\n    classes.content,\n    withScrollFade && classes.contentScrollFade,\n    !footer && classes.noFooter,\n    withBorders && classes.withBorders,\n    className,\n  ].filter(Boolean);\n  return (\n    <Box className={contentClassNames.join(\" \")}>\n      {withScrollArea ? (\n        <ScrollArea\n          type=\"scroll\"\n          className={classes.scrollArea}\n          px={withScrollAreaPadding ? \"md\" : 0}>\n          <Box mah={maxHeight}>{children}</Box>\n        </ScrollArea>\n      ) : (\n        <>{children}</>\n      )}\n    </Box>\n  );\n};\n\nexport type ContentLayoutFooterProps = Pick<\n  ContentLayoutProps,\n  \"footer\" | \"withBorders\" | \"footerClassName\"\n>;\n\nexport const ContentLayoutFooter: React.FC<ContentLayoutFooterProps> = ({\n  footer,\n  withBorders,\n  footerClassName,\n}) => {\n  const footerClassNames = [\n    classes.footer,\n    withBorders && classes.withBorders,\n    footerClassName,\n  ].filter(Boolean);\n  return (\n    <Group\n      gap=\"xs\"\n      align=\"center\"\n      className={footerClassNames.join(\" \")}\n      wrap=\"nowrap\">\n      {footer}\n    </Group>\n  );\n};\n\nexport const ContentLayout: React.FC<ContentLayoutProps> = ({\n  aside,\n  asideOpened,\n  children,\n  footer,\n  headerActions,\n  loading = false,\n  maxHeight,\n  title,\n  withBorders = true,\n  withScrollArea = true,\n  withScrollAreaPadding = true,\n  withScrollFade = true,\n  className,\n  headerClassName,\n  contentClassName,\n  footerClassName,\n  asideClassName,\n}) => {\n  const rootClassNames = [classes.root, className].filter(Boolean);\n  const asideClassNames = [\n    classes.aside,\n    asideOpened && classes.showAside,\n    asideClassName,\n  ].filter(Boolean);\n  return (\n    <Stack className={rootClassNames.join(\" \")} gap={0}>\n      <LoadingOverlay visible={loading} />\n      {(title || headerActions) && (\n        <ContentLayoutHeader\n          title={title}\n          headerActions={headerActions}\n          withBorders={withBorders}\n          headerClassName={headerClassName}\n        />\n      )}\n      <ContentLayoutContent\n        withScrollArea={withScrollArea}\n        withScrollAreaPadding={withScrollAreaPadding}\n        maxHeight={maxHeight}\n        withScrollFade={withScrollFade}\n        footer={footer}\n        withBorders={withBorders}\n        className={contentClassName}>\n        {children}\n      </ContentLayoutContent>\n      {aside && <Box className={asideClassNames.join(\" \")}>{aside}</Box>}\n      {footer && (\n        <ContentLayoutFooter\n          footer={footer}\n          withBorders={withBorders}\n          footerClassName={footerClassName}\n        />\n      )}\n    </Stack>\n  );\n};\n",
      "size_bytes": 4549
    },
    "apps/xmtp.chat-api-service/src/middleware/rateLimit.ts": {
      "content": "import { rateLimit } from \"express-rate-limit\";\n\n// limit API to 300 requests per 5 minutes\nexport const rateLimitMiddleware = rateLimit({\n  windowMs: 5 * 60 * 1000, // 5 minutes\n  limit: 300,\n  legacyHeaders: false,\n  standardHeaders: \"draft-8\",\n});\n",
      "size_bytes": 251
    },
    "apps/xmtp.chat/src/components/App/ConnectedAddress.module.css": {
      "content": ".wrapper {\n  flex-wrap: wrap;\n  min-width: 0;\n}\n\n.address {\n  display: inline-block;\n  max-width: 12rem;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-variant-numeric: tabular-nums;\n}\n\n@media (max-width: 480px) {\n  .address {\n    max-width: 8.5rem;\n  }\n}\n\n@media (min-width: 600px) {\n  .wrapper {\n    flex-wrap: nowrap;\n  }\n}\n",
      "size_bytes": 357
    },
    "apps/xmtp.chat/src/components/App/AccountCard.module.css": {
      "content": ".root {\n  cursor: pointer;\n  background-color: var(--mantine-color-body);\n}\n\n.root:hover {\n  background-color: var(--mantine-primary-color-light-hover);\n}\n\n.disabled {\n  cursor: not-allowed;\n  background-color: var(--mantine-color-body);\n}\n\n.disabled:hover {\n  background-color: var(--mantine-color-body);\n}\n\n.selected {\n  cursor: default;\n  background-color: var(--mantine-color-default-hover);\n}\n\n.selected:hover {\n  background-color: var(--mantine-color-default-hover);\n}\n\n.selected.disabled {\n  cursor: not-allowed;\n  background-color: inherit;\n}\n",
      "size_bytes": 551
    },
    "apps/xmtp.chat/src/components/InboxTools/InboxTools.tsx": {
      "content": "import {\n  Button,\n  Group,\n  Stack,\n  Stepper,\n  Text,\n  TextInput,\n  Title,\n} from \"@mantine/core\";\nimport { Client, type SafeInstallation, type Signer } from \"@xmtp/browser-sdk\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport { Outlet } from \"react-router\";\nimport { useSignMessage } from \"wagmi\";\nimport { ConnectedAddress } from \"@/components/App/ConnectedAddress\";\nimport { WalletConnect } from \"@/components/App/WalletConnect\";\nimport { InstallationTable } from \"@/components/InboxTools/InstallationTable\";\nimport { NetworkSelect } from \"@/components/InboxTools/NetworkSelect\";\nimport { createEOASigner, createSCWSigner } from \"@/helpers/createSigner\";\nimport { isValidInboxId } from \"@/helpers/strings\";\nimport { useConnectWallet } from \"@/hooks/useConnectWallet\";\nimport { useEphemeralSigner } from \"@/hooks/useEphemeralSigner\";\nimport { useMemberId } from \"@/hooks/useMemberId\";\nimport { useSettings } from \"@/hooks/useSettings\";\nimport { ContentLayout } from \"@/layouts/ContentLayout\";\n\nexport const InboxTools: React.FC = () => {\n  const {\n    account,\n    address,\n    isConnected,\n    disconnect,\n    loading: walletLoading,\n  } = useConnectWallet();\n  const { address: ephemeralAddress, signer: ephemeralSigner } =\n    useEphemeralSigner();\n  const { signMessageAsync } = useSignMessage();\n  const {\n    inboxId,\n    memberId,\n    setMemberId,\n    error: memberIdError,\n  } = useMemberId();\n  const [installations, setInstallations] = useState<SafeInstallation[]>([]);\n  const [selectedInstallationIds, setSelectedInstallationIds] = useState<\n    string[]\n  >([]);\n  const [loading, setLoading] = useState(false);\n  const {\n    environment,\n    useSCW,\n    ephemeralAccountEnabled,\n    setEphemeralAccountEnabled,\n  } = useSettings();\n  const [active, setActive] = useState(0);\n\n  const handleFindInstallations = useCallback(async () => {\n    if (!isValidInboxId(inboxId)) {\n      return;\n    }\n    setLoading(true);\n    setInstallations([]);\n    setSelectedInstallationIds([]);\n    try {\n      const inboxState = await Client.inboxStateFromInboxIds(\n        [inboxId],\n        environment,\n      );\n      setInstallations(\n        inboxState[0].installations.sort(\n          (a, b) =>\n            Number(b.clientTimestampNs ?? 0) - Number(a.clientTimestampNs ?? 0),\n        ),\n      );\n    } catch (error) {\n      console.error(error);\n    } finally {\n      setLoading(false);\n    }\n  }, [inboxId, environment]);\n\n  const handleRevokeInstallations = useCallback(\n    async (installationIds: Uint8Array[]) => {\n      let signer: Signer;\n      if (ephemeralAccountEnabled) {\n        if (!ephemeralAddress) {\n          console.error(\"Ephemeral wallet not connected\");\n          return;\n        }\n        signer = ephemeralSigner;\n      } else {\n        if (!address) {\n          console.error(\"Wallet not connected\");\n          return;\n        }\n        if (useSCW && !account.chainId) {\n          console.error(\"Smart contract wallet chain ID not set\");\n          return;\n        }\n        signer = useSCW\n          ? createSCWSigner(\n              address,\n              (message: string) => signMessageAsync({ message }),\n              account.chainId,\n            )\n          : createEOASigner(address, (message: string) =>\n              signMessageAsync({ message }),\n            );\n      }\n      setLoading(true);\n      try {\n        await Client.revokeInstallations(\n          signer,\n          inboxId,\n          installationIds,\n          environment,\n        );\n      } finally {\n        setLoading(false);\n      }\n      void handleFindInstallations();\n    },\n    [\n      environment,\n      address,\n      account.chainId,\n      useSCW,\n      signMessageAsync,\n      inboxId,\n      handleFindInstallations,\n      ephemeralAccountEnabled,\n      ephemeralAddress,\n    ],\n  );\n\n  const handleDisconnectWallet = useCallback(() => {\n    if (isConnected) {\n      disconnect();\n    } else {\n      setEphemeralAccountEnabled(false);\n    }\n    setMemberId(\"\");\n    setInstallations([]);\n    setSelectedInstallationIds([]);\n  }, [\n    isConnected,\n    disconnect,\n    setEphemeralAccountEnabled,\n    setMemberId,\n    setInstallations,\n    setSelectedInstallationIds,\n  ]);\n\n  useEffect(() => {\n    if (!isValidInboxId(inboxId)) {\n      setInstallations([]);\n      setSelectedInstallationIds([]);\n    }\n  }, [inboxId]);\n\n  useEffect(() => {\n    setInstallations([]);\n    setSelectedInstallationIds([]);\n  }, [environment]);\n\n  useEffect(() => {\n    if (isConnected || ephemeralAccountEnabled) {\n      setActive(1);\n    } else {\n      setActive(0);\n    }\n  }, [isConnected, ephemeralAccountEnabled]);\n\n  return (\n    <>\n      <ContentLayout\n        loading={loading}\n        title={\n          <Group justify=\"space-between\" align=\"center\" flex={1}>\n            <Text size=\"lg\" fw={700} c=\"text.primary\">\n              Installation management\n            </Text>\n          </Group>\n        }\n        footer={\n          <Group justify=\"flex-end\" p=\"md\" flex={1}>\n            {!(address || ephemeralAddress) && (\n              <Text size=\"sm\" c=\"dimmed\">\n                Wallet connection required\n              </Text>\n            )}\n            <Button\n              disabled={selectedInstallationIds.length === 0}\n              onClick={() => {\n                const installationBytes = installations\n                  .filter((installation) =>\n                    selectedInstallationIds.includes(installation.id),\n                  )\n                  .map((installation) => installation.bytes);\n                void handleRevokeInstallations(installationBytes);\n              }}>\n              Revoke installations\n            </Button>\n          </Group>\n        }>\n        <Stepper active={active} onStepClick={setActive} mt=\"md\">\n          <Stepper.Step\n            label=\"Connect your wallet\"\n            allowStepSelect={false}\n            loading={walletLoading}>\n            <WalletConnect />\n          </Stepper.Step>\n          <Stepper.Step label=\"Manage installations\" allowStepSelect={false}>\n            <Stack gap=\"md\" py=\"md\">\n              <Group justify=\"space-between\" align=\"center\">\n                <ConnectedAddress\n                  size=\"sm\"\n                  address={address ?? ephemeralAddress}\n                  onClick={handleDisconnectWallet}\n                />\n                <NetworkSelect />\n              </Group>\n              <Stack gap=\"xs\" mb=\"md\">\n                <Group justify=\"space-between\" align=\"center\">\n                  <Text size=\"sm\" pl={4}>\n                    Enter an address or inbox ID\n                  </Text>\n                  {memberIdError && (\n                    <Text c=\"red.7\" size=\"sm\">\n                      {memberIdError}\n                    </Text>\n                  )}\n                </Group>\n                <TextInput\n                  size=\"sm\"\n                  error={!!memberIdError}\n                  value={memberId}\n                  onChange={(event) => {\n                    setMemberId(event.target.value);\n                  }}\n                />\n                <Group justify=\"space-between\" align=\"center\">\n                  <Button\n                    variant=\"default\"\n                    onClick={() => {\n                      setMemberId(address ?? ephemeralAddress);\n                    }}>\n                    Use wallet address\n                  </Button>\n                  <Button\n                    disabled={!isValidInboxId(inboxId)}\n                    onClick={() => {\n                      void handleFindInstallations();\n                    }}>\n                    Find installations\n                  </Button>\n                </Group>\n              </Stack>\n              <Title order={4}>Installations</Title>\n              <Stack gap=\"md\">\n                {installations.length === 0 && (\n                  <Text>No installations found</Text>\n                )}\n                {installations.length > 0 && (\n                  <InstallationTable\n                    installations={installations}\n                    selectedInstallationIds={selectedInstallationIds}\n                    setSelectedInstallationIds={setSelectedInstallationIds}\n                  />\n                )}\n              </Stack>\n            </Stack>\n          </Stepper.Step>\n        </Stepper>\n      </ContentLayout>\n      <Outlet />\n    </>\n  );\n};\n",
      "size_bytes": 8363
    },
    "sdks/node-sdk/src/utils/version.ts": {
      "content": "import bindingsVersion from \"@xmtp/node-bindings/version.json\" with { type: \"json\" };\n\nexport const version = `${bindingsVersion.branch}@${bindingsVersion.version} (${bindingsVersion.date})`;\n",
      "size_bytes": 192
    },
    "content-types/content-type-reaction/src/Reaction.test.ts": {
      "content": "import type { EncodedContent } from \"@xmtp/content-type-primitives\";\nimport { Client, IdentifierKind, type Signer } from \"@xmtp/node-sdk\";\nimport { createWalletClient, http, toBytes } from \"viem\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { sepolia } from \"viem/chains\";\nimport {\n  ContentTypeReaction,\n  ReactionCodec,\n  type LegacyReactionParameters,\n  type Reaction,\n} from \"./Reaction\";\n\nexport const createSigner = (): Signer => {\n  const account = privateKeyToAccount(generatePrivateKey());\n  const wallet = createWalletClient({\n    account,\n    chain: sepolia,\n    transport: http(),\n  });\n  return {\n    type: \"EOA\",\n    getIdentifier: () => ({\n      identifierKind: IdentifierKind.Ethereum,\n      identifier: account.address.toLowerCase(),\n    }),\n    signMessage: async (message: string) => {\n      const signature = await wallet.signMessage({\n        message,\n      });\n      return toBytes(signature);\n    },\n  };\n};\n\ndescribe(\"ReactionContentType\", () => {\n  it(\"has the right content type\", () => {\n    expect(ContentTypeReaction.authorityId).toBe(\"xmtp.org\");\n    expect(ContentTypeReaction.typeId).toBe(\"reaction\");\n    expect(ContentTypeReaction.versionMajor).toBe(1);\n    expect(ContentTypeReaction.versionMinor).toBe(0);\n  });\n\n  it(\"supports canonical and legacy form\", () => {\n    const codec = new ReactionCodec();\n\n    // This is how clients send reactions now.\n    const canonicalEncoded: EncodedContent<LegacyReactionParameters> = {\n      parameters: {\n        action: \"added\",\n        reference: \"abc123\",\n        schema: \"shortcode\",\n        encoding: \"UTF-8\",\n      },\n      type: ContentTypeReaction,\n      content: new TextEncoder().encode(\n        JSON.stringify({\n          action: \"added\",\n          content: \"smile\",\n          reference: \"abc123\",\n          schema: \"shortcode\",\n        }),\n      ),\n    };\n\n    // Previously, some clients sent reactions like this.\n    // So we test here to make sure we can still decode them.\n    const legacyEncoded: EncodedContent<LegacyReactionParameters> = {\n      type: ContentTypeReaction,\n      parameters: {\n        action: \"added\",\n        reference: \"abc123\",\n        schema: \"shortcode\",\n        encoding: \"UTF-8\",\n      },\n      content: new TextEncoder().encode(\"smile\"),\n    };\n\n    const canonical = codec.decode(canonicalEncoded);\n    const legacy = codec.decode(legacyEncoded);\n    expect(canonical.action).toBe(\"added\");\n    expect(legacy.action).toBe(\"added\");\n    expect(canonical.content).toBe(\"smile\");\n    expect(legacy.content).toBe(\"smile\");\n    expect(canonical.reference).toBe(\"abc123\");\n    expect(legacy.reference).toBe(\"abc123\");\n    expect(canonical.schema).toBe(\"shortcode\");\n    expect(legacy.schema).toBe(\"shortcode\");\n  });\n\n  it(\"can send a reaction\", async () => {\n    const signer1 = createSigner();\n    const client1 = await Client.create(signer1, {\n      codecs: [new ReactionCodec()],\n      env: \"local\",\n    });\n\n    const signer2 = createSigner();\n    const client2 = await Client.create(signer2, {\n      codecs: [new ReactionCodec()],\n      env: \"local\",\n    });\n\n    const dm = await client1.conversations.newDm(client2.inboxId);\n\n    const originalMessage = await dm.send(\"test\");\n\n    const reaction: Reaction = {\n      action: \"added\",\n      content: \"smile\",\n      reference: originalMessage,\n      schema: \"shortcode\",\n    };\n\n    await dm.send(reaction, ContentTypeReaction);\n\n    await client2.conversations.sync();\n    const dms = client2.conversations.listDms();\n\n    expect(dms.length).toBe(1);\n\n    await dms[0].sync();\n    const messages = await dms[0].messages();\n    expect(messages.length).toBe(3);\n\n    const reactionMessage = messages[2];\n    const messageContent = reactionMessage.content as Reaction;\n    expect(messageContent.action).toBe(\"added\");\n    expect(messageContent.content).toBe(\"smile\");\n    expect(messageContent.reference).toBe(originalMessage);\n    expect(messageContent.schema).toBe(\"shortcode\");\n  });\n\n  it(\"has a proper shouldPush value\", () => {\n    const codec = new ReactionCodec();\n    expect(codec.shouldPush()).toBe(false);\n  });\n});\n",
      "size_bytes": 4130
    },
    "sdks/browser-sdk/test/Utils.test.ts": {
      "content": "import { v4 } from \"uuid\";\nimport { describe, expect, it } from \"vitest\";\nimport { Utils } from \"@/Utils\";\nimport {\n  createRegisteredClient,\n  createSigner,\n  createUser,\n} from \"@test/helpers\";\n\ndescribe(\"Utils\", () => {\n  it(\"should generate inbox id\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const utils = new Utils();\n    const inboxId = await utils.generateInboxId(await signer.getIdentifier());\n    expect(inboxId).toBeDefined();\n  });\n\n  it(\"should get inbox id for address\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const utils = new Utils();\n    const inboxId = await utils.getInboxIdForIdentifier(\n      await signer.getIdentifier(),\n      \"local\",\n    );\n    expect(inboxId).toBe(client.inboxId);\n  });\n\n  it(\"should revoke installations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client3 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    const inboxState = await client3.preferences.inboxState(true);\n    expect(inboxState.installations.length).toBe(3);\n\n    const installationIds = inboxState.installations.map((i) => i.id);\n    expect(installationIds).toContain(client.installationId);\n    expect(installationIds).toContain(client2.installationId);\n    expect(installationIds).toContain(client3.installationId);\n\n    const utils = new Utils();\n    await utils.revokeInstallations(\n      signer,\n      client.inboxId!,\n      [client2.installationIdBytes!, client3.installationIdBytes!],\n      \"local\",\n    );\n\n    const inboxState2 = await client.preferences.inboxState(true);\n    expect(inboxState2.installations.length).toBe(1);\n    expect(inboxState2.installations[0].id).toBe(client.installationId);\n  });\n\n  it(\"should get inbox state from inbox ids\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const utils = new Utils();\n    const inboxState = await utils.inboxStateFromInboxIds(\n      [client.inboxId!],\n      \"local\",\n    );\n    expect(inboxState.length).toBe(1);\n    expect(inboxState[0].inboxId).toBe(client.inboxId);\n    expect(inboxState[0].identifiers).toEqual([await signer.getIdentifier()]);\n  });\n});\n",
      "size_bytes": 2538
    },
    "apps/xmtp.chat/src/contexts/XMTPContext.tsx": {
      "content": "import {\n  Client,\n  type ClientOptions,\n  type ExtractCodecContentTypes,\n  type Signer,\n} from \"@xmtp/browser-sdk\";\nimport { MarkdownCodec } from \"@xmtp/content-type-markdown\";\nimport { ReactionCodec } from \"@xmtp/content-type-reaction\";\nimport { ReadReceiptCodec } from \"@xmtp/content-type-read-receipt\";\nimport { RemoteAttachmentCodec } from \"@xmtp/content-type-remote-attachment\";\nimport { ReplyCodec } from \"@xmtp/content-type-reply\";\nimport { TransactionReferenceCodec } from \"@xmtp/content-type-transaction-reference\";\nimport { WalletSendCallsCodec } from \"@xmtp/content-type-wallet-send-calls\";\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { ActionsCodec } from \"@/content-types/Actions\";\nimport { IntentCodec } from \"@/content-types/Intent\";\nimport { useActions } from \"@/stores/inbox/hooks\";\n\nexport type ContentTypes = ExtractCodecContentTypes<\n  [\n    ReactionCodec,\n    ReplyCodec,\n    RemoteAttachmentCodec,\n    TransactionReferenceCodec,\n    WalletSendCallsCodec,\n    ReadReceiptCodec,\n    ActionsCodec,\n    IntentCodec,\n    MarkdownCodec,\n  ]\n>;\n\nexport type InitializeClientOptions = {\n  dbEncryptionKey?: Uint8Array;\n  env?: ClientOptions[\"env\"];\n  loggingLevel?: ClientOptions[\"loggingLevel\"];\n  signer: Signer;\n};\n\nexport type XMTPContextValue = {\n  /**\n   * The XMTP client instance\n   */\n  client?: Client<ContentTypes>;\n  /**\n   * Set the XMTP client instance\n   */\n  setClient: React.Dispatch<\n    React.SetStateAction<Client<ContentTypes> | undefined>\n  >;\n  initialize: (\n    options: InitializeClientOptions,\n  ) => Promise<Client<ContentTypes> | undefined>;\n  initializing: boolean;\n  error: Error | null;\n  disconnect: () => void;\n};\n\nexport const XMTPContext = createContext<XMTPContextValue>({\n  setClient: () => {},\n  initialize: () => Promise.reject(new Error(\"XMTPProvider not available\")),\n  initializing: false,\n  error: null,\n  disconnect: () => {},\n});\n\nexport type XMTPProviderProps = React.PropsWithChildren & {\n  /**\n   * Initial XMTP client instance\n   */\n  client?: Client<ContentTypes>;\n};\n\nexport const XMTPProvider: React.FC<XMTPProviderProps> = ({\n  children,\n  client: initialClient,\n}) => {\n  const { reset } = useActions();\n  const [client, setClient] = useState<Client<ContentTypes> | undefined>(\n    initialClient,\n  );\n\n  const [initializing, setInitializing] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  // client is initializing\n  const initializingRef = useRef(false);\n\n  /**\n   * Initialize an XMTP client\n   */\n  const initialize = useCallback(\n    async ({\n      dbEncryptionKey,\n      env,\n      loggingLevel,\n      signer,\n    }: InitializeClientOptions) => {\n      // only initialize a client if one doesn't already exist\n      if (!client) {\n        // if the client is already initializing, don't do anything\n        if (initializingRef.current) {\n          return undefined;\n        }\n\n        // flag the client as initializing\n        initializingRef.current = true;\n\n        // reset error state\n        setError(null);\n        // reset initializing state\n        setInitializing(true);\n\n        let xmtpClient: Client<ContentTypes>;\n\n        try {\n          // create a new XMTP client\n          xmtpClient = await Client.create(signer, {\n            env,\n            loggingLevel,\n            dbEncryptionKey,\n            appVersion: \"xmtp.chat/0\",\n            codecs: [\n              new ReactionCodec(),\n              new ReplyCodec(),\n              new RemoteAttachmentCodec(),\n              new TransactionReferenceCodec(),\n              new WalletSendCallsCodec(),\n              new ReadReceiptCodec(),\n              new ActionsCodec(),\n              new IntentCodec(),\n              new MarkdownCodec(),\n            ],\n          });\n          setClient(xmtpClient);\n        } catch (e) {\n          setClient(undefined);\n          setError(e as Error);\n          // re-throw error for upstream consumption\n          throw e;\n        } finally {\n          initializingRef.current = false;\n          setInitializing(false);\n        }\n\n        return xmtpClient;\n      }\n      return client;\n    },\n    [client],\n  );\n\n  const disconnect = useCallback(() => {\n    if (client) {\n      client.close();\n      setClient(undefined);\n      reset();\n    }\n  }, [client, setClient]);\n\n  // memo-ize the context value to prevent unnecessary re-renders\n  const value = useMemo(\n    () => ({\n      client,\n      setClient,\n      initialize,\n      initializing,\n      error,\n      disconnect,\n    }),\n    [client, initialize, initializing, error, disconnect],\n  );\n\n  return <XMTPContext.Provider value={value}>{children}</XMTPContext.Provider>;\n};\n\nexport const useXMTP = () => {\n  return useContext(XMTPContext);\n};\n\nexport const useClient = () => {\n  const { client } = useXMTP();\n  if (!client) {\n    throw new Error(\"useClient: XMTP client not initialized\");\n  }\n  return client;\n};\n",
      "size_bytes": 4948
    },
    "apps/xmtp.chat/src/components/App/Welcome.tsx": {
      "content": "import { Paper, Stack, Text, useMatches } from \"@mantine/core\";\nimport { Connect } from \"@/components/App/Connect\";\n\nexport const Welcome = () => {\n  const px = useMatches({\n    base: \"6%\",\n    sm: \"10%\",\n    md: \"18%\",\n  });\n\n  return (\n    <Stack\n      gap=\"xl\"\n      py={48}\n      px={px}\n      style={{\n        maxWidth: 940,\n        width: \"100%\",\n        margin: \"0 auto\",\n      }}\n      align=\"center\"\n      justify=\"center\">\n      <Paper\n        withBorder\n        radius=\"xl\"\n        shadow=\"sm\"\n        p={{ base: \"lg\", sm: \"xl\" }}\n        style={{ background: \"rgba(10, 13, 25, 0.9)\" }}>\n        <Stack gap=\"lg\">\n          <Stack gap={6}>\n            <Text fw={600} size=\"sm\" c=\"var(--mantine-color-teal-3)\">\n              Connect your wallet\n            </Text>\n            <Text c=\"dimmed\" size=\"sm\">\n              Authorize your wallet to unlock the MumbleChat toolkit.\n            </Text>\n          </Stack>\n          <Connect />\n          <Text size=\"xs\" c=\"dimmed\" ta=\"center\">\n            By connecting, you agree to the MumbleChat Terms of Service and Privacy Policy.\n          </Text>\n        </Stack>\n      </Paper>\n    </Stack>\n  );\n};\n",
      "size_bytes": 1158
    },
    "apps/xmtp.chat/src/components/Conversation/Metadata.tsx": {
      "content": "import { Group, Stack, Text, Textarea, TextInput } from \"@mantine/core\";\nimport { Group as XmtpGroup, type Conversation } from \"@xmtp/browser-sdk\";\nimport { useEffect, useState } from \"react\";\nimport { type ClientPermissions } from \"@/hooks/useClientPermissions\";\n\ntype MetadataProps = {\n  conversation?: Conversation;\n  clientPermissions?: ClientPermissions;\n  onNameChange: (name: string) => void;\n  onDescriptionChange: (description: string) => void;\n  onImageUrlChange: (imageUrl: string) => void;\n};\n\nexport const Metadata: React.FC<MetadataProps> = ({\n  conversation,\n  clientPermissions,\n  onNameChange,\n  onDescriptionChange,\n  onImageUrlChange,\n}) => {\n  const [name, setName] = useState(\"\");\n  const [description, setDescription] = useState(\"\");\n  const [imageUrl, setImageUrl] = useState(\"\");\n\n  useEffect(() => {\n    if (conversation instanceof XmtpGroup) {\n      setName(conversation.name ?? \"\");\n      setDescription(conversation.description ?? \"\");\n      setImageUrl(conversation.imageUrl ?? \"\");\n    }\n  }, [conversation?.id]);\n\n  useEffect(() => {\n    onNameChange(name);\n  }, [name, onNameChange]);\n\n  useEffect(() => {\n    onDescriptionChange(description);\n  }, [description, onDescriptionChange]);\n\n  useEffect(() => {\n    onImageUrlChange(imageUrl);\n  }, [imageUrl, onImageUrlChange]);\n\n  return (\n    <Stack gap=\"xs\" p=\"md\">\n      <Group gap=\"sm\" align=\"center\" wrap=\"nowrap\">\n        <Text flex=\"1 1 20%\" size=\"sm\">\n          Name\n        </Text>\n        <TextInput\n          size=\"sm\"\n          flex=\"1 1 65%\"\n          value={name}\n          disabled={\n            conversation &&\n            clientPermissions &&\n            !clientPermissions.canChangeGroupName\n          }\n          onChange={(event) => {\n            setName(event.target.value);\n          }}\n        />\n      </Group>\n      <Group gap=\"sm\" align=\"flex-start\" wrap=\"nowrap\">\n        <Text flex=\"1 1 20%\" size=\"sm\">\n          Description\n        </Text>\n        <Textarea\n          size=\"sm\"\n          flex=\"1 1 65%\"\n          value={description}\n          disabled={\n            conversation &&\n            clientPermissions &&\n            !clientPermissions.canChangeGroupDescription\n          }\n          onChange={(event) => {\n            setDescription(event.target.value);\n          }}\n        />\n      </Group>\n      <Group gap=\"sm\" align=\"center\" wrap=\"nowrap\">\n        <Text flex=\"1 1 20%\" size=\"sm\">\n          Image URL\n        </Text>\n        <TextInput\n          size=\"sm\"\n          flex=\"1 1 65%\"\n          value={imageUrl}\n          disabled={\n            conversation &&\n            clientPermissions &&\n            !clientPermissions.canChangeGroupImage\n          }\n          onChange={(event) => {\n            setImageUrl(event.target.value);\n          }}\n        />\n      </Group>\n    </Stack>\n  );\n};\n",
      "size_bytes": 2814
    },
    "sdks/node-sdk/src/utils/validation.ts": {
      "content": "export type HexString = `0x${string}`;\nexport function isHexString(value: unknown): value is HexString {\n  return typeof value === \"string\" && /^0x(?:[0-9a-fA-F]{2})+$/.test(value);\n}\n",
      "size_bytes": 184
    },
    "sdks/node-sdk/test/Conversation.test.ts": {
      "content": "import {\n  ConsentState,\n  ContentType,\n  MetadataField,\n  PermissionPolicy,\n  PermissionUpdateType,\n  type MessageDisappearingSettings,\n} from \"@xmtp/node-bindings\";\nimport { describe, expect, it, vi } from \"vitest\";\nimport { StreamFailedError } from \"@/utils/errors\";\nimport { createStream } from \"@/utils/streams\";\nimport {\n  ContentTypeTest,\n  createRegisteredClient,\n  createSigner,\n  createUser,\n  sleep,\n  TestCodec,\n} from \"@test/helpers\";\n\ndescribe(\"Conversation\", () => {\n  it(\"should update conversation name\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n    const newName = \"foo\";\n    await conversation.updateName(newName);\n    expect(conversation.name).toBe(newName);\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(2);\n\n    await client2.conversations.sync();\n    const conversations = client2.conversations.listGroups();\n    expect(conversations.length).toBe(1);\n\n    const conversation2 = conversations[0];\n    expect(conversation2).toBeDefined();\n    await conversation2.sync();\n    expect(conversation2.id).toBe(conversation.id);\n    expect(conversation2.name).toBe(newName);\n  });\n\n  it(\"should update conversation image URL\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n    const imageUrl = \"https://foo/bar.jpg\";\n    await conversation.updateImageUrl(imageUrl);\n    expect(conversation.imageUrl).toBe(imageUrl);\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(2);\n\n    await client2.conversations.sync();\n    const conversations = client2.conversations.listGroups();\n    expect(conversations.length).toBe(1);\n\n    const conversation2 = conversations[0];\n    expect(conversation2).toBeDefined();\n    await conversation2.sync();\n    expect(conversation2.id).toBe(conversation.id);\n    expect(conversation2.imageUrl).toBe(imageUrl);\n  });\n\n  it(\"should update conversation description\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n    const newDescription = \"foo\";\n    await conversation.updateDescription(newDescription);\n    expect(conversation.description).toBe(newDescription);\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(2);\n\n    await client2.conversations.sync();\n    const conversations = client2.conversations.listGroups();\n    expect(conversations.length).toBe(1);\n\n    const conversation2 = conversations[0];\n    expect(conversation2).toBeDefined();\n    await conversation2.sync();\n    expect(conversation2.id).toBe(conversation.id);\n    expect(conversation2.description).toBe(newDescription);\n  });\n\n  it(\"should add and remove members\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    const members = await conversation.members();\n\n    const memberInboxIds = members.map((member) => member.inboxId);\n    expect(memberInboxIds).toContain(client1.inboxId);\n    expect(memberInboxIds).toContain(client2.inboxId);\n    expect(memberInboxIds).not.toContain(client3.inboxId);\n\n    await conversation.addMembers([client3.inboxId]);\n\n    const members2 = await conversation.members();\n    expect(members2.length).toBe(3);\n\n    const memberInboxIds2 = members2.map((member) => member.inboxId);\n    expect(memberInboxIds2).toContain(client1.inboxId);\n    expect(memberInboxIds2).toContain(client2.inboxId);\n    expect(memberInboxIds2).toContain(client3.inboxId);\n\n    await conversation.removeMembers([client2.inboxId]);\n\n    const members3 = await conversation.members();\n    expect(members3.length).toBe(2);\n\n    const memberInboxIds3 = members3.map((member) => member.inboxId);\n    expect(memberInboxIds3).toContain(client1.inboxId);\n    expect(memberInboxIds3).not.toContain(client2.inboxId);\n    expect(memberInboxIds3).toContain(client3.inboxId);\n  });\n\n  it(\"should add and remove members by inbox id\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    const members = await conversation.members();\n    const memberInboxIds = members.map((member) => member.inboxId);\n    expect(memberInboxIds).toContain(client1.inboxId);\n    expect(memberInboxIds).toContain(client2.inboxId);\n    expect(memberInboxIds).not.toContain(client3.inboxId);\n\n    await conversation.addMembers([client3.inboxId]);\n\n    const members2 = await conversation.members();\n    expect(members2.length).toBe(3);\n\n    const memberInboxIds2 = members2.map((member) => member.inboxId);\n    expect(memberInboxIds2).toContain(client1.inboxId);\n    expect(memberInboxIds2).toContain(client2.inboxId);\n    expect(memberInboxIds2).toContain(client3.inboxId);\n\n    await conversation.removeMembers([client2.inboxId]);\n\n    const members3 = await conversation.members();\n    expect(members3.length).toBe(2);\n\n    const memberInboxIds3 = members3.map((member) => member.inboxId);\n    expect(memberInboxIds3).toContain(client1.inboxId);\n    expect(memberInboxIds3).not.toContain(client2.inboxId);\n    expect(memberInboxIds3).toContain(client3.inboxId);\n  });\n\n  it(\"should send and list messages\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    expect(await conversation.lastMessage()).toBeDefined();\n\n    const text = \"gm\";\n    await conversation.send(text);\n\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(2);\n    expect(messages[1].content).toBe(text);\n\n    const lastMessage = await conversation.lastMessage();\n    expect(lastMessage).toBeDefined();\n    expect(lastMessage?.id).toBe(messages[1].id);\n    expect(lastMessage?.content).toBe(text);\n\n    await client2.conversations.sync();\n    const conversations = client2.conversations.listGroups();\n    expect(conversations.length).toBe(1);\n\n    const conversation2 = conversations[0];\n    expect(conversation2).toBeDefined();\n    await conversation2.sync();\n    expect(conversation2.id).toBe(conversation.id);\n\n    const messages2 = await conversation2.messages();\n    expect(messages2.length).toBe(2);\n    expect(messages2[1].content).toBe(text);\n\n    const lastMessage2 = await conversation2.lastMessage();\n    expect(lastMessage2).toBeDefined();\n    expect(lastMessage2?.id).toBe(messages2[1].id);\n    expect(lastMessage2?.content).toBe(text);\n  });\n\n  it(\"should require content type when sending non-string content\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1, {\n      codecs: [new TestCodec()],\n    });\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    // @ts-expect-error - testing invalid content type\n    await expect(() => conversation.send(1)).rejects.toThrow();\n    await expect(() => conversation.send({ foo: \"bar\" })).rejects.toThrow();\n    await expect(\n      conversation.send({ foo: \"bar\" }, ContentTypeTest),\n    ).resolves.not.toThrow();\n  });\n\n  it(\"should optimistically send and list messages\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    const text = \"gm\";\n    conversation.sendOptimistic(text);\n\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(2);\n    expect(messages[1].content).toBe(text);\n\n    await client2.conversations.sync();\n    const conversations = client2.conversations.listGroups();\n    expect(conversations.length).toBe(1);\n\n    const conversation2 = conversations[0];\n    expect(conversation2).toBeDefined();\n\n    await conversation2.sync();\n    expect(conversation2.id).toBe(conversation.id);\n\n    const messages2 = await conversation2.messages();\n    expect(messages2.length).toBe(1);\n\n    await conversation.publishMessages();\n    await conversation2.sync();\n\n    const messages4 = await conversation2.messages();\n    expect(messages4.length).toBe(2);\n    expect(messages4[1].content).toBe(text);\n  });\n\n  it(\"should require content type when optimistically sending non-string content\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1, {\n      codecs: [new TestCodec()],\n    });\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    // @ts-expect-error - testing invalid content type\n    expect(() => conversation.sendOptimistic(1)).toThrow();\n    expect(() => conversation.sendOptimistic({ foo: \"bar\" })).toThrow();\n    expect(() =>\n      conversation.sendOptimistic({ foo: \"bar\" }, ContentTypeTest),\n    ).not.toThrow();\n  });\n\n  it(\"should optimistically create a group\", async () => {\n    const user1 = createUser();\n    const signer1 = createSigner(user1);\n    const client1 = await createRegisteredClient(signer1);\n    const conversation = client1.conversations.newGroupOptimistic({\n      groupName: \"foo\",\n      groupDescription: \"bar\",\n    });\n\n    expect(conversation.id).toBeDefined();\n    expect(conversation.name).toBe(\"foo\");\n    expect(conversation.description).toBe(\"bar\");\n    expect(conversation.imageUrl).toBe(\"\");\n    expect(conversation.addedByInboxId).toBe(client1.inboxId);\n\n    const text = \"gm\";\n    conversation.sendOptimistic(text);\n\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(1);\n    expect(messages[0].content).toBe(text);\n    expect(messages[0].deliveryStatus).toBe(\"unpublished\");\n\n    await conversation.publishMessages();\n\n    const messages2 = await conversation.messages();\n    expect(messages2.length).toBe(1);\n    expect(messages2[0].content).toBe(text);\n    expect(messages2[0].deliveryStatus).toBe(\"published\");\n  });\n\n  it(\"should optimistically create a group with members\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = client1.conversations.newGroupOptimistic({\n      groupName: \"foo\",\n      groupDescription: \"bar\",\n    });\n\n    expect(conversation.id).toBeDefined();\n    expect(conversation.name).toBe(\"foo\");\n    expect(conversation.description).toBe(\"bar\");\n    expect(conversation.imageUrl).toBe(\"\");\n    expect(conversation.addedByInboxId).toBe(client1.inboxId);\n\n    const text = \"gm\";\n    conversation.sendOptimistic(text);\n\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(1);\n    expect(messages[0].content).toBe(text);\n    expect(messages[0].deliveryStatus).toBe(\"unpublished\");\n\n    await conversation.addMembers([client2.inboxId]);\n\n    const members = await conversation.members();\n    const memberInboxIds = members.map((member) => member.inboxId);\n    expect(memberInboxIds.length).toBe(2);\n    expect(memberInboxIds).toContain(client1.inboxId);\n    expect(memberInboxIds).toContain(client2.inboxId);\n\n    const messages3 = await conversation.messages();\n    expect(messages3.length).toBe(2);\n    expect(messages3[0].content).toBe(text);\n    expect(messages3[0].deliveryStatus).toBe(\"published\");\n    expect(messages3[1].deliveryStatus).toBe(\"published\");\n  });\n\n  it(\"should throw when sending content without a codec\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    await expect(\n      // @ts-expect-error - testing invalid content type\n      conversation.send({ foo: \"bar\" }, ContentTypeTest),\n    ).rejects.toThrow();\n  });\n\n  it(\"should stream messages\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    await client2.conversations.sync();\n    const conversation2 = client2.conversations.listGroups();\n    expect(conversation2.length).toBe(1);\n    expect(conversation2[0].id).toBe(conversation.id);\n\n    const streamedMessages: unknown[] = [];\n    const stream = await conversation2[0].stream({\n      onValue: (message) => {\n        streamedMessages.push(message.content);\n      },\n    });\n\n    await conversation.send(\"gm\");\n    await conversation.send(\"gm2\");\n\n    setTimeout(() => {\n      void stream.end();\n    }, 100);\n\n    let count = 0;\n    for await (const message of stream) {\n      count++;\n      expect(message).toBeDefined();\n      if (count === 1) {\n        expect(message.content).toBe(\"gm\");\n      }\n      if (count === 2) {\n        expect(message.content).toBe(\"gm2\");\n      }\n    }\n\n    expect(streamedMessages).toEqual([\"gm\", \"gm2\"]);\n  });\n\n  it(\"should forward StreamFailedError to onError\", async () => {\n    const onErrorSpy = vi.fn();\n    const onFailSpy = vi.fn();\n\n    const mockStreamFunction = vi.fn(async (_, onFail: () => void) => {\n      // Simulate immediate stream failure\n      setTimeout(() => {\n        onFail();\n      }, 0);\n      return Promise.resolve({\n        end: vi.fn(),\n        endAndWait: vi.fn().mockResolvedValue(undefined),\n        isClosed: vi.fn().mockReturnValue(false),\n        waitForReady: vi.fn().mockResolvedValue(undefined),\n      });\n    });\n\n    setTimeout(() => {\n      void stream.end();\n    }, 100);\n\n    const stream = await createStream(mockStreamFunction, undefined, {\n      onError: onErrorSpy,\n      onFail: onFailSpy,\n      retryOnFail: false,\n    });\n\n    // Wait for the failure to be processed\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    expect(onErrorSpy).toHaveBeenCalledWith(expect.any(StreamFailedError));\n  });\n\n  it(\"should add and remove admins\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    expect(conversation.isSuperAdmin(client1.inboxId)).toBe(true);\n    expect(conversation.superAdmins.length).toBe(1);\n    expect(conversation.superAdmins).toContain(client1.inboxId);\n    expect(conversation.isAdmin(client1.inboxId)).toBe(false);\n    expect(conversation.isAdmin(client2.inboxId)).toBe(false);\n    expect(conversation.admins.length).toBe(0);\n\n    await conversation.addAdmin(client2.inboxId);\n    expect(conversation.isAdmin(client2.inboxId)).toBe(true);\n    expect(conversation.admins.length).toBe(1);\n    expect(conversation.admins).toContain(client2.inboxId);\n\n    await conversation.removeAdmin(client2.inboxId);\n    expect(conversation.isAdmin(client2.inboxId)).toBe(false);\n    expect(conversation.admins.length).toBe(0);\n  });\n\n  it(\"should add and remove super admins\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    expect(conversation.isSuperAdmin(client1.inboxId)).toBe(true);\n    expect(conversation.isSuperAdmin(client2.inboxId)).toBe(false);\n    expect(conversation.superAdmins.length).toBe(1);\n    expect(conversation.superAdmins).toContain(client1.inboxId);\n\n    await conversation.addSuperAdmin(client2.inboxId);\n    expect(conversation.isSuperAdmin(client2.inboxId)).toBe(true);\n    expect(conversation.superAdmins.length).toBe(2);\n    expect(conversation.superAdmins).toContain(client1.inboxId);\n    expect(conversation.superAdmins).toContain(client2.inboxId);\n\n    await conversation.removeSuperAdmin(client2.inboxId);\n    expect(conversation.isSuperAdmin(client2.inboxId)).toBe(false);\n    expect(conversation.superAdmins.length).toBe(1);\n    expect(conversation.superAdmins).toContain(client1.inboxId);\n  });\n\n  it(\"should manage group consent state\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const group = await client1.conversations.newGroup([client2.inboxId]);\n    expect(group).toBeDefined();\n    const dmGroup = await client1.conversations.newDm(client3.inboxId);\n    expect(dmGroup).toBeDefined();\n\n    await client2.conversations.sync();\n    const group2 = await client2.conversations.getConversationById(group.id);\n    expect(group2).toBeDefined();\n    expect(group2!.consentState).toBe(ConsentState.Unknown);\n    await group2!.send(\"gm!\");\n    expect(group2!.consentState).toBe(ConsentState.Allowed);\n\n    await client3.conversations.sync();\n    const dmGroup2 = await client3.conversations.getConversationById(\n      dmGroup.id,\n    );\n    expect(dmGroup2).toBeDefined();\n    expect(dmGroup2?.consentState).toBe(ConsentState.Unknown);\n    await dmGroup2?.send(\"gm!\");\n    expect(dmGroup2?.consentState).toBe(ConsentState.Allowed);\n  });\n\n  it(\"should update group permissions\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    expect(conversation.permissions.policySet).toEqual({\n      addMemberPolicy: 0,\n      removeMemberPolicy: 2,\n      addAdminPolicy: 3,\n      removeAdminPolicy: 3,\n      updateGroupNamePolicy: 0,\n      updateGroupDescriptionPolicy: 0,\n      updateGroupImageUrlSquarePolicy: 0,\n      updateMessageDisappearingPolicy: 2,\n    });\n\n    await conversation.updatePermission(\n      PermissionUpdateType.AddMember,\n      PermissionPolicy.Admin,\n    );\n\n    await conversation.updatePermission(\n      PermissionUpdateType.RemoveMember,\n      PermissionPolicy.SuperAdmin,\n    );\n\n    await conversation.updatePermission(\n      PermissionUpdateType.AddAdmin,\n      PermissionPolicy.Admin,\n    );\n\n    await conversation.updatePermission(\n      PermissionUpdateType.RemoveAdmin,\n      PermissionPolicy.Admin,\n    );\n\n    await conversation.updatePermission(\n      PermissionUpdateType.UpdateMetadata,\n      PermissionPolicy.Admin,\n      MetadataField.GroupName,\n    );\n\n    await conversation.updatePermission(\n      PermissionUpdateType.UpdateMetadata,\n      PermissionPolicy.Admin,\n      MetadataField.Description,\n    );\n\n    await conversation.updatePermission(\n      PermissionUpdateType.UpdateMetadata,\n      PermissionPolicy.Admin,\n      MetadataField.ImageUrlSquare,\n    );\n\n    expect(conversation.permissions.policySet).toEqual({\n      addMemberPolicy: 2,\n      removeMemberPolicy: 3,\n      addAdminPolicy: 2,\n      removeAdminPolicy: 2,\n      updateGroupNamePolicy: 2,\n      updateGroupDescriptionPolicy: 2,\n      updateGroupImageUrlSquarePolicy: 2,\n      updateMessageDisappearingPolicy: 2,\n    });\n  });\n\n  it(\"should handle disappearing messages in a group\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n\n    // create message disappearing settings so that messages are deleted after 1 second\n    const messageDisappearingSettings: MessageDisappearingSettings = {\n      fromNs: 10_000_000,\n      inNs: 10_000_000,\n    };\n\n    // create a group with message disappearing settings\n    const conversation = await client1.conversations.newGroup(\n      [client2.inboxId],\n      {\n        messageDisappearingSettings,\n      },\n    );\n\n    // verify that the message disappearing settings are set and enabled\n    expect(conversation.messageDisappearingSettings()).toEqual({\n      fromNs: 10_000_000,\n      inNs: 10_000_000,\n    });\n    expect(conversation.isMessageDisappearingEnabled()).toBe(true);\n\n    // send messages to the group\n    await conversation.send(\"gm\");\n    await conversation.send(\"gm2\");\n\n    // verify that the messages are sent\n    expect((await conversation.messages()).length).toBe(3);\n\n    // sync the messages to the other client\n    await client2.conversations.sync();\n    const conversation2 = await client2.conversations.getConversationById(\n      conversation.id,\n    );\n    await conversation2?.sync();\n\n    // verify that the message disappearing settings are set and enabled\n    expect(conversation2!.messageDisappearingSettings()).toEqual({\n      fromNs: 10_000_000,\n      inNs: 10_000_000,\n    });\n    expect(conversation2?.isMessageDisappearingEnabled()).toBe(true);\n\n    // wait for the messages to be deleted\n    await sleep(10000);\n\n    // verify that the messages are deleted\n    expect((await conversation.messages()).length).toBe(1);\n\n    // verify that the messages are deleted on the other client\n    expect((await conversation2?.messages())?.length).toBe(1);\n\n    // remove the message disappearing settings\n    await conversation.removeMessageDisappearingSettings();\n\n    // verify that the message disappearing settings are removed\n    expect(conversation.messageDisappearingSettings()).toEqual({\n      fromNs: 0,\n      inNs: 0,\n    });\n\n    expect(conversation.isMessageDisappearingEnabled()).toBe(false);\n\n    // sync other group\n    await conversation2?.sync();\n\n    // verify that the message disappearing settings are set and disabled\n    expect(conversation2?.messageDisappearingSettings()).toEqual({\n      fromNs: 0,\n      inNs: 0,\n    });\n    expect(conversation2?.isMessageDisappearingEnabled()).toBe(false);\n\n    // send messages to the group\n    await conversation2?.send(\"gm\");\n    await conversation2?.send(\"gm2\");\n\n    // verify that the messages are sent\n    expect((await conversation2?.messages())?.length).toBe(5);\n\n    // sync original group\n    await conversation.sync();\n\n    // verify that the messages are not deleted\n    expect((await conversation.messages()).length).toBe(5);\n  });\n\n  it(\"should handle disappearing messages in a DM group\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n\n    // create message disappearing settings so that messages are deleted after 1 second\n    const messageDisappearingSettings: MessageDisappearingSettings = {\n      fromNs: 10_000_000,\n      inNs: 10_000_000,\n    };\n\n    // create a group with message disappearing settings\n    const conversation = await client1.conversations.newDm(client2.inboxId, {\n      messageDisappearingSettings,\n    });\n\n    // verify that the message disappearing settings are set and enabled\n    expect(conversation.messageDisappearingSettings()).toEqual({\n      fromNs: 10_000_000,\n      inNs: 10_000_000,\n    });\n    expect(conversation.isMessageDisappearingEnabled()).toBe(true);\n\n    // send messages to the group\n    await conversation.send(\"gm\");\n    await conversation.send(\"gm2\");\n\n    // verify that the messages are sent\n    expect((await conversation.messages()).length).toBe(3);\n\n    // sync the messages to the other client\n    await client2.conversations.sync();\n    const conversation2 = await client2.conversations.getConversationById(\n      conversation.id,\n    );\n    await conversation2?.sync();\n\n    // verify that the message disappearing settings are set and enabled\n    expect(conversation2!.messageDisappearingSettings()).toEqual({\n      fromNs: 10_000_000,\n      inNs: 10_000_000,\n    });\n    expect(conversation2?.isMessageDisappearingEnabled()).toBe(true);\n\n    // wait for the messages to be deleted\n    await sleep(10000);\n\n    // verify that the messages are deleted\n    expect((await conversation.messages()).length).toBe(1);\n\n    // verify that the messages are deleted on the other client\n    expect((await conversation2?.messages())?.length).toBe(1);\n\n    // remove the message disappearing settings\n    await conversation.removeMessageDisappearingSettings();\n\n    // verify that the message disappearing settings are removed\n    expect(conversation.messageDisappearingSettings()).toEqual({\n      fromNs: 0,\n      inNs: 0,\n    });\n\n    expect(conversation.isMessageDisappearingEnabled()).toBe(false);\n\n    // sync other group\n    await conversation2?.sync();\n\n    // verify that the message disappearing settings are set and disabled\n    expect(conversation2?.messageDisappearingSettings()).toEqual({\n      fromNs: 0,\n      inNs: 0,\n    });\n    expect(conversation2?.isMessageDisappearingEnabled()).toBe(false);\n\n    // send messages to the group\n    await conversation2?.send(\"gm\");\n    await conversation2?.send(\"gm2\");\n\n    // verify that the messages are sent\n    expect((await conversation2?.messages())?.length).toBe(3);\n\n    // sync original group\n    await conversation.sync();\n\n    // verify that the messages are not deleted\n    expect((await conversation.messages()).length).toBe(3);\n  });\n\n  it(\"should return paused for version\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newDm(client2.inboxId);\n    expect(conversation.pausedForVersion()).toBeUndefined();\n  });\n\n  it(\"should get hmac keys\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    const hmacKeys = conversation.getHmacKeys();\n    const groupIds = Object.keys(hmacKeys);\n    for (const groupId of groupIds) {\n      expect(hmacKeys[groupId].length).toBe(3);\n      expect(hmacKeys[groupId][0].key).toBeDefined();\n      expect(hmacKeys[groupId][0].epoch).toBeDefined();\n      expect(hmacKeys[groupId][1].key).toBeDefined();\n      expect(hmacKeys[groupId][1].epoch).toBeDefined();\n      expect(hmacKeys[groupId][2].key).toBeDefined();\n      expect(hmacKeys[groupId][2].epoch).toBeDefined();\n    }\n  });\n\n  it(\"should get conversation debug info\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n    const debugInfo = await conversation.debugInfo();\n    expect(debugInfo).toBeDefined();\n    expect(debugInfo.epoch).toBeDefined();\n    expect(debugInfo.maybeForked).toBe(false);\n    expect(debugInfo.forkDetails).toBe(\"\");\n    expect(debugInfo.isCommitLogForked).toBeUndefined();\n    expect(debugInfo.localCommitLog).toBeDefined();\n    expect(debugInfo.remoteCommitLog).toBeDefined();\n    expect(debugInfo.cursor).toBeGreaterThan(0);\n  });\n\n  it(\"should filter messages by content type\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n\n    await conversation.send(\"gm\");\n\n    const messages = await conversation.messages();\n    expect(messages.length).toBe(2);\n\n    const filteredMessages = await conversation.messages({\n      contentTypes: [ContentType.Text],\n    });\n    expect(filteredMessages.length).toBe(1);\n  });\n});\n",
      "size_bytes": 31375
    },
    "content-types/content-type-markdown/README.md": {
      "content": "# Markdown content type\n\nThis package provides an XMTP content type to support markdown in messages.\n\n## Install the package\n\n```bash\n# npm\nnpm i @xmtp/content-type-markdown\n\n# yarn\nyarn add @xmtp/content-type-markdown\n\n# pnpm\npnpm i @xmtp/content-type-markdown\n```\n\n## Send a message with markdown\n\n```tsx\nconst markdown = `\n# Test\n\nThis is a markdown message with **bold** and *italic* text.\n`;\n\nawait conversation.send(markdown, ContentTypeMarkdown);\n```\n\n## Developing\n\nRun `yarn dev` to build the content type and watch for changes, which will trigger a rebuild.\n\nFor more information on contributing to this repository, see our [contributing guidelines](../../CONTRIBUTING.md).\n",
      "size_bytes": 684
    },
    "content-types/content-type-wallet-send-calls/src/index.ts": {
      "content": "export {\n  WalletSendCallsCodec,\n  ContentTypeWalletSendCalls,\n} from \"./WalletSendCalls\";\nexport type { WalletSendCallsParams } from \"./WalletSendCalls\";\n",
      "size_bytes": 155
    },
    "sdks/agent-sdk/vitest.config.ts": {
      "content": "import tsconfigPaths from \"vite-tsconfig-paths\";\nimport { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  plugins: [tsconfigPaths()],\n  test: {\n    globals: true,\n    environment: \"node\",\n  },\n});\n",
      "size_bytes": 219
    },
    "sdks/agent-sdk/src/middleware/index.ts": {
      "content": "export * from \"./CommandRouter.js\";\n",
      "size_bytes": 36
    },
    "apps/xmtp.chat/src/components/Conversations/ConversationsMenu.tsx": {
      "content": "import { ActionIcon, Menu } from \"@mantine/core\";\nimport { IconDots } from \"@/icons/IconDots\";\n\nexport type ConversationsMenuProps = {\n  onSync: () => void;\n  onSyncAll: () => void;\n  disabled?: boolean;\n  loading?: boolean;\n};\n\nexport const ConversationsMenu: React.FC<ConversationsMenuProps> = ({\n  onSync,\n  onSyncAll,\n  disabled,\n  loading,\n}) => {\n  return (\n    <Menu shadow=\"md\" disabled={disabled} position=\"bottom-end\">\n      <Menu.Target>\n        <ActionIcon\n          variant=\"light\"\n          loading={loading}\n          radius=\"xl\"\n          size=\"lg\"\n          style={{\n            background:\n              \"linear-gradient(130deg, rgba(10, 255, 241, 0.16), rgba(151, 114, 251, 0.24))\",\n            border: \"1px solid rgba(10, 255, 241, 0.25)\",\n            color: \"var(--mantine-color-gray-0)\",\n            boxShadow: \"0 14px 26px rgba(10, 255, 241, 0.18)\",\n          }}>\n          <IconDots />\n        </ActionIcon>\n      </Menu.Target>\n      <Menu.Dropdown miw={200}>\n        <Menu.Label>Actions</Menu.Label>\n        <Menu.Item onClick={onSync}>Sync</Menu.Item>\n        <Menu.Item onClick={onSyncAll}>Sync All</Menu.Item>\n      </Menu.Dropdown>\n    </Menu>\n  );\n};\n",
      "size_bytes": 1182
    },
    "content-types/content-type-reaction/src/index.ts": {
      "content": "export * from \"./Reaction\";\n",
      "size_bytes": 28
    },
    "apps/xmtp.chat/src/helpers/createSigner.ts": {
      "content": "import type { Signer } from \"@xmtp/browser-sdk\";\nimport { toBytes, type Hex } from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\n\nexport const createEphemeralSigner = (privateKey: Hex): Signer => {\n  const account = privateKeyToAccount(privateKey);\n  return {\n    type: \"EOA\",\n    getIdentifier: () => ({\n      identifier: account.address.toLowerCase(),\n      identifierKind: \"Ethereum\",\n    }),\n    signMessage: async (message: string) => {\n      const signature = await account.signMessage({\n        message,\n      });\n      return toBytes(signature);\n    },\n  };\n};\n\nexport const createEOASigner = (\n  address: `0x${string}`,\n  signMessage: (message: string) => Promise<string> | string,\n): Signer => {\n  return {\n    type: \"EOA\",\n    getIdentifier: () => ({\n      identifier: address.toLowerCase(),\n      identifierKind: \"Ethereum\",\n    }),\n    signMessage: async (message: string) => {\n      const signature = await signMessage(message);\n      return toBytes(signature);\n    },\n  };\n};\n\nexport const createSCWSigner = (\n  address: `0x${string}`,\n  signMessage: (message: string) => Promise<string> | string,\n  chainId: number = 1,\n): Signer => {\n  console.log(\"Creating SCW signer with chain ID:\", chainId);\n  return {\n    type: \"SCW\",\n    getIdentifier: () => ({\n      identifier: address.toLowerCase(),\n      identifierKind: \"Ethereum\",\n    }),\n    signMessage: async (message: string) => {\n      const signature = await signMessage(message);\n      const signatureBytes = toBytes(signature);\n      return signatureBytes;\n    },\n    getChainId: () => BigInt(chainId),\n  };\n};\n",
      "size_bytes": 1597
    },
    "apps/xmtp.chat/src/helpers/strings.ts": {
      "content": "export const isValidEthereumAddress = (\n  address: string,\n): address is `0x${string}` => /^0x[a-fA-F0-9]{40}$/.test(address);\n\nexport const isValidInboxId = (inboxId: string): boolean =>\n  /^[a-z0-9]{64}$/.test(inboxId);\n\nconst shouldTruncate = (inputLength: number, prefix: number, suffix: number) =>\n  inputLength > prefix + suffix + 3;\n\nconst buildTruncatedValue = (\n  value: string,\n  prefix: number,\n  suffix: number,\n): string => {\n  if (!shouldTruncate(value.length, prefix, suffix)) {\n    return value;\n  }\n\n  return `${value.substring(0, prefix)}...${value.substring(value.length - suffix)}`;\n};\n\nexport const shortAddress = (value: string, length: number = 4): string => {\n  if (!value) {\n    return value;\n  }\n\n  const trimmed = value.trim();\n  const safeLength = Math.max(1, length);\n\n  if (isValidEthereumAddress(trimmed)) {\n    const prefix = Math.min(trimmed.length, safeLength + 2);\n    const suffix = Math.max(\n      1,\n      Math.min(trimmed.length - prefix, safeLength),\n    );\n    return buildTruncatedValue(trimmed, prefix, suffix);\n  }\n\n  if (isValidInboxId(trimmed)) {\n    const prefix = Math.min(trimmed.length, safeLength);\n    const suffix = Math.max(\n      1,\n      Math.min(trimmed.length - prefix, safeLength),\n    );\n    return buildTruncatedValue(trimmed, prefix, suffix);\n  }\n\n  const prefix = Math.min(trimmed.length, safeLength);\n  const suffix = Math.max(\n    1,\n    Math.min(\n      trimmed.length - prefix,\n      Math.max(safeLength, Math.ceil(safeLength * 1.5)),\n    ),\n  );\n  return buildTruncatedValue(trimmed, prefix, suffix);\n};\n\nexport const MEMBER_NO_LONGER_IN_GROUP =\n  \"This member is no longer in the group\";\n",
      "size_bytes": 1656
    },
    "apps/xmtp.chat/src/components/Messages/MessageContent.tsx": {
      "content": "import { Code } from \"@mantine/core\";\nimport { ContentTypeMarkdown } from \"@xmtp/content-type-markdown\";\nimport type { ContentTypeId } from \"@xmtp/content-type-primitives\";\nimport { ContentTypeReadReceipt } from \"@xmtp/content-type-read-receipt\";\nimport {\n  ContentTypeRemoteAttachment,\n  type RemoteAttachment,\n} from \"@xmtp/content-type-remote-attachment\";\nimport { ContentTypeReply, type Reply } from \"@xmtp/content-type-reply\";\nimport {\n  ContentTypeTransactionReference,\n  type TransactionReference,\n} from \"@xmtp/content-type-transaction-reference\";\nimport {\n  ContentTypeWalletSendCalls,\n  type WalletSendCallsParams,\n} from \"@xmtp/content-type-wallet-send-calls\";\nimport { ActionsContent } from \"@/components/Messages/ActionsContent\";\nimport { FallbackContent } from \"@/components/Messages/FallbackContent\";\nimport { MarkdownContent } from \"@/components/Messages/MarkdownContent\";\nimport { type MessageContentAlign } from \"@/components/Messages/MessageContentWrapper\";\nimport { ReadReceiptContent } from \"@/components/Messages/ReadReceiptContent\";\nimport { RemoteAttachmentContent } from \"@/components/Messages/RemoteAttachmentContent\";\nimport { ReplyContent } from \"@/components/Messages/ReplyContent\";\nimport { TextContent } from \"@/components/Messages/TextContent\";\nimport { TransactionReferenceContent } from \"@/components/Messages/TransactionReferenceContent\";\nimport { WalletSendCallsContent } from \"@/components/Messages/WalletSendCallsContent\";\nimport { ContentTypeActions, type Actions } from \"@/content-types/Actions\";\n\nexport type MessageContentProps = {\n  align: MessageContentAlign;\n  scrollToMessage: (id: string) => void;\n  contentType: ContentTypeId;\n  content: unknown;\n  conversationId: string;\n  fallback?: string;\n};\n\nexport const MessageContent: React.FC<MessageContentProps> = ({\n  contentType,\n  content,\n  conversationId,\n  fallback,\n  align,\n  scrollToMessage,\n}) => {\n  if (contentType.sameAs(ContentTypeTransactionReference)) {\n    return (\n      <TransactionReferenceContent content={content as TransactionReference} />\n    );\n  }\n\n  if (contentType.sameAs(ContentTypeWalletSendCalls)) {\n    return (\n      <WalletSendCallsContent\n        content={content as WalletSendCallsParams}\n        conversationId={conversationId}\n      />\n    );\n  }\n\n  if (contentType.sameAs(ContentTypeReply)) {\n    return (\n      <ReplyContent\n        align={align}\n        conversationId={conversationId}\n        reply={content as Reply}\n        fallback={fallback}\n        scrollToMessage={scrollToMessage}\n      />\n    );\n  }\n\n  if (contentType.sameAs(ContentTypeReadReceipt)) {\n    return <ReadReceiptContent />;\n  }\n\n  if (contentType.sameAs(ContentTypeRemoteAttachment)) {\n    return (\n      <RemoteAttachmentContent\n        align={align}\n        content={content as RemoteAttachment}\n      />\n    );\n  }\n\n  if (contentType.sameAs(ContentTypeActions)) {\n    return <ActionsContent content={content as Actions} />;\n  }\n\n  if (contentType.sameAs(ContentTypeMarkdown)) {\n    return <MarkdownContent content={content as string} align={align} />;\n  }\n\n  if (typeof content === \"string\") {\n    return <TextContent text={content} align={align} />;\n  }\n\n  if (typeof fallback === \"string\") {\n    return <FallbackContent text={fallback} />;\n  }\n\n  return (\n    <Code\n      block\n      w=\"100%\"\n      style={{ whiteSpace: \"pre-wrap\", wordBreak: \"break-all\" }}>\n      {JSON.stringify(content ?? fallback, null, 2)}\n    </Code>\n  );\n};\n",
      "size_bytes": 3444
    },
    "apps/xmtp.chat/src/icons/IconUsers.tsx": {
      "content": "export const IconUsers = ({\n  size = 20,\n  color = \"currentColor\",\n  ...props\n}: {\n  size?: number;\n  color?: string;\n}) => {\n  return (\n    <svg\n      width={size}\n      height={size}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox=\"0 0 16 16\"\n      fill={color}\n      {...props}>\n      <path d=\"M8.5 4.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM10.9 12.006c.11.542-.348.994-.9.994H2c-.553 0-1.01-.452-.902-.994a5.002 5.002 0 0 1 9.803 0ZM14.002 12h-1.59a2.556 2.556 0 0 0-.04-.29 6.476 6.476 0 0 0-1.167-2.603 3.002 3.002 0 0 1 3.633 1.911c.18.522-.283.982-.836.982ZM12 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z\" />\n    </svg>\n  );\n};\n",
      "size_bytes": 629
    },
    "sdks/node-sdk/src/AsyncStream.ts": {
      "content": "type ResolveValue<T> = {\n  value: T;\n  done: boolean;\n};\n\ntype ResolveNext<T> = (resolveValue: ResolveValue<T>) => void;\n\n/**\n * AsyncStream provides an async iterable interface for streaming data.\n *\n * This class implements a producer-consumer pattern where:\n * - Producers can push values using the `push()` method\n * - Consumers can iterate over values asynchronously using `for await` loops or `next()`\n * - Values are queued internally when no consumers are waiting\n * - Consumers are resolved immediately when values are available\n * - The stream can be terminated using `done()`, `return()`, or `end()`\n *\n * @example\n * ```typescript\n * const stream = new AsyncStream<string>();\n *\n * stream.push(\"hello\");\n * stream.push(\"world\");\n *\n * for await (const value of stream) {\n *   console.log(value); // \"hello\", \"world\"\n * }\n * ```\n */\nexport class AsyncStream<T> {\n  isDone = false;\n  #pendingResolves: ResolveNext<T | undefined>[] = [];\n  #queue: T[];\n  onDone: (() => void) | undefined;\n  onReturn: (() => void) | undefined;\n\n  constructor() {\n    this.#queue = [];\n    this.isDone = false;\n  }\n\n  flush() {\n    while (this.#pendingResolves.length > 0) {\n      const nextResolve = this.#pendingResolves.shift();\n      if (nextResolve) {\n        nextResolve({ done: true, value: undefined });\n      }\n    }\n  }\n\n  done() {\n    this.flush();\n    this.#queue = [];\n    this.#pendingResolves = [];\n    this.isDone = true;\n    this.onDone?.();\n  }\n\n  push = (value: T) => {\n    if (this.isDone) {\n      return;\n    }\n\n    const nextResolve = this.#pendingResolves.shift();\n    if (nextResolve) {\n      nextResolve({\n        done: false,\n        value,\n      });\n    } else {\n      this.#queue.push(value);\n    }\n  };\n\n  next = (): Promise<ResolveValue<T | undefined>> => {\n    if (this.isDone) {\n      return Promise.resolve({ done: true, value: undefined });\n    }\n\n    if (this.#queue.length > 0) {\n      return Promise.resolve({\n        done: false,\n        value: this.#queue.shift(),\n      });\n    }\n\n    return new Promise((resolve) => {\n      this.#pendingResolves.push(resolve);\n    });\n  };\n\n  return = (): Promise<ResolveValue<T | undefined>> => {\n    this.onReturn?.();\n    this.done();\n\n    return Promise.resolve({\n      done: true,\n      value: undefined,\n    });\n  };\n\n  end = () => this.return();\n\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n}\n\nexport interface AsyncStreamProxy<T> extends AsyncIterable<T> {\n  next(): Promise<ResolveValue<T>>;\n  return(): Promise<ResolveValue<undefined>>;\n  end(): Promise<ResolveValue<undefined>>;\n  isDone: boolean;\n}\n\nconst usableProperties = [\n  \"end\",\n  \"isDone\",\n  \"next\",\n  \"return\",\n  Symbol.asyncIterator,\n];\nconst isUsableProperty = <T>(\n  prop: string | symbol,\n): prop is keyof AsyncStreamProxy<T> => {\n  return usableProperties.includes(prop);\n};\n\n/**\n * Creates a read-only proxy for AsyncStream instances that restricts access to consumer-only methods.\n *\n * This proxy only exposes the following properties and methods:\n * - `next()`: Get the next value from the stream\n * - `end()`: Terminate the stream and stop iteration\n * - `return()`: Same as end(), terminates the stream\n * - `isDone`: Boolean indicating if the stream has been terminated\n * - `Symbol.asyncIterator`: Enables `for await` loop iteration\n *\n * Producer methods like `push()`, `done()`, and `flush()` are hidden to prevent\n * consumers from accidentally modifying the stream state.\n *\n * @param stream - The AsyncStream instance to create a proxy for\n * @returns A read-only proxy that implements AsyncStreamProxy<T>\n *\n * @example\n * ```typescript\n * const stream = new AsyncStream<string>();\n * const proxy = createAsyncStreamProxy(stream);\n *\n * stream.push(\"hello\");\n * stream.push(\"world\");\n *\n * for await (const value of proxy) {\n *   console.log(value); // \"hello\", \"world\"\n * }\n * ```\n */\nexport function createAsyncStreamProxy<T>(stream: AsyncStream<T>) {\n  return new Proxy(stream, {\n    get(target, prop, receiver) {\n      if (isUsableProperty(prop)) {\n        return Reflect.get(target, prop, receiver);\n      }\n    },\n\n    set() {\n      return true;\n    },\n\n    has(_target, prop) {\n      return isUsableProperty(prop);\n    },\n\n    ownKeys() {\n      return usableProperties;\n    },\n\n    getOwnPropertyDescriptor(target, prop) {\n      if (isUsableProperty(prop)) {\n        return {\n          enumerable: true,\n          configurable: true,\n          value: Reflect.get(target, prop),\n        };\n      }\n      return undefined;\n    },\n  }) as AsyncStreamProxy<T>;\n}\n",
      "size_bytes": 4528
    },
    "apps/xmtp.chat/src/components/Conversation/Conversation.module.css": {
      "content": ".shell {\n  height: 100%;\n}\n\n.header {\n  padding: var(--mantine-spacing-md);\n  background: transparent;\n  border-bottom: 1px solid rgba(148, 163, 184, 0.14);\n  backdrop-filter: blur(10px);\n}\n\n.content {\n  position: relative;\n  padding: var(--mantine-spacing-lg) var(--mantine-spacing-md)\n    calc(var(--mantine-spacing-lg) * 1.4);\n  display: flex;\n  flex-direction: column;\n  gap: var(--mantine-spacing-sm);\n  background:\n    linear-gradient(180deg, rgba(6, 9, 20, 0.75), rgba(6, 9, 20, 0.82)),\n    radial-gradient(circle at top left, rgba(10, 255, 241, 0.08), transparent 55%),\n    radial-gradient(circle at bottom right, rgba(151, 114, 251, 0.1), transparent 60%);\n}\n\n.content::after {\n  content: \"\";\n  position: absolute;\n  inset: 0;\n  background-image: radial-gradient(\n      rgba(255, 255, 255, 0.04) 1px,\n      transparent 0\n    ),\n    radial-gradient(rgba(10, 255, 241, 0.035) 1px, transparent 0);\n  background-size: 18px 18px, 40px 40px;\n  opacity: 0.4;\n  pointer-events: none;\n}\n\n.content > * {\n  position: relative;\n  z-index: 1;\n}\n\n.footer {\n  padding: var(--mantine-spacing-md);\n  border-top: 1px solid rgba(148, 163, 184, 0.14);\n  background: rgba(4, 7, 18, 0.6);\n  backdrop-filter: blur(10px);\n}\n\n.membersAside {\n  background:\n    linear-gradient(180deg, rgba(6, 9, 20, 0.92), rgba(6, 9, 20, 0.85));\n  border-left: 1px solid rgba(148, 163, 184, 0.1);\n}\n\n@media (max-width: 768px) {\n  .content {\n    padding: var(--mantine-spacing-md);\n    border-radius: 18px 18px 0 0;\n  }\n\n  .footer {\n    padding: var(--mantine-spacing-md) var(--mantine-spacing-sm);\n    border-radius: 0 0 18px 18px;\n  }\n}\n\n@media (max-width: 520px) {\n  .header {\n    padding: var(--mantine-spacing-sm) var(--mantine-spacing-xs);\n    border-bottom-width: 0;\n    border-radius: 14px 14px 0 0;\n  }\n\n  .content {\n    padding: var(--mantine-spacing-sm) var(--mantine-spacing-xs)\n      calc(var(--mantine-spacing-lg) * 1.1);\n    border-radius: 14px 14px 0 0;\n  }\n\n  .footer {\n    padding: var(--mantine-spacing-sm) var(--mantine-spacing-xs);\n    border-top-width: 0;\n    border-radius: 0 0 14px 14px;\n  }\n\n  .membersAside {\n    border-radius: 0;\n  }\n}\n",
      "size_bytes": 2129
    },
    "apps/xmtp.chat/src/components/App/LoggingSelect.tsx": {
      "content": "import { Group, NativeSelect, Stack, Text } from \"@mantine/core\";\nimport { type ClientOptions } from \"@xmtp/browser-sdk\";\nimport { useSettings } from \"@/hooks/useSettings\";\n\nexport const LoggingSelect: React.FC = () => {\n  const { loggingLevel, setLoggingLevel } = useSettings();\n\n  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {\n    setLoggingLevel(event.currentTarget.value as ClientOptions[\"loggingLevel\"]);\n  };\n\n  return (\n    <Stack gap=\"xs\">\n      <Group gap=\"xs\" justify=\"space-between\">\n        <Text fw=\"bold\" size=\"lg\">\n          Logging level\n        </Text>\n        <NativeSelect\n          data={[\"off\", \"error\", \"warn\", \"info\", \"debug\", \"trace\"]}\n          value={loggingLevel}\n          onChange={handleChange}\n        />\n      </Group>\n      <Text size=\"sm\">Enable logging to help debug issues</Text>\n    </Stack>\n  );\n};\n",
      "size_bytes": 863
    },
    "sdks/node-sdk/test/Client.test.ts": {
      "content": "import fs from \"node:fs\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport { IdentifierKind } from \"@xmtp/node-bindings\";\nimport { uint8ArrayToHex } from \"uint8array-extras\";\nimport { v4 } from \"uuid\";\nimport { describe, expect, it } from \"vitest\";\nimport { Client } from \"@/Client\";\nimport {\n  ClientNotInitializedError,\n  SignerUnavailableError,\n} from \"@/utils/errors\";\nimport {\n  buildClient,\n  createClient,\n  createIdentifier,\n  createRegisteredClient,\n  createSigner,\n  createUser,\n} from \"@test/helpers\";\n\ndescribe(\"Client\", () => {\n  it(\"should create a client\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createClient(signer);\n    expect(client.accountIdentifier?.identifierKind).toBe(\n      IdentifierKind.Ethereum,\n    );\n    expect(client.accountIdentifier?.identifier).toBe(\n      user.account.address.toLowerCase(),\n    );\n    expect(client.isRegistered).toBe(false);\n    expect(client.inboxId).toBeDefined();\n    expect(client.installationId).toBeDefined();\n    expect(client.options).toBeDefined();\n    expect(client.signer).toBe(signer);\n  });\n\n  it(\"should register an identity\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer);\n    expect(client2.isRegistered).toBe(true);\n  });\n\n  it(\"should be able to message registered identity\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const canMessage = await client.canMessage([await signer.getIdentifier()]);\n    expect(Object.fromEntries(canMessage)).toEqual({\n      [user.account.address.toLowerCase()]: true,\n    });\n  });\n\n  it(\"should be able to check if can message without client instance\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    await createRegisteredClient(signer);\n    const canMessage = await Client.canMessage(\n      [await signer.getIdentifier()],\n      \"local\",\n    );\n    expect(Object.fromEntries(canMessage)).toEqual({\n      [user.account.address.toLowerCase()]: true,\n    });\n  });\n\n  it(\"should get an inbox ID from an address\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const inboxId = await client.getInboxIdByIdentifier(\n      await signer.getIdentifier(),\n    );\n    expect(inboxId).toBe(client.inboxId);\n  });\n\n  it(\"should add a wallet association to the client\", async () => {\n    const user = createUser();\n    const user2 = createUser();\n    const signer = createSigner(user);\n    const signer2 = createSigner(user2);\n    const client = await createRegisteredClient(signer);\n\n    await client.unsafe_addAccount(signer2, true);\n\n    const inboxState = await client.preferences.inboxState();\n    expect(inboxState.identifiers.length).toEqual(2);\n    expect(inboxState.identifiers).toContainEqual(await signer.getIdentifier());\n    expect(inboxState.identifiers).toContainEqual(\n      await signer2.getIdentifier(),\n    );\n  });\n\n  it(\"should revoke a wallet association from the client\", async () => {\n    const user = createUser();\n    const user2 = createUser();\n    const signer = createSigner(user);\n    const signer2 = createSigner(user2);\n    const client = await createRegisteredClient(signer);\n\n    await client.unsafe_addAccount(signer2, true);\n    await client.removeAccount(await signer2.getIdentifier());\n\n    const inboxState = await client.preferences.inboxState();\n    expect(inboxState.identifiers).toEqual([await signer.getIdentifier()]);\n  });\n\n  it(\"should revoke all other installations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client3 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    const inboxState = await client3.preferences.inboxState(true);\n    expect(inboxState.installations.length).toBe(3);\n\n    const installationIds = inboxState.installations.map((i) => i.id);\n    expect(installationIds).toContain(client.installationId);\n    expect(installationIds).toContain(client2.installationId);\n    expect(installationIds).toContain(client3.installationId);\n\n    await client3.revokeAllOtherInstallations();\n\n    const inboxState2 = await client3.preferences.inboxState(true);\n\n    expect(inboxState2.installations.length).toBe(1);\n    expect(inboxState2.installations[0].id).toBe(client3.installationId);\n  });\n\n  it(\"should revoke specific installations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client3 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    const inboxState = await client3.preferences.inboxState(true);\n    expect(inboxState.installations.length).toBe(3);\n\n    const installationIds = inboxState.installations.map((i) => i.id);\n    expect(installationIds).toContain(client.installationId);\n    expect(installationIds).toContain(client2.installationId);\n    expect(installationIds).toContain(client3.installationId);\n\n    await client3.revokeInstallations([client.installationIdBytes]);\n\n    const inboxState2 = await client3.preferences.inboxState(true);\n\n    expect(inboxState2.installations.length).toBe(2);\n\n    const installationIds2 = inboxState2.installations.map((i) => i.id);\n    expect(installationIds2).toContain(client2.installationId);\n    expect(installationIds2).toContain(client3.installationId);\n    expect(installationIds2).not.toContain(client.installationId);\n  });\n\n  it(\"should statically revoke specific installations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client3 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    const inboxState = await client3.preferences.inboxState(true);\n    expect(inboxState.installations.length).toBe(3);\n\n    const installationIds = inboxState.installations.map((i) => i.id);\n    expect(installationIds).toContain(client.installationId);\n    expect(installationIds).toContain(client2.installationId);\n    expect(installationIds).toContain(client3.installationId);\n\n    await Client.revokeInstallations(\n      signer,\n      client3.inboxId,\n      [client.installationIdBytes],\n      \"local\",\n    );\n\n    const inboxState2 = await client3.preferences.inboxState(true);\n\n    expect(inboxState2.installations.length).toBe(2);\n\n    const installationIds2 = inboxState2.installations.map((i) => i.id);\n    expect(installationIds2).toContain(client2.installationId);\n    expect(installationIds2).toContain(client3.installationId);\n    expect(installationIds2).not.toContain(client.installationId);\n  });\n\n  it(\"should throw when trying to create more than 10 installations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client3 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client4 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client5 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client6 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client7 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client8 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client9 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client10 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    const inboxState = await client3.preferences.inboxState(true);\n    expect(inboxState.installations.length).toBe(10);\n\n    const installationIds = inboxState.installations.map((i) => i.id);\n    expect(installationIds).toContain(client.installationId);\n    expect(installationIds).toContain(client2.installationId);\n    expect(installationIds).toContain(client3.installationId);\n    expect(installationIds).toContain(client4.installationId);\n    expect(installationIds).toContain(client5.installationId);\n    expect(installationIds).toContain(client6.installationId);\n    expect(installationIds).toContain(client7.installationId);\n    expect(installationIds).toContain(client8.installationId);\n    expect(installationIds).toContain(client9.installationId);\n    expect(installationIds).toContain(client10.installationId);\n\n    await expect(\n      createRegisteredClient(signer, {\n        dbPath: `./test-${v4()}.db3`,\n      }),\n    ).rejects.toThrow();\n\n    await client3.revokeAllOtherInstallations();\n\n    const inboxState2 = await client3.preferences.inboxState(true);\n\n    expect(inboxState2.installations.length).toBe(1);\n    expect(inboxState2.installations[0].id).toBe(client3.installationId);\n\n    const client11 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    const inboxState3 = await client11.preferences.inboxState(true);\n    expect(inboxState3.installations.length).toBe(2);\n    const installationIds3 = inboxState3.installations.map((i) => i.id);\n    expect(installationIds3).toContain(client3.installationId);\n    expect(installationIds3).toContain(client11.installationId);\n  });\n\n  it(\"should verify signatures\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const signatureText = \"gm1\";\n    const signature = client.signWithInstallationKey(signatureText);\n    const verified = client.verifySignedWithInstallationKey(\n      signatureText,\n      signature,\n    );\n    expect(verified).toBe(true);\n    const verified2 = Client.verifySignedWithPublicKey(\n      signatureText,\n      signature,\n      client.installationIdBytes,\n    );\n    expect(verified2).toBe(true);\n\n    const signatureText2 = new Uint8Array(32).fill(1);\n    const signature2 = client.signWithInstallationKey(\n      uint8ArrayToHex(signatureText2),\n    );\n    const verified3 = Client.verifySignedWithPublicKey(\n      uint8ArrayToHex(signatureText2),\n      signature2,\n      client.installationIdBytes,\n    );\n    expect(verified3).toBe(true);\n    const verified4 = Client.verifySignedWithPublicKey(\n      uint8ArrayToHex(signatureText2),\n      signature,\n      client.installationIdBytes,\n    );\n    expect(verified4).toBe(false);\n  });\n\n  it(\"should check if an address is authorized\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const authorized = await Client.isAddressAuthorized(\n      client.inboxId,\n      user.account.address.toLowerCase(),\n      \"local\",\n    );\n    expect(authorized).toBe(true);\n\n    const notAuthorized = await Client.isAddressAuthorized(\n      client.inboxId,\n      \"0x1234567890123456789012345678901234567890\",\n      \"local\",\n    );\n    expect(notAuthorized).toBe(false);\n  });\n\n  it(\"should check if an installation is authorized\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const authorized = await Client.isInstallationAuthorized(\n      client.inboxId,\n      client.installationIdBytes,\n      \"local\",\n    );\n    expect(authorized).toBe(true);\n\n    const notAuthorized = await Client.isInstallationAuthorized(\n      client.inboxId,\n      new Uint8Array(32),\n      \"local\",\n    );\n    expect(notAuthorized).toBe(false);\n  });\n\n  it(\"should return a version\", () => {\n    expect(Client.version).toBeDefined();\n  });\n\n  it(\"should change the recovery identifier\", async () => {\n    const user = createUser();\n    const user2 = createUser();\n    const signer = createSigner(user);\n    const signer2 = createSigner(user2);\n    const client = await createRegisteredClient(signer);\n\n    const inboxState = await client.preferences.inboxState();\n    expect(inboxState.recoveryIdentifier).toEqual(await signer.getIdentifier());\n\n    await client.changeRecoveryIdentifier(await signer2.getIdentifier());\n\n    const inboxState2 = await client.preferences.inboxState();\n    expect(inboxState2.recoveryIdentifier).toEqual(\n      await signer2.getIdentifier(),\n    );\n  });\n\n  it(\"should read key package lifetime for specific installations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const client3 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    const inboxState = await client3.preferences.inboxState(true);\n    expect(inboxState.installations.length).toBe(3);\n\n    const keyPackageStatuses =\n      await client3.getKeyPackageStatusesForInstallationIds([\n        client.installationId,\n        client2.installationId,\n        client3.installationId,\n      ]);\n    expect(\n      (keyPackageStatuses[client.installationId].lifetime?.notAfter ?? 0n) -\n        (keyPackageStatuses[client.installationId].lifetime?.notBefore ?? 0n),\n    ).toEqual(BigInt(3600 * 24 * 28 * 3 + 3600));\n  });\n\n  it(\"should create a client without a signer\", async () => {\n    const user = createUser();\n    const identifier = createIdentifier(user);\n    const client = await buildClient(identifier);\n    expect(client).toBeDefined();\n    expect(client.accountIdentifier).toEqual(identifier);\n    expect(client.isRegistered).toBe(false);\n    expect(client.inboxId).toBeDefined();\n    expect(client.installationId).toBeDefined();\n    expect(client.signer).toBeUndefined();\n\n    const user2 = createUser();\n    const signer2 = createSigner(user2);\n\n    await expect(() => client.register()).rejects.toThrow(\n      new SignerUnavailableError(),\n    );\n\n    await expect(async () =>\n      client.removeAccount(await signer2.getIdentifier()),\n    ).rejects.toThrow();\n\n    await expect(() => client.revokeInstallations([])).rejects.toThrow();\n\n    await expect(() => client.revokeAllOtherInstallations()).rejects.toThrow();\n\n    await expect(async () =>\n      client.changeRecoveryIdentifier(await signer2.getIdentifier()),\n    ).rejects.toThrow();\n  });\n\n  it(\"should throw errors when client is not initialized\", async () => {\n    const client = new Client({ env: \"local\" });\n\n    await expect(async () =>\n      client.unsafe_createInboxSignatureRequest(),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () =>\n      client.unsafe_addAccountSignatureRequest(createIdentifier(createUser())),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () =>\n      client.unsafe_removeAccountSignatureRequest(\n        createIdentifier(createUser()),\n      ),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () =>\n      client.unsafe_revokeAllOtherInstallationsSignatureRequest(),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () =>\n      client.unsafe_revokeInstallationsSignatureRequest([new Uint8Array()]),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () =>\n      client.unsafe_changeRecoveryIdentifierSignatureRequest(\n        createIdentifier(createUser()),\n      ),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () =>\n      client.unsafe_addAccount(createSigner(createUser())),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () =>\n      client.changeRecoveryIdentifier(createIdentifier(createUser())),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () =>\n      client.removeAccount(createIdentifier(createUser())),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () =>\n      client.revokeAllOtherInstallations(),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () =>\n      client.revokeInstallations([new Uint8Array()]),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () => client.register()).rejects.toThrow(\n      new ClientNotInitializedError(),\n    );\n    await expect(async () =>\n      client.canMessage([createIdentifier(createUser())]),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () =>\n      client.getKeyPackageStatusesForInstallationIds([]),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    await expect(async () =>\n      client.getInboxIdByIdentifier(createIdentifier(createUser())),\n    ).rejects.toThrow(new ClientNotInitializedError());\n    expect(() => client.signWithInstallationKey(\"gm1\")).toThrow(\n      new ClientNotInitializedError(),\n    );\n    expect(() =>\n      client.verifySignedWithInstallationKey(\"gm1\", new Uint8Array()),\n    ).toThrow(new ClientNotInitializedError());\n    expect(() => client.conversations).toThrow(new ClientNotInitializedError());\n    expect(() => client.preferences).toThrow(new ClientNotInitializedError());\n    expect(() => client.inboxId).toThrow(new ClientNotInitializedError());\n    expect(() => client.installationId).toThrow(\n      new ClientNotInitializedError(),\n    );\n    expect(() => client.installationIdBytes).toThrow(\n      new ClientNotInitializedError(),\n    );\n    expect(() => client.isRegistered).toThrow(new ClientNotInitializedError());\n  });\n\n  it(\"should get inbox states from inbox IDs without a client\", async () => {\n    const user = createUser();\n    const user2 = createUser();\n    const signer = createSigner(user);\n    const signer2 = createSigner(user2);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer2);\n    const inboxStates = await Client.inboxStateFromInboxIds(\n      [client.inboxId],\n      \"local\",\n    );\n    expect(inboxStates.length).toBe(1);\n    expect(inboxStates[0].inboxId).toBe(client.inboxId);\n    expect(inboxStates[0].identifiers).toEqual([await signer.getIdentifier()]);\n\n    const inboxStates2 = await Client.inboxStateFromInboxIds(\n      [client2.inboxId],\n      \"local\",\n    );\n    expect(inboxStates2.length).toBe(1);\n    expect(inboxStates2[0].inboxId).toBe(client2.inboxId);\n    expect(inboxStates2[0].identifiers).toEqual([\n      await signer2.getIdentifier(),\n    ]);\n  });\n\n  it(\"should support a callback function for dynamic database creation\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const baseDir = os.tmpdir();\n\n    const client = await Client.create(signer, {\n      dbPath: (inboxId: string) => path.join(baseDir, `user-${inboxId}.db3`),\n    });\n    expect(client).toBeDefined();\n\n    const database = path.join(baseDir, `user-${client.inboxId}.db3`);\n    expect(fs.existsSync(database)).toBe(true);\n  });\n\n  it(\"should create a client without encryption key\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n\n    const client = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n\n    expect(client).toBeDefined();\n    expect(client.inboxId).toBeDefined();\n  });\n\n  it(\"should create a client with Uint8Array encryption key\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const encryptionKey = new Uint8Array(32).fill(1);\n\n    const client = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n      dbEncryptionKey: encryptionKey,\n    });\n\n    expect(client).toBeDefined();\n  });\n\n  it(\"should create a client with hex string encryption key with 0x prefix\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const encryptionKey =\n      \"0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\";\n\n    const client = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n      dbEncryptionKey: encryptionKey,\n    });\n\n    expect(client).toBeDefined();\n  });\n});\n",
      "size_bytes": 20800
    },
    "apps/xmtp.chat/src/components/Messages/ActionsContent.tsx": {
      "content": "import { Button, Paper, Stack, type ButtonVariant } from \"@mantine/core\";\nimport { isAfter, parseISO } from \"date-fns\";\nimport { useCallback } from \"react\";\nimport BreakableText from \"@/components/Messages/BreakableText\";\nimport type { Action, Actions } from \"@/content-types/Actions\";\nimport { ContentTypeIntent, type Intent } from \"@/content-types/Intent\";\nimport { useConversationContext } from \"@/contexts/ConversationContext\";\nimport { useConversation } from \"@/hooks/useConversation\";\n\nexport type ActionsContentProps = {\n  content: Actions;\n};\n\nconst styleToVariantMap: Record<Required<Action>[\"style\"], ButtonVariant> = {\n  primary: \"filled\",\n  secondary: \"default\",\n  danger: \"filled\",\n};\n\nconst styleToColorMap: Record<Required<Action>[\"style\"], string | undefined> = {\n  primary: undefined,\n  secondary: undefined,\n  danger: \"red\",\n};\n\nexport const ActionsContent: React.FC<ActionsContentProps> = ({ content }) => {\n  const { conversationId } = useConversationContext();\n  const { send } = useConversation(conversationId);\n  const handleActionClick = useCallback(\n    (actionId: string) => {\n      const intent: Intent = {\n        id: content.id,\n        actionId,\n      };\n      void send(intent, ContentTypeIntent);\n    },\n    [send, content],\n  );\n  const actionsExpiration = content.expiresAt\n    ? parseISO(content.expiresAt)\n    : undefined;\n  return (\n    <Paper p=\"sm\" radius=\"md\" withBorder>\n      <Stack gap=\"xxs\">\n        <BreakableText>{content.description}</BreakableText>\n        {content.actions.map((action) => {\n          const actionExpiration = action.expiresAt\n            ? parseISO(action.expiresAt)\n            : undefined;\n          const expiration = actionExpiration ?? actionsExpiration;\n          const isExpired = expiration && isAfter(Date.now(), expiration);\n          return (\n            <Button\n              key={action.id}\n              disabled={isExpired}\n              title={isExpired ? \"This action has expired\" : undefined}\n              variant={\n                action.style ? styleToVariantMap[action.style] : \"filled\"\n              }\n              color={action.style ? styleToColorMap[action.style] : undefined}\n              onClick={() => {\n                if (!isExpired) {\n                  handleActionClick(action.id);\n                }\n              }}>\n              {action.label}\n            </Button>\n          );\n        })}\n      </Stack>\n    </Paper>\n  );\n};\n",
      "size_bytes": 2431
    },
    "apps/xmtp.chat/src/stores/inbox/hooks.ts": {
      "content": "import {\n  type Conversation,\n  type DecodedMessage,\n  type SafeGroupMember,\n} from \"@xmtp/browser-sdk\";\nimport { useMemo } from \"react\";\nimport { useStore } from \"zustand\";\nimport type { ContentTypes } from \"@/contexts/XMTPContext\";\nimport { inboxStore, type ConversationMetadata } from \"@/stores/inbox/store\";\n\nconst EMPTY_METADATA: ConversationMetadata = {};\nconst EMPTY_MEMBERS = new Map<string, SafeGroupMember>();\nconst EMPTY_MESSAGES: DecodedMessage<ContentTypes>[] = [];\n\nexport const useConversation = (\n  conversationId: string,\n): Conversation<ContentTypes> | undefined => {\n  return useStore(inboxStore, (state) => state.getConversation(conversationId));\n};\n\nexport const useMetadata = (conversationId: string) => {\n  return useStore(\n    inboxStore,\n    (state) => state.metadata.get(conversationId) ?? EMPTY_METADATA,\n  );\n};\n\nexport const useMembers = (conversationId: string) => {\n  return useStore(\n    inboxStore,\n    (state) => state.members.get(conversationId) ?? EMPTY_MEMBERS,\n  );\n};\n\nexport const useConversations = () => {\n  return useStore(inboxStore, (state) => state.sortedConversations);\n};\n\nexport const useLastCreatedAt = () => {\n  return useStore(inboxStore, (state) => state.lastCreatedAt);\n};\n\nexport const useMessage = (conversationId: string, messageId: string) => {\n  return useStore(inboxStore, (state) =>\n    state.getMessage(conversationId, messageId),\n  );\n};\n\nexport const useMessageCount = () => {\n  const messages = useStore(inboxStore, (state) => state.sortedMessages);\n  return useMemo(() => {\n    const count = Array.from(messages.keys()).reduce((acc, conversationId) => {\n      const count = messages.get(conversationId)?.length ?? 0;\n      return acc + count;\n    }, 0);\n    return count;\n  }, [messages]);\n};\n\nexport const useMessages = (conversationId: string) => {\n  return useStore(\n    inboxStore,\n    (state) => state.sortedMessages.get(conversationId) ?? EMPTY_MESSAGES,\n  );\n};\n\nexport const useLastSentAt = (conversationId: string) => {\n  return useStore(inboxStore, (state) => state.lastSentAt.get(conversationId));\n};\n\nexport const useLastSyncedAt = () => {\n  return useStore(inboxStore, (state) => state.lastSyncedAt);\n};\n\nexport const usePermissions = (conversationId: string) => {\n  return useStore(inboxStore, (state) => state.permissions.get(conversationId));\n};\n\nexport const useActions = () => {\n  const addConversation = useStore(\n    inboxStore,\n    (state) => state.addConversation,\n  );\n  const addConversations = useStore(\n    inboxStore,\n    (state) => state.addConversations,\n  );\n  const getConversation = useStore(\n    inboxStore,\n    (state) => state.getConversation,\n  );\n  const hasConversation = useStore(\n    inboxStore,\n    (state) => state.hasConversation,\n  );\n  const addMessage = useStore(inboxStore, (state) => state.addMessage);\n  const addMessages = useStore(inboxStore, (state) => state.addMessages);\n  const getMessage = useStore(inboxStore, (state) => state.getMessage);\n  const getMessages = useStore(inboxStore, (state) => state.getMessages);\n  const hasMessage = useStore(inboxStore, (state) => state.hasMessage);\n  const setLastSyncedAt = useStore(\n    inboxStore,\n    (state) => state.setLastSyncedAt,\n  );\n  const syncPermissions = useStore(\n    inboxStore,\n    (state) => state.syncPermissions,\n  );\n  const syncMembers = useStore(inboxStore, (state) => state.syncMembers);\n  const reset = useStore(inboxStore, (state) => state.reset);\n\n  return {\n    addConversation,\n    addConversations,\n    getConversation,\n    hasConversation,\n    addMessage,\n    addMessages,\n    getMessage,\n    getMessages,\n    hasMessage,\n    setLastSyncedAt,\n    syncPermissions,\n    syncMembers,\n    reset,\n  };\n};\n",
      "size_bytes": 3692
    },
    "apps/xmtp.chat/src/components/Messages/ReactionPopover.tsx": {
      "content": "import {\n  ActionIcon,\n  Box,\n  Button,\n  Group,\n  Popover,\n  SegmentedControl,\n  TextInput,\n} from \"@mantine/core\";\nimport type { DecodedMessage } from \"@xmtp/browser-sdk\";\nimport {\n  ContentTypeReaction,\n  type Reaction,\n} from \"@xmtp/content-type-reaction\";\nimport { useState } from \"react\";\nimport { useConversationContext } from \"@/contexts/ConversationContext\";\nimport { useConversation } from \"@/hooks/useConversation\";\n\nconst EMOJIS = [\"👍\", \"❤️\", \"😂\", \"🔥\", \"😮\", \"🙏\", \"🎉\", \"👀\"];\n\nexport type ReactionBarProps = {\n  message: DecodedMessage;\n};\n\nexport const ReactionPopover: React.FC<ReactionBarProps> = ({ message }) => {\n  const { conversationId } = useConversationContext();\n  const { send } = useConversation(conversationId);\n  const [opened, setOpened] = useState(false);\n  const [schema, setSchema] = useState<Reaction[\"schema\"]>(\"unicode\");\n  const [text, setText] = useState(\"\");\n\n  const sendReaction = async (content: string) => {\n    const payload: Reaction = {\n      action: \"added\",\n      reference: message.id,\n      referenceInboxId: message.senderInboxId,\n      schema,\n      content,\n    };\n    await send(payload, ContentTypeReaction);\n    setOpened(false);\n    setText(\"\");\n    setSchema(\"unicode\");\n  };\n\n  return (\n    <Popover opened={opened} onChange={setOpened} width=\"auto\" position=\"top\">\n      <Popover.Target>\n        <Button\n          size=\"compact-xs\"\n          variant=\"subtle\"\n          onClick={() => {\n            setOpened((opened) => !opened);\n          }}>\n          React\n        </Button>\n      </Popover.Target>\n      <Popover.Dropdown p=\"sm\">\n        <SegmentedControl\n          value={schema}\n          onChange={(schema: string) => {\n            switch (schema) {\n              case \"unicode\":\n              case \"shortcode\":\n                setSchema(schema);\n                break;\n              default:\n                setSchema(\"custom\");\n            }\n          }}\n          data={[\n            { label: \"Unicode\", value: \"unicode\" },\n            { label: \"Shortcode\", value: \"shortcode\" },\n            { label: \"Custom\", value: \"custom\" },\n          ]}\n          mb=\"sm\"\n          size=\"sm\"\n        />\n        <Box\n          style={{\n            height: 36,\n            display: \"flex\",\n            alignItems: \"center\",\n          }}>\n          {schema === \"unicode\" ? (\n            <Group gap={4}>\n              {EMOJIS.map((emoji) => (\n                <ActionIcon\n                  key={emoji}\n                  size=\"sm\"\n                  variant=\"light\"\n                  onClick={() => void sendReaction(emoji)}>\n                  {emoji}\n                </ActionIcon>\n              ))}\n            </Group>\n          ) : (\n            <Group gap=\"sm\">\n              <TextInput\n                value={text}\n                onChange={(event) => {\n                  setText(event.currentTarget.value);\n                }}\n                placeholder={schema === \"shortcode\" ? \":xmtp:\" : \"Enter custom\"}\n                size=\"sm\"\n                style={{ width: 180 }}\n                onKeyDown={(event) => {\n                  if (\n                    event.key === \"Enter\" &&\n                    [\"shortcode\", \"custom\"].includes(schema)\n                  ) {\n                    event.preventDefault();\n                    void sendReaction(text);\n                  }\n                }}\n              />\n              <ActionIcon\n                size=\"sm\"\n                variant=\"filled\"\n                onClick={() => void sendReaction(text)}>\n                ➤\n              </ActionIcon>\n            </Group>\n          )}\n        </Box>\n      </Popover.Dropdown>\n    </Popover>\n  );\n};\n",
      "size_bytes": 3675
    },
    "sdks/browser-sdk/src/constants.ts": {
      "content": "/**\n * Pre-configured URLs for the XMTP network based on the environment\n *\n * @constant\n * @property {string} local - The local URL for the XMTP network\n * @property {string} dev - The development URL for the XMTP network\n * @property {string} production - The production URL for the XMTP network\n */\nexport const ApiUrls = {\n  local: \"http://localhost:5555\",\n  dev: \"https://dev.xmtp.network\",\n  production: \"https://production.xmtp.network\",\n} as const;\n\n/**\n * Pre-configured URLs for the XMTP history sync service based on the environment\n *\n * @constant\n * @property {string} local - The local URL for the XMTP history sync service\n * @property {string} dev - The development URL for the XMTP history sync service\n * @property {string} production - The production URL for the XMTP history sync service\n */\nexport const HistorySyncUrls = {\n  local: \"http://localhost:5558\",\n  dev: \"https://message-history.dev.ephemera.network\",\n  production: \"https://message-history.production.ephemera.network\",\n} as const;\n",
      "size_bytes": 1015
    },
    "content-types/content-type-markdown/vitest.config.ts": {
      "content": "import { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n  },\n});\n",
      "size_bytes": 115
    },
    "apps/xmtp.chat-api-service/src/middleware/json.ts": {
      "content": "import express from \"express\";\n\nexport const jsonMiddleware = express.json({ limit: \"50mb\" });\n",
      "size_bytes": 95
    },
    "apps/xmtp.chat/src/icons/IconArrowBackUp.tsx": {
      "content": "export type IconArrowBackUpProps = Omit<\n  React.SVGProps<SVGSVGElement>,\n  \"width\" | \"height\"\n> & {\n  size?: number;\n};\n\nexport const IconArrowBackUp: React.FC<IconArrowBackUpProps> = ({\n  size = 16,\n  color = \"currentColor\",\n  ...rest\n}) => {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width={size}\n      height={size}\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke={color}\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      {...rest}>\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M9 14l-4 -4l4 -4\" />\n      <path d=\"M5 10h11a4 4 0 1 1 0 8h-1\" />\n    </svg>\n  );\n};\n",
      "size_bytes": 665
    },
    "sdks/browser-sdk/src/DebugInformation.ts": {
      "content": "import type { Client } from \"./Client\";\n\n/**\n * Debug information helpers for the client\n *\n * This class is not intended to be initialized directly.\n */\nexport class DebugInformation<ContentTypes = unknown> {\n  #client: Client<ContentTypes>;\n\n  constructor(client: Client<ContentTypes>) {\n    this.#client = client;\n  }\n\n  apiStatistics() {\n    return this.#client.sendMessage(\n      \"debugInformation.apiStatistics\",\n      undefined,\n    );\n  }\n\n  apiIdentityStatistics() {\n    return this.#client.sendMessage(\n      \"debugInformation.apiIdentityStatistics\",\n      undefined,\n    );\n  }\n\n  apiAggregateStatistics() {\n    return this.#client.sendMessage(\n      \"debugInformation.apiAggregateStatistics\",\n      undefined,\n    );\n  }\n\n  clearAllStatistics() {\n    return this.#client.sendMessage(\n      \"debugInformation.clearAllStatistics\",\n      undefined,\n    );\n  }\n\n  uploadDebugArchive(serverUrl?: string) {\n    return this.#client.sendMessage(\"debugInformation.uploadDebugArchive\", {\n      serverUrl,\n    });\n  }\n}\n",
      "size_bytes": 1021
    },
    "sdks/node-sdk/src/Dm.ts": {
      "content": "import type { Conversation as XmtpConversation } from \"@xmtp/node-bindings\";\nimport type { Client } from \"@/Client\";\nimport { Conversation } from \"@/Conversation\";\n\n/**\n * Represents a direct message conversation between two inboxes\n *\n * This class is not intended to be initialized directly.\n */\nexport class Dm<ContentTypes = unknown> extends Conversation<ContentTypes> {\n  #client: Client<ContentTypes>;\n  #conversation: XmtpConversation;\n\n  /**\n   * Creates a new direct message conversation instance\n   *\n   * @param client - The client instance managing this direct message conversation\n   * @param conversation - The underlying conversation instance\n   * @param isCommitLogForked\n   */\n  constructor(\n    client: Client<ContentTypes>,\n    conversation: XmtpConversation,\n    isCommitLogForked?: boolean | null,\n  ) {\n    super(client, conversation, isCommitLogForked);\n    this.#client = client;\n    this.#conversation = conversation;\n  }\n\n  /**\n   * Retrieves the inbox ID of the other participant in the DM\n   *\n   * @returns Promise that resolves with the peer's inbox ID\n   */\n  get peerInboxId() {\n    return this.#conversation.dmPeerInboxId();\n  }\n\n  async getDuplicateDms() {\n    const duplicateDms = await this.#conversation.findDuplicateDms();\n    return duplicateDms.map((dm) => new Dm(this.#client, dm));\n  }\n}\n",
      "size_bytes": 1330
    },
    "sdks/browser-sdk/src/types/options.ts": {
      "content": "import type { ContentCodec } from \"@xmtp/content-type-primitives\";\nimport type { ApiUrls } from \"@/constants\";\n\nexport type XmtpEnv = keyof typeof ApiUrls;\n\n/**\n * Network options\n */\nexport type NetworkOptions = {\n  /**\n   * Specify which XMTP environment to connect to. (default: `dev`)\n   */\n  env?: XmtpEnv;\n  /**\n   * apiUrl can be used to override the `env` flag and connect to a\n   * specific endpoint\n   */\n  apiUrl?: string;\n  /**\n   * historySyncUrl can be used to override the `env` flag and connect to a\n   * specific endpoint for syncing history\n   */\n  historySyncUrl?: string | null;\n};\n\nexport type ContentOptions = {\n  /**\n   * Allow configuring codecs for additional content types\n   */\n  codecs?: ContentCodec[];\n};\n\n/**\n * Storage options\n */\nexport type StorageOptions = {\n  /**\n   * Path to the local DB\n   *\n   * There are 3 value types that can be used to specify the database path:\n   *\n   * - `undefined` (or excluded from the client options)\n   *    The database will be created in the current working directory and is based on\n   *    the XMTP environment and client inbox ID.\n   *    Example: `xmtp-dev-<inbox-id>.db3`\n   *\n   * - `null`\n   *    No database will be created and all data will be lost once the client disconnects.\n   *\n   * - `string`\n   *    The given path will be used to create the database.\n   *    Example: `./my-db.db3`\n   */\n  dbPath?: string | null;\n  /**\n   * Encryption key for the local DB\n   */\n  dbEncryptionKey?: Uint8Array;\n};\n\nexport type OtherOptions = {\n  /**\n   * Enable structured JSON logging\n   */\n  structuredLogging?: boolean;\n  /**\n   * Enable performance metrics\n   */\n  performanceLogging?: boolean;\n  /**\n   * Logging level\n   */\n  loggingLevel?: \"off\" | \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\";\n  /**\n   * Disable automatic registration when creating a client\n   */\n  disableAutoRegister?: boolean;\n  /**\n   * Disable device sync\n   */\n  disableDeviceSync?: boolean;\n  /**\n   * Custom app version\n   */\n  appVersion?: string;\n  /**\n   * Should debug events be tracked\n   * (default: false)\n   */\n  debugEventsEnabled?: boolean;\n};\n\nexport type ClientOptions = NetworkOptions &\n  ContentOptions &\n  StorageOptions &\n  OtherOptions;\n",
      "size_bytes": 2210
    },
    "content-types/content-type-transaction-reference/src/index.ts": {
      "content": "export {\n  TransactionReferenceCodec,\n  ContentTypeTransactionReference,\n} from \"./TransactionReference\";\nexport type { TransactionReference } from \"./TransactionReference\";\n",
      "size_bytes": 174
    },
    "apps/xmtp.chat/src/components/App/ConnectXMTP.module.css": {
      "content": ".actions {\n  border-top-width: 1px;\n  border-top-style: solid;\n  border-top-color: light-dark(\n    var(--mantine-color-gray-3),\n    var(--mantine-color-dark-4)\n  );\n}\n",
      "size_bytes": 167
    },
    "apps/xmtp.chat/src/components/InboxTools/InboxToolsHeader.tsx": {
      "content": "import { Button, Group } from \"@mantine/core\";\nimport { useNavigate } from \"react-router\";\n\nexport const InboxToolsHeader: React.FC = () => {\n  const navigate = useNavigate();\n\n  return (\n    <Group align=\"center\" flex={1} gap=\"md\" justify=\"space-between\">\n      <Button\n        variant=\"default\"\n        size=\"sm\"\n        onClick={() => {\n          void navigate(\"/\");\n        }}>\n        ← Back to messaging\n      </Button>\n    </Group>\n  );\n};\n",
      "size_bytes": 449
    },
    "sdks/browser-sdk/src/types/actions/conversations.ts": {
      "content": "import type {\n  ConsentState,\n  ConversationType,\n  Identifier,\n} from \"@xmtp/wasm-bindings\";\nimport type {\n  SafeConversation,\n  SafeCreateDmOptions,\n  SafeCreateGroupOptions,\n  SafeHmacKeys,\n  SafeListConversationsOptions,\n  SafeMessage,\n} from \"@/utils/conversions\";\n\nexport type ConversationsAction =\n  | {\n      action: \"conversations.getConversationById\";\n      id: string;\n      result: SafeConversation | undefined;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversations.getMessageById\";\n      id: string;\n      result: SafeMessage | undefined;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"conversations.getDmByInboxId\";\n      id: string;\n      result: SafeConversation | undefined;\n      data: {\n        inboxId: string;\n      };\n    }\n  | {\n      action: \"conversations.list\";\n      id: string;\n      result: SafeConversation[];\n      data: {\n        options?: SafeListConversationsOptions;\n      };\n    }\n  | {\n      action: \"conversations.listGroups\";\n      id: string;\n      result: SafeConversation[];\n      data: {\n        options?: Omit<SafeListConversationsOptions, \"conversation_type\">;\n      };\n    }\n  | {\n      action: \"conversations.listDms\";\n      id: string;\n      result: SafeConversation[];\n      data: {\n        options?: Omit<SafeListConversationsOptions, \"conversation_type\">;\n      };\n    }\n  | {\n      action: \"conversations.newGroupOptimistic\";\n      id: string;\n      result: SafeConversation;\n      data: {\n        options?: SafeCreateGroupOptions;\n      };\n    }\n  | {\n      action: \"conversations.newGroupWithIdentifiers\";\n      id: string;\n      result: SafeConversation;\n      data: {\n        identifiers: Identifier[];\n        options?: SafeCreateGroupOptions;\n      };\n    }\n  | {\n      action: \"conversations.newGroup\";\n      id: string;\n      result: SafeConversation;\n      data: {\n        inboxIds: string[];\n        options?: SafeCreateGroupOptions;\n      };\n    }\n  | {\n      action: \"conversations.newDmWithIdentifier\";\n      id: string;\n      result: SafeConversation;\n      data: {\n        identifier: Identifier;\n        options?: SafeCreateDmOptions;\n      };\n    }\n  | {\n      action: \"conversations.newDm\";\n      id: string;\n      result: SafeConversation;\n      data: {\n        inboxId: string;\n        options?: SafeCreateDmOptions;\n      };\n    }\n  | {\n      action: \"conversations.sync\";\n      id: string;\n      result: undefined;\n      data: undefined;\n    }\n  | {\n      action: \"conversations.syncAll\";\n      id: string;\n      result: undefined;\n      data: {\n        consentStates?: ConsentState[];\n      };\n    }\n  | {\n      action: \"conversations.getHmacKeys\";\n      id: string;\n      result: SafeHmacKeys;\n      data: undefined;\n    }\n  | {\n      action: \"conversations.stream\";\n      id: string;\n      result: undefined;\n      data: {\n        streamId: string;\n        conversationType?: ConversationType;\n      };\n    }\n  | {\n      action: \"conversations.streamAllMessages\";\n      id: string;\n      result: undefined;\n      data: {\n        streamId: string;\n        conversationType?: ConversationType;\n        consentStates?: ConsentState[];\n      };\n    };\n",
      "size_bytes": 3178
    },
    "sdks/browser-sdk/src/workers/client.ts": {
      "content": "import init, {\n  type Consent,\n  type Conversation,\n  type Message,\n  type SignatureRequestHandle,\n  type StreamCloser,\n  type UserPreference,\n} from \"@xmtp/wasm-bindings\";\nimport type {\n  ActionErrorData,\n  ActionName,\n  ActionWithoutResult,\n  ClientWorkerAction,\n  ExtractActionWithoutData,\n} from \"@/types/actions\";\nimport type {\n  ExtractStreamAction,\n  StreamActionErrorData,\n  StreamActionName,\n} from \"@/types/actions/streams\";\nimport {\n  fromEncodedContent,\n  fromSafeEncodedContent,\n  toSafeApiStats,\n  toSafeConsent,\n  toSafeConversation,\n  toSafeConversationDebugInfo,\n  toSafeHmacKey,\n  toSafeIdentityStats,\n  toSafeInboxState,\n  toSafeKeyPackageStatus,\n  toSafeMessage,\n  toSafeMessageDisappearingSettings,\n} from \"@/utils/conversions\";\nimport {\n  ClientNotInitializedError,\n  GroupNotFoundError,\n  StreamNotFoundError,\n} from \"@/utils/errors\";\nimport { WorkerClient } from \"@/WorkerClient\";\nimport { WorkerConversation } from \"@/WorkerConversation\";\n\nlet maybeClient: WorkerClient | undefined;\nlet enableLogging = false;\n\nconst streamClosers = new Map<string, StreamCloser>();\nconst signatureRequests = new Map<string, SignatureRequestHandle>();\n\n/**\n * Type-safe postMessage\n */\nconst postMessage = <A extends ActionName<ClientWorkerAction>>(\n  data: ExtractActionWithoutData<ClientWorkerAction, A>,\n) => {\n  self.postMessage(data);\n};\n\n/**\n * Type-safe postMessage for errors\n */\nconst postMessageError = (data: ActionErrorData<ClientWorkerAction>) => {\n  self.postMessage(data);\n};\n\n/**\n * Type-safe postMessage for streams\n */\nconst postStreamMessage = <A extends StreamActionName>(\n  data: ExtractStreamAction<A>,\n) => {\n  self.postMessage(data);\n};\n\n/**\n * Type-safe postMessage for stream errors\n */\nconst postStreamMessageError = (data: StreamActionErrorData) => {\n  self.postMessage(data);\n};\n\nself.onmessage = async (\n  event: MessageEvent<ActionWithoutResult<ClientWorkerAction>>,\n) => {\n  const { action, id, data } = event.data;\n\n  if (enableLogging) {\n    console.log(\"client worker received event data\", event.data);\n  }\n\n  // initialize WASM module\n  await init();\n\n  try {\n    // init is a special action that initializes the client\n    if (action === \"client.init\" && !maybeClient) {\n      maybeClient = await WorkerClient.create(data.identifier, data.options);\n      enableLogging =\n        data.options?.loggingLevel !== undefined &&\n        data.options.loggingLevel !== \"off\";\n      postMessage({\n        id,\n        action,\n        result: {\n          inboxId: maybeClient.inboxId,\n          installationId: maybeClient.installationId,\n          installationIdBytes: maybeClient.installationIdBytes,\n        },\n      });\n      return;\n    }\n\n    // a client is required for all other actions\n    if (!maybeClient) {\n      throw new ClientNotInitializedError();\n    }\n\n    // let typescript know that a client will be available for the rest\n    // of this code block\n    const client = maybeClient;\n\n    // helper function that throws an error if the group is not found\n    const getGroup = (groupId: string) => {\n      const group = client.conversations.getConversationById(groupId);\n      if (!group) {\n        throw new GroupNotFoundError(groupId);\n      }\n      return group;\n    };\n\n    switch (action) {\n      /**\n       * Stream actions\n       */\n      case \"endStream\": {\n        const streamCloser = streamClosers.get(data.streamId);\n        if (streamCloser) {\n          streamCloser.end();\n          streamClosers.delete(data.streamId);\n          postMessage({ id, action, result: undefined });\n        } else {\n          throw new StreamNotFoundError(data.streamId);\n        }\n        break;\n      }\n      /**\n       * Client actions\n       */\n      case \"client.applySignatureRequest\": {\n        const signatureRequest = signatureRequests.get(data.signatureRequestId);\n        if (!signatureRequest) {\n          throw new Error(\"Signature request not found\");\n        }\n        await client.processSignatureRequest(data.signer, signatureRequest);\n        signatureRequests.delete(data.signatureRequestId);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"client.createInboxSignatureText\": {\n        const result: {\n          signatureText?: string;\n          signatureRequestId?: string;\n        } = {\n          signatureText: undefined,\n          signatureRequestId: undefined,\n        };\n        try {\n          const signatureRequest = client.createInboxSignatureRequest();\n          if (signatureRequest) {\n            result.signatureText = await signatureRequest.signatureText();\n            result.signatureRequestId = data.signatureRequestId;\n            signatureRequests.set(data.signatureRequestId, signatureRequest);\n          }\n        } finally {\n          postMessage({ id, action, result });\n        }\n        break;\n      }\n      case \"client.addAccountSignatureText\": {\n        const signatureRequest = await client.addAccountSignatureRequest(\n          data.newIdentifier,\n        );\n        const result = {\n          signatureText: await signatureRequest.signatureText(),\n          signatureRequestId: data.signatureRequestId,\n        };\n        signatureRequests.set(data.signatureRequestId, signatureRequest);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"client.removeAccountSignatureText\": {\n        const signatureRequest = await client.removeAccountSignatureRequest(\n          data.identifier,\n        );\n        const result = {\n          signatureText: await signatureRequest.signatureText(),\n          signatureRequestId: data.signatureRequestId,\n        };\n        signatureRequests.set(data.signatureRequestId, signatureRequest);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"client.revokeAllOtherInstallationsSignatureText\": {\n        const signatureRequest =\n          await client.revokeAllOtherInstallationsSignatureRequest();\n        const result = {\n          signatureText: await signatureRequest.signatureText(),\n          signatureRequestId: data.signatureRequestId,\n        };\n        signatureRequests.set(data.signatureRequestId, signatureRequest);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"client.revokeInstallationsSignatureText\": {\n        const signatureRequest =\n          await client.revokeInstallationsSignatureRequest(\n            data.installationIds,\n          );\n        const result = {\n          signatureText: await signatureRequest.signatureText(),\n          signatureRequestId: data.signatureRequestId,\n        };\n        signatureRequests.set(data.signatureRequestId, signatureRequest);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"client.changeRecoveryIdentifierSignatureText\": {\n        const signatureRequest =\n          await client.changeRecoveryIdentifierSignatureRequest(\n            data.identifier,\n          );\n        const result = {\n          signatureText: await signatureRequest.signatureText(),\n          signatureRequestId: data.signatureRequestId,\n        };\n        signatureRequests.set(data.signatureRequestId, signatureRequest);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"client.registerIdentity\": {\n        const signatureRequest = signatureRequests.get(data.signatureRequestId);\n        if (!signatureRequest) {\n          throw new Error(\"Signature request not found\");\n        }\n        await client.registerIdentity(data.signer, signatureRequest);\n        signatureRequests.delete(data.signatureRequestId);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"client.addAccount\": {\n        const signatureRequest = signatureRequests.get(data.signatureRequestId);\n        if (!signatureRequest) {\n          throw new Error(\"Signature request not found\");\n        }\n        await client.processSignatureRequest(data.signer, signatureRequest);\n        signatureRequests.delete(data.signatureRequestId);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"client.removeAccount\": {\n        const signatureRequest = signatureRequests.get(data.signatureRequestId);\n        if (!signatureRequest) {\n          throw new Error(\"Signature request not found\");\n        }\n        await client.processSignatureRequest(data.signer, signatureRequest);\n        signatureRequests.delete(data.signatureRequestId);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"client.revokeAllOtherInstallations\": {\n        const signatureRequest = signatureRequests.get(data.signatureRequestId);\n        if (!signatureRequest) {\n          throw new Error(\"Signature request not found\");\n        }\n        await client.processSignatureRequest(data.signer, signatureRequest);\n        signatureRequests.delete(data.signatureRequestId);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"client.revokeInstallations\": {\n        const signatureRequest = signatureRequests.get(data.signatureRequestId);\n        if (!signatureRequest) {\n          throw new Error(\"Signature request not found\");\n        }\n        await client.processSignatureRequest(data.signer, signatureRequest);\n        signatureRequests.delete(data.signatureRequestId);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"client.changeRecoveryIdentifier\": {\n        const signatureRequest = signatureRequests.get(data.signatureRequestId);\n        if (!signatureRequest) {\n          throw new Error(\"Signature request not found\");\n        }\n        await client.processSignatureRequest(data.signer, signatureRequest);\n        signatureRequests.delete(data.signatureRequestId);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"client.isRegistered\": {\n        const result = client.isRegistered;\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"client.canMessage\": {\n        const result = await client.canMessage(data.identifiers);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"client.findInboxIdByIdentifier\": {\n        const result = await client.findInboxIdByIdentifier(data.identifier);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"client.signWithInstallationKey\": {\n        const result = client.signWithInstallationKey(data.signatureText);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"client.verifySignedWithInstallationKey\": {\n        const result = client.verifySignedWithInstallationKey(\n          data.signatureText,\n          data.signatureBytes,\n        );\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"client.verifySignedWithPublicKey\": {\n        const result = client.verifySignedWithPublicKey(\n          data.signatureText,\n          data.signatureBytes,\n          data.publicKey,\n        );\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"client.getKeyPackageStatusesForInstallationIds\": {\n        const result = await client.getKeyPackageStatusesForInstallationIds(\n          data.installationIds,\n        );\n        const safeResult = new Map(\n          Array.from(result.entries()).map(([installationId, status]) => [\n            installationId,\n            toSafeKeyPackageStatus(status),\n          ]),\n        );\n        postMessage({\n          id,\n          action,\n          result: safeResult,\n        });\n        break;\n      }\n      /**\n       * Debug information actions\n       */\n      case \"debugInformation.apiStatistics\": {\n        const apiStats = client.debugInformation.apiStatistics();\n        const result = toSafeApiStats(apiStats);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"debugInformation.apiIdentityStatistics\": {\n        const apiIdentityStats =\n          client.debugInformation.apiIdentityStatistics();\n        const result = toSafeIdentityStats(apiIdentityStats);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"debugInformation.apiAggregateStatistics\": {\n        const result = client.debugInformation.apiAggregateStatistics();\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"debugInformation.clearAllStatistics\": {\n        client.debugInformation.clearAllStatistics();\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"debugInformation.uploadDebugArchive\": {\n        const result = await client.debugInformation.uploadDebugArchive(\n          data.serverUrl,\n        );\n        postMessage({ id, action, result });\n        break;\n      }\n      /**\n       * Preferences actions\n       */\n      case \"preferences.inboxState\": {\n        const inboxState = await client.preferences.inboxState(\n          data.refreshFromNetwork,\n        );\n        const result = toSafeInboxState(inboxState);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"preferences.inboxStateFromInboxIds\": {\n        const inboxStates = await client.preferences.inboxStateFromInboxIds(\n          data.inboxIds,\n          data.refreshFromNetwork,\n        );\n        const result = inboxStates.map(toSafeInboxState);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"preferences.getLatestInboxState\": {\n        const inboxState = await client.preferences.getLatestInboxState(\n          data.inboxId,\n        );\n        const result = toSafeInboxState(inboxState);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"preferences.setConsentStates\": {\n        await client.preferences.setConsentStates(data.records);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"preferences.getConsentState\": {\n        const result = await client.preferences.getConsentState(\n          data.entityType,\n          data.entity,\n        );\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"preferences.sync\": {\n        const result = await client.preferences.sync();\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"preferences.streamConsent\": {\n        const streamCallback = (\n          error: Error | null,\n          value: Consent[] | undefined,\n        ) => {\n          if (error) {\n            postStreamMessageError({\n              action: \"stream.consent\",\n              streamId: data.streamId,\n              error,\n            });\n          } else {\n            postStreamMessage({\n              action: \"stream.consent\",\n              streamId: data.streamId,\n              result: value?.map(toSafeConsent) ?? [],\n            });\n          }\n        };\n        const streamCloser = client.preferences.streamConsent(\n          streamCallback,\n          () => {\n            streamClosers.delete(data.streamId);\n            postStreamMessage({\n              action: \"stream.fail\",\n              streamId: data.streamId,\n              result: undefined,\n            });\n          },\n        );\n        streamClosers.set(data.streamId, streamCloser);\n        postMessage({\n          id,\n          action,\n          result: undefined,\n        });\n        break;\n      }\n      case \"preferences.streamPreferences\": {\n        const streamCallback = (\n          error: Error | null,\n          value: UserPreference[] | undefined,\n        ) => {\n          if (error) {\n            postStreamMessageError({\n              action: \"stream.preferences\",\n              streamId: data.streamId,\n              error,\n            });\n          } else {\n            postStreamMessage({\n              action: \"stream.preferences\",\n              streamId: data.streamId,\n              result: value ?? undefined,\n            });\n          }\n        };\n        const streamCloser = client.preferences.streamPreferences(\n          streamCallback,\n          () => {\n            streamClosers.delete(data.streamId);\n            postStreamMessage({\n              action: \"stream.fail\",\n              streamId: data.streamId,\n              result: undefined,\n            });\n          },\n        );\n        streamClosers.set(data.streamId, streamCloser);\n        postMessage({\n          id,\n          action,\n          result: undefined,\n        });\n        break;\n      }\n      /**\n       * Conversations actions\n       */\n      case \"conversations.stream\": {\n        const streamCallback = (\n          error: Error | null,\n          value: Conversation | undefined,\n        ) => {\n          if (error) {\n            postStreamMessageError({\n              action: \"stream.conversation\",\n              streamId: data.streamId,\n              error,\n            });\n          } else {\n            if (value) {\n              toSafeConversation(new WorkerConversation(client, value))\n                .then((result) => {\n                  postStreamMessage({\n                    action: \"stream.conversation\",\n                    streamId: data.streamId,\n                    result,\n                  });\n                })\n                .catch((error: unknown) => {\n                  postStreamMessageError({\n                    action: \"stream.conversation\",\n                    streamId: data.streamId,\n                    error: error as Error,\n                  });\n                });\n            } else {\n              postStreamMessage({\n                action: \"stream.conversation\",\n                streamId: data.streamId,\n                result: undefined,\n              });\n            }\n          }\n        };\n        const streamCloser = client.conversations.stream(\n          streamCallback,\n          () => {\n            streamClosers.delete(data.streamId);\n            postStreamMessage({\n              action: \"stream.fail\",\n              streamId: data.streamId,\n              result: undefined,\n            });\n          },\n          data.conversationType,\n        );\n        streamClosers.set(data.streamId, streamCloser);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"conversations.streamAllMessages\": {\n        const streamCallback = (\n          error: Error | null,\n          value: Message | undefined,\n        ) => {\n          if (error) {\n            postStreamMessageError({\n              action: \"stream.message\",\n              streamId: data.streamId,\n              error,\n            });\n          } else {\n            postStreamMessage({\n              action: \"stream.message\",\n              streamId: data.streamId,\n              result: value ? toSafeMessage(value) : undefined,\n            });\n          }\n        };\n        const streamCloser = client.conversations.streamAllMessages(\n          streamCallback,\n          () => {\n            streamClosers.delete(data.streamId);\n            postStreamMessage({\n              action: \"stream.fail\",\n              streamId: data.streamId,\n              result: undefined,\n            });\n          },\n          data.conversationType,\n          data.consentStates,\n        );\n        streamClosers.set(data.streamId, streamCloser);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"conversations.list\": {\n        const conversations = client.conversations.list(data.options);\n        const result = await Promise.all(\n          conversations.map((conversation) => toSafeConversation(conversation)),\n        );\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversations.listGroups\": {\n        const conversations = client.conversations.listGroups(data.options);\n        const result = await Promise.all(\n          conversations.map((conversation) => toSafeConversation(conversation)),\n        );\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversations.listDms\": {\n        const conversations = client.conversations.listDms(data.options);\n        const result = await Promise.all(\n          conversations.map((conversation) => toSafeConversation(conversation)),\n        );\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversations.newGroupOptimistic\": {\n        const conversation = client.conversations.newGroupOptimistic(\n          data.options,\n        );\n        const result = await toSafeConversation(conversation);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversations.newGroupWithIdentifiers\": {\n        const conversation = await client.conversations.newGroupWithIdentifiers(\n          data.identifiers,\n          data.options,\n        );\n        const result = await toSafeConversation(conversation);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversations.newGroup\": {\n        const conversation = await client.conversations.newGroup(\n          data.inboxIds,\n          data.options,\n        );\n        const result = await toSafeConversation(conversation);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversations.newDmWithIdentifier\": {\n        const conversation = await client.conversations.newDmWithIdentifier(\n          data.identifier,\n          data.options,\n        );\n        const result = await toSafeConversation(conversation);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversations.newDm\": {\n        const conversation = await client.conversations.newDm(\n          data.inboxId,\n          data.options,\n        );\n        const result = await toSafeConversation(conversation);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversations.sync\": {\n        await client.conversations.sync();\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"conversations.syncAll\": {\n        await client.conversations.syncAll(data.consentStates);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"conversations.getConversationById\": {\n        const conversation = client.conversations.getConversationById(data.id);\n        const result = conversation\n          ? await toSafeConversation(conversation)\n          : undefined;\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversations.getMessageById\": {\n        const message = client.conversations.getMessageById(data.id);\n        const result = message ? toSafeMessage(message) : undefined;\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversations.getDmByInboxId\": {\n        const conversation = client.conversations.getDmByInboxId(data.inboxId);\n        const result = conversation\n          ? await toSafeConversation(conversation)\n          : undefined;\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversations.getHmacKeys\": {\n        const hmacKeys = client.conversations.getHmacKeys();\n        const result = Object.fromEntries(\n          Array.from(hmacKeys.entries()).map(([groupId, hmacKeys]) => [\n            groupId,\n            hmacKeys.map(toSafeHmacKey),\n          ]),\n        );\n        postMessage({ id, action, result });\n        break;\n      }\n      /**\n       * Group actions\n       */\n      case \"conversation.sync\": {\n        const group = getGroup(data.id);\n        await group.sync();\n        const result = await toSafeConversation(group);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversation.lastMessage\": {\n        const group = getGroup(data.id);\n        const result = await group.lastMessage();\n        postMessage({\n          id,\n          action,\n          result: result ? toSafeMessage(result) : undefined,\n        });\n        break;\n      }\n      case \"conversation.isActive\": {\n        const group = getGroup(data.id);\n        const result = group.isActive;\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversation.consentState\": {\n        const group = getGroup(data.id);\n        const result = group.consentState;\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversation.updateConsentState\": {\n        const group = getGroup(data.id);\n        group.updateConsentState(data.state);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"group.updateName\": {\n        const group = getGroup(data.id);\n        await group.updateName(data.name);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"group.updateDescription\": {\n        const group = getGroup(data.id);\n        await group.updateDescription(data.description);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"group.updateImageUrl\": {\n        const group = getGroup(data.id);\n        await group.updateImageUrl(data.imageUrl);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"conversation.send\": {\n        const group = getGroup(data.id);\n        const result = await group.send(\n          fromEncodedContent(fromSafeEncodedContent(data.content)),\n        );\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversation.sendOptimistic\": {\n        const group = getGroup(data.id);\n        const result = group.sendOptimistic(\n          fromEncodedContent(fromSafeEncodedContent(data.content)),\n        );\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversation.publishMessages\": {\n        const group = getGroup(data.id);\n        await group.publishMessages();\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"conversation.messages\": {\n        const group = getGroup(data.id);\n        const messages = await group.messages(data.options);\n        const result = messages.map((message) => toSafeMessage(message));\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversation.members\": {\n        const group = getGroup(data.id);\n        const result = await group.members();\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"group.listAdmins\": {\n        const group = getGroup(data.id);\n        const result = group.admins;\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"group.listSuperAdmins\": {\n        const group = getGroup(data.id);\n        const result = group.superAdmins;\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"group.addAdmin\": {\n        const group = getGroup(data.id);\n        await group.addAdmin(data.inboxId);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"group.removeAdmin\": {\n        const group = getGroup(data.id);\n        await group.removeAdmin(data.inboxId);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"group.addSuperAdmin\": {\n        const group = getGroup(data.id);\n        await group.addSuperAdmin(data.inboxId);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"group.removeSuperAdmin\": {\n        const group = getGroup(data.id);\n        await group.removeSuperAdmin(data.inboxId);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"group.addMembersByIdentifiers\": {\n        const group = getGroup(data.id);\n        await group.addMembersByIdentifiers(data.identifiers);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"group.removeMembersByIdentifiers\": {\n        const group = getGroup(data.id);\n        await group.removeMembersByIdentifiers(data.identifiers);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"group.addMembers\": {\n        const group = getGroup(data.id);\n        await group.addMembers(data.inboxIds);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"group.removeMembers\": {\n        const group = getGroup(data.id);\n        await group.removeMembers(data.inboxIds);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"group.isAdmin\": {\n        const group = getGroup(data.id);\n        const result = group.isAdmin(data.inboxId);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"group.isSuperAdmin\": {\n        const group = getGroup(data.id);\n        const result = group.isSuperAdmin(data.inboxId);\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"dm.peerInboxId\": {\n        const group = getGroup(data.id);\n        const result = group.dmPeerInboxId();\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"group.updatePermission\": {\n        const group = getGroup(data.id);\n        await group.updatePermission(\n          data.permissionType,\n          data.policy,\n          data.metadataField,\n        );\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"group.permissions\": {\n        const group = getGroup(data.id);\n        const safeConversation = await toSafeConversation(group);\n        const result = safeConversation.permissions;\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversation.messageDisappearingSettings\": {\n        const group = getGroup(data.id);\n        const settings = group.messageDisappearingSettings();\n        const result = settings\n          ? toSafeMessageDisappearingSettings(settings)\n          : undefined;\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversation.updateMessageDisappearingSettings\": {\n        const group = getGroup(data.id);\n        await group.updateMessageDisappearingSettings(data.fromNs, data.inNs);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"conversation.removeMessageDisappearingSettings\": {\n        const group = getGroup(data.id);\n        await group.removeMessageDisappearingSettings();\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"conversation.isMessageDisappearingEnabled\": {\n        const group = getGroup(data.id);\n        const result = group.isMessageDisappearingEnabled();\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversation.stream\": {\n        const group = getGroup(data.groupId);\n        const streamCallback = (\n          error: Error | null,\n          value: Message | undefined,\n        ) => {\n          if (error) {\n            postStreamMessageError({\n              action: \"stream.message\",\n              streamId: data.streamId,\n              error,\n            });\n          } else {\n            postStreamMessage({\n              action: \"stream.message\",\n              streamId: data.streamId,\n              result: value ? toSafeMessage(value) : undefined,\n            });\n          }\n        };\n        const streamCloser = group.stream(streamCallback, () => {\n          streamClosers.delete(data.streamId);\n          postStreamMessage({\n            action: \"stream.fail\",\n            streamId: data.streamId,\n            result: undefined,\n          });\n        });\n        streamClosers.set(data.streamId, streamCloser);\n        postMessage({ id, action, result: undefined });\n        break;\n      }\n      case \"conversation.pausedForVersion\": {\n        const group = getGroup(data.id);\n        const result = group.pausedForVersion();\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversation.getHmacKeys\": {\n        const group = getGroup(data.id);\n        const result = group.getHmacKeys();\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"dm.getDuplicateDms\": {\n        const group = getGroup(data.id);\n        const dms = await group.getDuplicateDms();\n        const result = await Promise.all(\n          dms.map((dm) => toSafeConversation(dm)),\n        );\n        postMessage({ id, action, result });\n        break;\n      }\n      case \"conversation.debugInfo\": {\n        const group = getGroup(data.id);\n        const debugInfo = await group.debugInfo();\n        const result = toSafeConversationDebugInfo(debugInfo);\n        postMessage({ id, action, result });\n        break;\n      }\n    }\n  } catch (e) {\n    postMessageError({\n      id,\n      action,\n      error: e as Error,\n    });\n  }\n};\n",
      "size_bytes": 32631
    },
    "apps/xmtp.chat/src/components/Conversations/ConversationsNavbar.module.css": {
      "content": ".shell {\n  height: 100%;\n  border-radius: 24px;\n  background:\n    linear-gradient(180deg, rgba(6, 9, 20, 0.88), rgba(6, 9, 20, 0.72));\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  box-shadow: 0 28px 48px rgba(4, 8, 20, 0.4);\n  backdrop-filter: blur(14px);\n}\n\n.header {\n  padding: var(--mantine-spacing-md);\n  background: transparent;\n  border-bottom: 1px solid rgba(148, 163, 184, 0.12);\n}\n\n.header :global(.mantine-Badge-root) {\n  padding-inline: var(--mantine-spacing-xs);\n  background: rgba(10, 255, 241, 0.16);\n  border: 1px solid rgba(10, 255, 241, 0.28);\n  color: #0afff1;\n}\n\n.content {\n  padding: var(--mantine-spacing-md);\n  display: flex;\n  flex-direction: column;\n  gap: var(--mantine-spacing-sm);\n}\n\n.empty {\n  color: rgba(203, 213, 225, 0.7);\n}\n\n@media (max-width: 768px) {\n  .shell {\n    border-radius: 20px;\n    border-color: rgba(148, 163, 184, 0.16);\n  }\n\n  .content {\n    padding: var(--mantine-spacing-md) var(--mantine-spacing-sm);\n  }\n}\n\n@media (max-width: 520px) {\n  .header {\n    padding: var(--mantine-spacing-sm) var(--mantine-spacing-xs);\n  }\n\n  .content {\n    padding: var(--mantine-spacing-sm) var(--mantine-spacing-xs);\n  }\n}\n",
      "size_bytes": 1158
    },
    "content-types/content-type-primitives/CHANGELOG.md": {
      "content": "# @xmtp/content-type-primitives\n\n## 2.0.2\n\n### Patch Changes\n\n- 592b5ff:\n  - Converted `any` types to `unknown`\n  - Removed `@deprecated` tag from `CodecRegistry` type\n  - Refactored `registry` type of the `encode` and `decode` codec methods\n\n## 2.0.1\n\n### Patch Changes\n\n- 340fcf4: Upgraded `@xmtp/proto` dependency\n\n## 2.0.0\n\n### Major Changes\n\n- 1777a23: Dropped support for CommonJS\n\n## 1.0.3\n\n### Patch Changes\n\n- 63e5276: Upgraded `@xmtp/proto` dependency\n\n## 1.0.2\n\n### Patch Changes\n\n- 9addb1c: Added new parameter to `ContentCodec` generic type to allow typing of content parameters\n\n## 1.0.1\n\n### Patch Changes\n\n- [#71](https://github.com/xmtp/xmtp-js-content-types/pull/71) [`52bf31e`](https://github.com/xmtp/xmtp-js-content-types/commit/52bf31ec9d9b78da321727745d0a37bfa617362a) - Add more primitive types\n\n## 1.0.0\n\nInitial release\n",
      "size_bytes": 846
    },
    "apps/xmtp.chat/src/components/Messages/FallbackContent.tsx": {
      "content": "import { Paper, Text } from \"@mantine/core\";\nimport classes from \"./TextContent.module.css\";\n\nexport type FallbackContentProps = {\n  text: string;\n};\n\nexport const FallbackContent: React.FC<FallbackContentProps> = ({ text }) => {\n  return (\n    <Paper className={classes.text} withBorder py=\"xs\" px=\"sm\" radius=\"md\">\n      <Text\n        component=\"pre\"\n        style={{\n          whiteSpace: \"pre-wrap\",\n          wordBreak: \"break-word\",\n          fontFamily: \"inherit\",\n        }}>\n        {text}\n      </Text>\n    </Paper>\n  );\n};\n",
      "size_bytes": 534
    },
    "sdks/browser-sdk/src/ClientWorkerClass.ts": {
      "content": "import { v4 } from \"uuid\";\nimport type {\n  ActionErrorData,\n  ActionName,\n  ActionWithoutData,\n  ClientWorkerAction,\n  ExtractActionData,\n  ExtractActionResult,\n} from \"@/types/actions\";\nimport type {\n  StreamAction,\n  StreamActionErrorData,\n} from \"@/types/actions/streams\";\nimport type { StreamOptions } from \"@/utils/streams\";\n\nconst handleError = (event: ErrorEvent) => {\n  console.error(event.message);\n};\n\n/**\n * Class that sets up a worker and provides communications for client functions\n *\n * This class is not meant to be used directly, it is extended by the Client class\n * to provide an interface to the worker.\n *\n * @param worker - The worker to use for the client class\n * @param enableLogging - Whether to enable logging in the worker\n * @returns A new ClientWorkerClass instance\n */\nexport class ClientWorkerClass {\n  #worker: Worker;\n\n  #enableLogging: boolean;\n\n  #promises = new Map<\n    string,\n    {\n      resolve: (value: unknown) => void;\n      reject: (reason?: unknown) => void;\n    }\n  >();\n\n  constructor(worker: Worker, enableLogging: boolean) {\n    this.#worker = worker;\n    this.#worker.addEventListener(\"message\", this.handleMessage);\n    if (enableLogging) {\n      this.#worker.addEventListener(\"error\", handleError);\n    }\n    this.#enableLogging = enableLogging;\n  }\n\n  /**\n   * Sends an action message to the client worker\n   *\n   * @param action - The action to send to the worker\n   * @param data - The data to send to the worker\n   * @returns A promise that resolves when the action is completed\n   */\n  sendMessage<A extends ActionName<ClientWorkerAction>>(\n    action: A,\n    data: ExtractActionData<ClientWorkerAction, A>,\n  ) {\n    const promiseId = v4();\n    this.#worker.postMessage({\n      action,\n      id: promiseId,\n      data,\n    });\n    const promise = new Promise((resolve, reject) => {\n      this.#promises.set(promiseId, {\n        resolve: resolve as (value: unknown) => void,\n        reject,\n      });\n    });\n    return promise as [ExtractActionResult<ClientWorkerAction, A>] extends [\n      undefined,\n    ]\n      ? Promise<void>\n      : Promise<ExtractActionResult<ClientWorkerAction, A>>;\n  }\n\n  /**\n   * Handles a message from the client worker\n   *\n   * @param event - The event to handle\n   */\n  handleMessage = (\n    event: MessageEvent<\n      | ActionWithoutData<ClientWorkerAction>\n      | ActionErrorData<ClientWorkerAction>\n    >,\n  ) => {\n    const eventData = event.data;\n    if (this.#enableLogging) {\n      console.log(\"client received event data\", eventData);\n    }\n    const promise = this.#promises.get(eventData.id);\n    if (promise) {\n      this.#promises.delete(eventData.id);\n      if (\"error\" in eventData) {\n        promise.reject(eventData.error);\n      } else {\n        promise.resolve(eventData.result);\n      }\n    }\n  };\n\n  /**\n   * Handles a stream message from the client worker\n   *\n   * @param streamId - The ID of the stream to handle\n   * @param callback - The callback to handle the stream message\n   * @returns A function to remove the stream handler\n   */\n  handleStreamMessage = <T extends StreamAction[\"result\"], V = T>(\n    streamId: string,\n    callback: (error: Error | null, value: T | undefined) => void,\n    options?: StreamOptions<T, V>,\n  ) => {\n    const streamHandler = (\n      event: MessageEvent<StreamAction | StreamActionErrorData>,\n    ) => {\n      const eventData = event.data;\n      // only handle messages for the passed stream ID\n      if (eventData.streamId === streamId) {\n        // if the stream failed, call the onFail callback\n        if (eventData.action === \"stream.fail\") {\n          options?.onFail?.();\n          return;\n        }\n        if (\"error\" in eventData) {\n          callback(eventData.error, undefined);\n        } else {\n          callback(null, eventData.result as T);\n        }\n      }\n    };\n    this.#worker.addEventListener(\"message\", streamHandler);\n\n    return async () => {\n      await this.sendMessage(\"endStream\", {\n        streamId,\n      });\n      this.#worker.removeEventListener(\"message\", streamHandler);\n    };\n  };\n\n  /**\n   * Removes all event listeners and terminates the worker\n   */\n  close() {\n    this.#worker.removeEventListener(\"message\", this.handleMessage);\n    if (this.#enableLogging) {\n      this.#worker.removeEventListener(\"error\", handleError);\n    }\n    this.#worker.terminate();\n  }\n}\n",
      "size_bytes": 4359
    },
    "sdks/browser-sdk/src/Utils.ts": {
      "content": "import type { Identifier } from \"@xmtp/wasm-bindings\";\nimport { v4 } from \"uuid\";\nimport type { XmtpEnv } from \"@/types/options\";\nimport { toSafeSigner, type Signer } from \"@/utils/signer\";\nimport { UtilsWorkerClass } from \"@/UtilsWorkerClass\";\n\n/**\n * Utility class that provides helper functions for XMTP inbox IDs\n */\nexport class Utils extends UtilsWorkerClass {\n  /**\n   * Creates a new Utils instance\n   *\n   * @param enableLogging - Optional flag to enable logging\n   */\n  constructor(enableLogging?: boolean) {\n    const worker = new Worker(new URL(\"./workers/utils\", import.meta.url), {\n      type: \"module\",\n    });\n    super(worker, enableLogging ?? false);\n  }\n\n  /**\n   * Generates an inbox ID for a given identifier\n   *\n   * @param identifier - The identifier to generate an inbox ID for\n   * @returns Promise that resolves with the generated inbox ID\n   */\n  async generateInboxId(identifier: Identifier) {\n    return this.sendMessage(\"utils.generateInboxId\", {\n      identifier,\n    });\n  }\n\n  /**\n   * Gets the inbox ID for a specific identifier and optional environment\n   *\n   * @param identifier - The identifier to get the inbox ID for\n   * @param env - Optional XMTP environment configuration (default: \"dev\")\n   * @returns Promise that resolves with the inbox ID for the identifier\n   */\n  async getInboxIdForIdentifier(identifier: Identifier, env?: XmtpEnv) {\n    return this.sendMessage(\"utils.getInboxIdForIdentifier\", {\n      identifier,\n      env,\n    });\n  }\n\n  /**\n   * Creates signature text for revoking installations\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `revokeInstallations` method instead.\n   *\n   * @param env - The environment to use\n   * @param identifier - The identifier to revoke installations for\n   * @param inboxId - The inbox ID to revoke installations for\n   * @param installationIds - The installation IDs to revoke\n   * @returns The signature text and signature request ID\n   */\n  async revokeInstallationsSignatureText(\n    identifier: Identifier,\n    inboxId: string,\n    installationIds: Uint8Array[],\n    env?: XmtpEnv,\n  ) {\n    return this.sendMessage(\"utils.revokeInstallationsSignatureText\", {\n      env,\n      identifier,\n      inboxId,\n      installationIds,\n      signatureRequestId: v4(),\n    });\n  }\n\n  /**\n   * Revokes installations for a given inbox ID\n   *\n   * @param env - The environment to use\n   * @param signer - The signer to use\n   * @param inboxId - The inbox ID to revoke installations for\n   * @param installationIds - The installation IDs to revoke\n   * @returns Promise that resolves with the result of the revoke installations operation\n   */\n  async revokeInstallations(\n    signer: Signer,\n    inboxId: string,\n    installationIds: Uint8Array[],\n    env?: XmtpEnv,\n  ) {\n    const identifier = await signer.getIdentifier();\n    const { signatureText, signatureRequestId } =\n      await this.revokeInstallationsSignatureText(\n        identifier,\n        inboxId,\n        installationIds,\n        env,\n      );\n    const signature = await signer.signMessage(signatureText);\n    const safeSigner = await toSafeSigner(signer, signature);\n\n    return this.sendMessage(\"utils.revokeInstallations\", {\n      signer: safeSigner,\n      signatureRequestId,\n      env,\n    });\n  }\n\n  /**\n   * Gets the inbox state for the specified inbox IDs without a client\n   *\n   * @param inboxIds - The inbox IDs to get the state for\n   * @param env - The environment to use\n   * @returns The inbox state for the specified inbox IDs\n   */\n  async inboxStateFromInboxIds(inboxIds: string[], env?: XmtpEnv) {\n    return this.sendMessage(\"utils.inboxStateFromInboxIds\", {\n      inboxIds,\n      env,\n    });\n  }\n}\n",
      "size_bytes": 3870
    },
    "apps/xmtp.chat/src/components/App/ConnectorSelect.module.css": {
      "content": ".root {\n  background-color: light-dark(\n    var(--mantine-color-gray-3),\n    var(--mantine-color-dark-4)\n  );\n  border-style: solid;\n  border-color: light-dark(\n    var(--mantine-color-gray-3),\n    var(--mantine-color-dark-4)\n  );\n  border-width: 1px 0 1px 0;\n}\n",
      "size_bytes": 262
    },
    "content-types/content-type-group-updated/src/GroupUpdated.test.ts": {
      "content": "import { describe, expect, it } from \"vitest\";\nimport {\n  ContentTypeGroupUpdated,\n  GroupUpdatedCodec,\n  type GroupUpdated,\n} from \"./GroupUpdated\";\n\ndescribe(\"ContentTypeGroupUpdated\", () => {\n  it(\"can encode/decode group updated data\", () => {\n    const groupUpdated: GroupUpdated = {\n      initiatedByInboxId: \"inbox-id\",\n      addedInboxes: [],\n      removedInboxes: [],\n      metadataFieldChanges: [],\n    };\n    const codec = new GroupUpdatedCodec();\n    const ec = codec.encode(groupUpdated);\n    expect(ec.type.sameAs(ContentTypeGroupUpdated)).toBe(true);\n    const groupUpdated2 = codec.decode(ec);\n    expect(groupUpdated2).toEqual(groupUpdated);\n  });\n});\n",
      "size_bytes": 669
    },
    "apps/xmtp.chat/src/icons/IconDots.tsx": {
      "content": "export const IconDots = ({\n  size = 20,\n  color = \"currentColor\",\n  ...props\n}: {\n  size?: number;\n  color?: string;\n}) => {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width={size}\n      height={size}\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke={color}\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      {...props}>\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0\" />\n      <path d=\"M12 19m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0\" />\n      <path d=\"M12 5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0\" />\n    </svg>\n  );\n};\n",
      "size_bytes": 644
    },
    "sdks/browser-sdk/src/AsyncStream.ts": {
      "content": "type ResolveValue<T> = {\n  value: T;\n  done: boolean;\n};\n\ntype ResolveNext<T> = (resolveValue: ResolveValue<T>) => void;\n\n/**\n * AsyncStream provides an async iterable interface for streaming data.\n *\n * This class implements a producer-consumer pattern where:\n * - Producers can push values using the `push()` method\n * - Consumers can iterate over values asynchronously using `for await` loops or `next()`\n * - Values are queued internally when no consumers are waiting\n * - Consumers are resolved immediately when values are available\n * - The stream can be terminated using `done()`, `return()`, or `end()`\n *\n * @example\n * ```typescript\n * const stream = new AsyncStream<string>();\n *\n * stream.push(\"hello\");\n * stream.push(\"world\");\n *\n * for await (const value of stream) {\n *   console.log(value); // \"hello\", \"world\"\n * }\n * ```\n */\nexport class AsyncStream<T> {\n  isDone = false;\n  #pendingResolves: ResolveNext<T | undefined>[] = [];\n  #queue: T[];\n  onDone: (() => void) | undefined;\n  onReturn: (() => void) | undefined;\n\n  constructor() {\n    this.#queue = [];\n    this.isDone = false;\n  }\n\n  flush() {\n    while (this.#pendingResolves.length > 0) {\n      const nextResolve = this.#pendingResolves.shift();\n      if (nextResolve) {\n        nextResolve({ done: true, value: undefined });\n      }\n    }\n  }\n\n  done() {\n    this.flush();\n    this.#queue = [];\n    this.#pendingResolves = [];\n    this.isDone = true;\n    this.onDone?.();\n  }\n\n  push = (value: T) => {\n    if (this.isDone) {\n      return;\n    }\n\n    const nextResolve = this.#pendingResolves.shift();\n    if (nextResolve) {\n      nextResolve({\n        done: false,\n        value,\n      });\n    } else {\n      this.#queue.push(value);\n    }\n  };\n\n  next = (): Promise<ResolveValue<T | undefined>> => {\n    if (this.isDone) {\n      return Promise.resolve({ done: true, value: undefined });\n    }\n\n    if (this.#queue.length > 0) {\n      return Promise.resolve({\n        done: false,\n        value: this.#queue.shift(),\n      });\n    }\n\n    return new Promise((resolve) => {\n      this.#pendingResolves.push(resolve);\n    });\n  };\n\n  return = (): Promise<ResolveValue<T | undefined>> => {\n    this.onReturn?.();\n    this.done();\n\n    return Promise.resolve({\n      done: true,\n      value: undefined,\n    });\n  };\n\n  end = () => this.return();\n\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n}\n\nexport interface AsyncStreamProxy<T> extends AsyncIterable<T> {\n  next(): Promise<ResolveValue<T>>;\n  return(): Promise<ResolveValue<undefined>>;\n  end(): Promise<ResolveValue<undefined>>;\n  isDone: boolean;\n}\n\nconst usableProperties = [\n  \"end\",\n  \"isDone\",\n  \"next\",\n  \"return\",\n  Symbol.asyncIterator,\n];\nconst isUsableProperty = <T>(\n  prop: string | symbol,\n): prop is keyof AsyncStreamProxy<T> => {\n  return usableProperties.includes(prop);\n};\n\n/**\n * Creates a read-only proxy for AsyncStream instances that restricts access to consumer-only methods.\n *\n * This proxy only exposes the following properties and methods:\n * - `next()`: Get the next value from the stream\n * - `end()`: Terminate the stream and stop iteration\n * - `return()`: Same as end(), terminates the stream\n * - `isDone`: Boolean indicating if the stream has been terminated\n * - `Symbol.asyncIterator`: Enables `for await` loop iteration\n *\n * Producer methods like `push()`, `done()`, and `flush()` are hidden to prevent\n * consumers from accidentally modifying the stream state.\n *\n * @param stream - The AsyncStream instance to create a proxy for\n * @returns A read-only proxy that implements AsyncStreamProxy<T>\n *\n * @example\n * ```typescript\n * const stream = new AsyncStream<string>();\n * const proxy = createAsyncStreamProxy(stream);\n *\n * stream.push(\"hello\");\n * stream.push(\"world\");\n *\n * for await (const value of proxy) {\n *   console.log(value); // \"hello\", \"world\"\n * }\n * ```\n */\nexport function createAsyncStreamProxy<T>(stream: AsyncStream<T>) {\n  return new Proxy(stream, {\n    get(target, prop, receiver) {\n      if (isUsableProperty(prop)) {\n        return Reflect.get(target, prop, receiver);\n      }\n    },\n\n    set() {\n      return true;\n    },\n\n    has(_target, prop) {\n      return isUsableProperty(prop);\n    },\n\n    ownKeys() {\n      return usableProperties;\n    },\n\n    getOwnPropertyDescriptor(target, prop) {\n      if (isUsableProperty(prop)) {\n        return {\n          enumerable: true,\n          configurable: true,\n          value: Reflect.get(target, prop),\n        };\n      }\n      return undefined;\n    },\n  }) as AsyncStreamProxy<T>;\n}\n",
      "size_bytes": 4528
    },
    "apps/xmtp.chat/src/components/App/AppLayout.tsx": {
      "content": "import { LoadingOverlay } from \"@mantine/core\";\nimport { useDisclosure } from \"@mantine/hooks\";\nimport { useEffect } from \"react\";\nimport { Outlet, useLocation, useNavigate } from \"react-router\";\nimport { AppHeader } from \"@/components/App/AppHeader\";\nimport { ConversationsNavbar } from \"@/components/Conversations/ConversationsNavbar\";\nimport { useXMTP } from \"@/contexts/XMTPContext\";\nimport { useRedirect } from \"@/hooks/useRedirect\";\nimport { CenteredLayout } from \"@/layouts/CenteredLayout\";\nimport {\n  MainLayout,\n  MainLayoutContent,\n  MainLayoutHeader,\n  MainLayoutNav,\n} from \"@/layouts/MainLayout\";\n\nexport const AppLayout: React.FC = () => {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const { client } = useXMTP();\n  const { setRedirectUrl } = useRedirect();\n  const [opened, { toggle }] = useDisclosure();\n\n  useEffect(() => {\n    if (!client) {\n      // save the current path to redirect to it after the client is initialized\n      if (\n        location.pathname !== \"/welcome\" &&\n        location.pathname !== \"/disconnect\"\n      ) {\n        setRedirectUrl(`${location.pathname}${location.search}`);\n      }\n      void navigate(\"/welcome\");\n    }\n  }, [client]);\n\n  return !client ? (\n    <CenteredLayout fullScreen>\n      <LoadingOverlay visible />\n    </CenteredLayout>\n  ) : (\n    <MainLayout>\n      <MainLayoutHeader>\n        <AppHeader client={client} opened={opened} toggle={toggle} />\n      </MainLayoutHeader>\n      <MainLayoutNav opened={opened} toggle={toggle}>\n        <ConversationsNavbar />\n      </MainLayoutNav>\n      <MainLayoutContent>\n        <Outlet />\n      </MainLayoutContent>\n    </MainLayout>\n  );\n};\n",
      "size_bytes": 1667
    },
    "content-types/content-type-remote-attachment/src/encryption/crypto.browser.ts": {
      "content": "/***********************************************************************************************\n * DO NOT IMPORT THIS FILE DIRECTLY\n ***********************************************************************************************/\nconst crypto = window.crypto;\nexport default crypto;\n",
      "size_bytes": 284
    },
    "apps/xmtp.chat/src/components/Messages/AttachmentDetails.tsx": {
      "content": "import { Stack, Text } from \"@mantine/core\";\nimport type { MessageContentAlign } from \"@/components/Messages/MessageContentWrapper\";\n\nexport type AttachmentDetailsProps = {\n  filename: string;\n  fileSize: string;\n  align: MessageContentAlign;\n};\n\nexport const AttachmentDetails: React.FC<AttachmentDetailsProps> = ({\n  filename,\n  fileSize,\n  align,\n}) => (\n  <Stack mt=\"xs\" gap={0} align={align === \"left\" ? \"flex-start\" : \"flex-end\"}>\n    <Text size=\"sm\" fw={500}>\n      {filename}\n    </Text>\n    <Text size=\"xs\" c=\"dimmed\">\n      {fileSize}\n    </Text>\n  </Stack>\n);\n",
      "size_bytes": 571
    },
    "sdks/browser-sdk/src/utils/conversions.ts": {
      "content": "import {\n  ContentTypeId,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\nimport {\n  Consent,\n  CreateDMOptions,\n  CreateGroupOptions,\n  GroupMember,\n  GroupPermissionsOptions,\n  ListConversationsOptions,\n  ListMessagesOptions,\n  MessageDisappearingSettings,\n  PermissionPolicySet,\n  ContentTypeId as WasmContentTypeId,\n  EncodedContent as WasmEncodedContent,\n  type ApiStats,\n  type ConsentEntityType,\n  type ConsentState,\n  type ContentType,\n  type ConversationDebugInfo,\n  type ConversationType,\n  type DeliveryStatus,\n  type GroupMessageKind,\n  type HmacKey,\n  type Identifier,\n  type IdentityStats,\n  type InboxState,\n  type Installation,\n  type KeyPackageStatus,\n  type Message,\n  type PermissionLevel,\n  type PermissionPolicy,\n  type SortDirection,\n} from \"@xmtp/wasm-bindings\";\nimport type { WorkerConversation } from \"@/WorkerConversation\";\n\nexport const toContentTypeId = (\n  contentTypeId: WasmContentTypeId,\n): ContentTypeId =>\n  new ContentTypeId({\n    authorityId: contentTypeId.authorityId,\n    typeId: contentTypeId.typeId,\n    versionMajor: contentTypeId.versionMajor,\n    versionMinor: contentTypeId.versionMinor,\n  });\n\nexport const fromContentTypeId = (\n  contentTypeId: ContentTypeId,\n): WasmContentTypeId =>\n  new WasmContentTypeId(\n    contentTypeId.authorityId,\n    contentTypeId.typeId,\n    contentTypeId.versionMajor,\n    contentTypeId.versionMinor,\n  );\n\nexport type SafeContentTypeId = {\n  authorityId: string;\n  typeId: string;\n  versionMajor: number;\n  versionMinor: number;\n};\n\nexport const toSafeContentTypeId = (\n  contentTypeId: ContentTypeId,\n): SafeContentTypeId => ({\n  authorityId: contentTypeId.authorityId,\n  typeId: contentTypeId.typeId,\n  versionMajor: contentTypeId.versionMajor,\n  versionMinor: contentTypeId.versionMinor,\n});\n\nexport const fromSafeContentTypeId = (\n  contentTypeId: SafeContentTypeId,\n): ContentTypeId =>\n  new ContentTypeId({\n    authorityId: contentTypeId.authorityId,\n    typeId: contentTypeId.typeId,\n    versionMajor: contentTypeId.versionMajor,\n    versionMinor: contentTypeId.versionMinor,\n  });\n\nexport const toEncodedContent = (\n  content: WasmEncodedContent,\n): EncodedContent => ({\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  type: toContentTypeId(content.type!),\n  parameters: Object.fromEntries(content.parameters as Map<string, string>),\n  fallback: content.fallback,\n  compression: content.compression,\n  content: content.content,\n});\n\nexport const fromEncodedContent = (\n  content: EncodedContent,\n): WasmEncodedContent =>\n  new WasmEncodedContent(\n    fromContentTypeId(content.type),\n    new Map(Object.entries(content.parameters)),\n    content.fallback,\n    content.compression,\n    content.content,\n  );\n\nexport type SafeEncodedContent = {\n  type: SafeContentTypeId;\n  parameters: Record<string, string>;\n  fallback?: string;\n  compression?: number;\n  content: Uint8Array;\n};\n\nexport const toSafeEncodedContent = (\n  content: EncodedContent,\n): SafeEncodedContent => ({\n  type: toSafeContentTypeId(content.type),\n  parameters: content.parameters,\n  fallback: content.fallback,\n  compression: content.compression,\n  content: content.content,\n});\n\nexport const fromSafeEncodedContent = (\n  content: SafeEncodedContent,\n): EncodedContent => ({\n  type: fromSafeContentTypeId(content.type),\n  parameters: content.parameters,\n  fallback: content.fallback,\n  compression: content.compression,\n  content: content.content,\n});\n\nexport type SafeMessage = {\n  content: SafeEncodedContent;\n  convoId: string;\n  deliveryStatus: DeliveryStatus;\n  id: string;\n  kind: GroupMessageKind;\n  senderInboxId: string;\n  sentAtNs: bigint;\n};\n\nexport const toSafeMessage = (message: Message): SafeMessage => ({\n  content: toSafeEncodedContent(toEncodedContent(message.content)),\n  convoId: message.convoId,\n  deliveryStatus: message.deliveryStatus,\n  id: message.id,\n  kind: message.kind,\n  senderInboxId: message.senderInboxId,\n  sentAtNs: message.sentAtNs,\n});\n\nexport type SafeListMessagesOptions = {\n  contentTypes?: ContentType[];\n  deliveryStatus?: DeliveryStatus;\n  direction?: SortDirection;\n  limit?: bigint;\n  sentAfterNs?: bigint;\n  sentBeforeNs?: bigint;\n};\n\nexport const toSafeListMessagesOptions = (\n  options: ListMessagesOptions,\n): SafeListMessagesOptions => ({\n  contentTypes: options.contentTypes,\n  deliveryStatus: options.deliveryStatus,\n  direction: options.direction,\n  limit: options.limit,\n  sentAfterNs: options.sentAfterNs,\n  sentBeforeNs: options.sentBeforeNs,\n});\n\nexport const fromSafeListMessagesOptions = (\n  options: SafeListMessagesOptions,\n): ListMessagesOptions =>\n  new ListMessagesOptions(\n    options.sentBeforeNs,\n    options.sentAfterNs,\n    options.limit,\n    options.deliveryStatus,\n    options.direction,\n    options.contentTypes,\n  );\n\nexport type SafeListConversationsOptions = {\n  consentStates?: ConsentState[];\n  conversationType?: ConversationType;\n  createdAfterNs?: bigint;\n  createdBeforeNs?: bigint;\n  includeDuplicateDms?: boolean;\n  limit?: bigint;\n};\n\nexport const toSafeListConversationsOptions = (\n  options: ListConversationsOptions,\n): SafeListConversationsOptions => ({\n  consentStates: options.consentStates,\n  conversationType: options.conversationType,\n  createdAfterNs: options.createdAfterNs,\n  createdBeforeNs: options.createdBeforeNs,\n  includeDuplicateDms: options.includeDuplicateDms,\n  limit: options.limit,\n});\n\nexport const fromSafeListConversationsOptions = (\n  options: SafeListConversationsOptions,\n): ListConversationsOptions =>\n  new ListConversationsOptions(\n    options.consentStates,\n    options.conversationType,\n    options.createdAfterNs,\n    options.createdBeforeNs,\n    options.includeDuplicateDms ?? false,\n    options.limit,\n  );\n\nexport type SafePermissionPolicySet = {\n  addAdminPolicy: PermissionPolicy;\n  addMemberPolicy: PermissionPolicy;\n  removeAdminPolicy: PermissionPolicy;\n  removeMemberPolicy: PermissionPolicy;\n  updateGroupDescriptionPolicy: PermissionPolicy;\n  updateGroupImageUrlSquarePolicy: PermissionPolicy;\n  updateGroupNamePolicy: PermissionPolicy;\n  updateMessageDisappearingPolicy: PermissionPolicy;\n};\n\nexport const toSafePermissionPolicySet = (\n  policySet: PermissionPolicySet,\n): SafePermissionPolicySet => ({\n  addAdminPolicy: policySet.addAdminPolicy,\n  addMemberPolicy: policySet.addMemberPolicy,\n  removeAdminPolicy: policySet.removeAdminPolicy,\n  removeMemberPolicy: policySet.removeMemberPolicy,\n  updateGroupDescriptionPolicy: policySet.updateGroupDescriptionPolicy,\n  updateGroupImageUrlSquarePolicy: policySet.updateGroupImageUrlSquarePolicy,\n  updateGroupNamePolicy: policySet.updateGroupNamePolicy,\n  updateMessageDisappearingPolicy: policySet.updateMessageDisappearingPolicy,\n});\n\nexport const fromSafePermissionPolicySet = (\n  policySet: SafePermissionPolicySet,\n): PermissionPolicySet =>\n  new PermissionPolicySet(\n    policySet.addMemberPolicy,\n    policySet.removeMemberPolicy,\n    policySet.addAdminPolicy,\n    policySet.removeAdminPolicy,\n    policySet.updateGroupNamePolicy,\n    policySet.updateGroupDescriptionPolicy,\n    policySet.updateGroupImageUrlSquarePolicy,\n    policySet.updateMessageDisappearingPolicy,\n  );\n\nexport type SafeCreateGroupOptions = {\n  customPermissionPolicySet?: SafePermissionPolicySet;\n  description?: string;\n  imageUrlSquare?: string;\n  messageDisappearingSettings?: SafeMessageDisappearingSettings;\n  name?: string;\n  permissions?: GroupPermissionsOptions;\n};\n\nexport const toSafeCreateGroupOptions = (\n  options: CreateGroupOptions,\n): SafeCreateGroupOptions => ({\n  customPermissionPolicySet: options.customPermissionPolicySet,\n  description: options.groupDescription,\n  imageUrlSquare: options.groupImageUrlSquare,\n  messageDisappearingSettings: options.messageDisappearingSettings\n    ? toSafeMessageDisappearingSettings(options.messageDisappearingSettings)\n    : undefined,\n  name: options.groupName,\n  permissions: options.permissions,\n});\n\nexport const fromSafeCreateGroupOptions = (\n  options: SafeCreateGroupOptions,\n): CreateGroupOptions =>\n  new CreateGroupOptions(\n    options.permissions,\n    options.name,\n    options.imageUrlSquare,\n    options.description,\n    // only include custom policy set if permissions are set to CustomPolicy\n    options.customPermissionPolicySet &&\n    options.permissions === GroupPermissionsOptions.CustomPolicy\n      ? fromSafePermissionPolicySet(options.customPermissionPolicySet)\n      : undefined,\n    options.messageDisappearingSettings\n      ? fromSafeMessageDisappearingSettings(options.messageDisappearingSettings)\n      : undefined,\n  );\n\nexport type SafeCreateDmOptions = {\n  messageDisappearingSettings?: SafeMessageDisappearingSettings;\n};\n\nexport const toSafeCreateDmOptions = (\n  options: CreateDMOptions,\n): SafeCreateDmOptions => ({\n  messageDisappearingSettings: options.messageDisappearingSettings\n    ? toSafeMessageDisappearingSettings(options.messageDisappearingSettings)\n    : undefined,\n});\n\nexport const fromSafeCreateDmOptions = (\n  options: SafeCreateDmOptions,\n): CreateDMOptions =>\n  new CreateDMOptions(\n    options.messageDisappearingSettings\n      ? fromSafeMessageDisappearingSettings(options.messageDisappearingSettings)\n      : undefined,\n  );\n\nexport type SafeConversation = {\n  id: string;\n  name: string;\n  imageUrl: string;\n  description: string;\n  permissions: {\n    policyType: GroupPermissionsOptions;\n    policySet: {\n      addAdminPolicy: PermissionPolicy;\n      addMemberPolicy: PermissionPolicy;\n      removeAdminPolicy: PermissionPolicy;\n      removeMemberPolicy: PermissionPolicy;\n      updateGroupDescriptionPolicy: PermissionPolicy;\n      updateGroupImageUrlSquarePolicy: PermissionPolicy;\n      updateGroupNamePolicy: PermissionPolicy;\n      updateMessageDisappearingPolicy: PermissionPolicy;\n    };\n  };\n  addedByInboxId: string;\n  metadata: {\n    creatorInboxId: string;\n    conversationType: string;\n  };\n  admins: string[];\n  superAdmins: string[];\n  createdAtNs: bigint;\n  isCommitLogForked?: boolean;\n};\n\nexport const toSafeConversation = async (\n  conversation: WorkerConversation,\n): Promise<SafeConversation> => {\n  const id = conversation.id;\n  const name = conversation.name;\n  const imageUrl = conversation.imageUrl;\n  const description = conversation.description;\n  const permissions = conversation.permissions;\n  const addedByInboxId = conversation.addedByInboxId;\n  const metadata = await conversation.metadata();\n  const admins = conversation.admins;\n  const superAdmins = conversation.superAdmins;\n  const createdAtNs = conversation.createdAtNs;\n  const policyType = permissions.policyType;\n  const policySet = permissions.policySet;\n  const isCommitLogForked = conversation.isCommitLogForked;\n  return {\n    id,\n    name,\n    imageUrl,\n    description,\n    permissions: {\n      policyType,\n      policySet: {\n        addAdminPolicy: policySet.addAdminPolicy,\n        addMemberPolicy: policySet.addMemberPolicy,\n        removeAdminPolicy: policySet.removeAdminPolicy,\n        removeMemberPolicy: policySet.removeMemberPolicy,\n        updateGroupDescriptionPolicy: policySet.updateGroupDescriptionPolicy,\n        updateGroupImageUrlSquarePolicy:\n          policySet.updateGroupImageUrlSquarePolicy,\n        updateGroupNamePolicy: policySet.updateGroupNamePolicy,\n        updateMessageDisappearingPolicy:\n          policySet.updateMessageDisappearingPolicy,\n      },\n    },\n    addedByInboxId,\n    metadata,\n    admins,\n    superAdmins,\n    createdAtNs,\n    isCommitLogForked,\n  };\n};\n\nexport type SafeInstallation = {\n  bytes: Uint8Array;\n  clientTimestampNs?: bigint;\n  id: string;\n};\n\nexport const toSafeInstallation = (\n  installation: Installation,\n): SafeInstallation => ({\n  bytes: installation.bytes,\n  clientTimestampNs: installation.clientTimestampNs,\n  id: installation.id,\n});\n\nexport type SafeInboxState = {\n  identifiers: Identifier[];\n  inboxId: string;\n  installations: SafeInstallation[];\n  recoveryIdentifier: Identifier;\n};\n\nexport const toSafeInboxState = (inboxState: InboxState): SafeInboxState => ({\n  identifiers: inboxState.accountIdentifiers,\n  inboxId: inboxState.inboxId,\n  installations: inboxState.installations.map(toSafeInstallation),\n  recoveryIdentifier: inboxState.recoveryIdentifier,\n});\n\nexport type SafeConsent = {\n  entity: string;\n  entityType: ConsentEntityType;\n  state: ConsentState;\n};\n\nexport const toSafeConsent = (consent: Consent): SafeConsent => ({\n  entity: consent.entity,\n  entityType: consent.entityType,\n  state: consent.state,\n});\n\nexport const fromSafeConsent = (consent: SafeConsent): Consent =>\n  new Consent(consent.entityType, consent.state, consent.entity);\n\nexport type SafeGroupMember = {\n  accountIdentifiers: Identifier[];\n  consentState: ConsentState;\n  inboxId: string;\n  installationIds: string[];\n  permissionLevel: PermissionLevel;\n};\n\nexport const toSafeGroupMember = (member: GroupMember): SafeGroupMember => ({\n  accountIdentifiers: member.accountIdentifiers,\n  consentState: member.consentState,\n  inboxId: member.inboxId,\n  installationIds: member.installationIds,\n  permissionLevel: member.permissionLevel,\n});\n\nexport const fromSafeGroupMember = (member: SafeGroupMember): GroupMember =>\n  new GroupMember(\n    member.inboxId,\n    member.accountIdentifiers,\n    member.installationIds,\n    member.permissionLevel,\n    member.consentState,\n  );\n\nexport type SafeHmacKey = {\n  key: Uint8Array;\n  epoch: bigint;\n};\n\nexport const toSafeHmacKey = (hmacKey: HmacKey): SafeHmacKey => ({\n  key: hmacKey.key,\n  epoch: hmacKey.epoch,\n});\n\nexport type HmacKeys = Map<string, HmacKey[]>;\nexport type SafeHmacKeys = Record<string, SafeHmacKey[]>;\n\nexport type SafeMessageDisappearingSettings = {\n  fromNs: bigint;\n  inNs: bigint;\n};\n\nexport const toSafeMessageDisappearingSettings = (\n  settings: MessageDisappearingSettings,\n): SafeMessageDisappearingSettings => ({\n  fromNs: settings.fromNs,\n  inNs: settings.inNs,\n});\n\nexport const fromSafeMessageDisappearingSettings = (\n  settings: SafeMessageDisappearingSettings,\n): MessageDisappearingSettings =>\n  new MessageDisappearingSettings(settings.fromNs, settings.inNs);\n\nexport type SafeKeyPackageStatus = {\n  lifetime?: {\n    notBefore: bigint;\n    notAfter: bigint;\n  };\n  validationError?: string;\n};\n\nexport const toSafeKeyPackageStatus = (\n  status: KeyPackageStatus,\n): SafeKeyPackageStatus => ({\n  lifetime: status.lifetime\n    ? {\n        notBefore: status.lifetime.not_before,\n        notAfter: status.lifetime.not_after,\n      }\n    : undefined,\n  validationError: status.validationError,\n});\n\nexport type SafeConversationDebugInfo = {\n  epoch: bigint;\n  maybeForked: boolean;\n  forkDetails: string;\n  isCommitLogForked?: boolean;\n  localCommitLog: string;\n  remoteCommitLog: string;\n  cursor: bigint;\n};\n\nexport const toSafeConversationDebugInfo = (\n  debugInfo: ConversationDebugInfo,\n): SafeConversationDebugInfo => ({\n  epoch: debugInfo.epoch,\n  maybeForked: debugInfo.maybeForked,\n  forkDetails: debugInfo.forkDetails,\n  isCommitLogForked: debugInfo.isCommitLogForked,\n  localCommitLog: debugInfo.localCommitLog,\n  remoteCommitLog: debugInfo.remoteCommitLog,\n  cursor: debugInfo.cursor,\n});\n\nexport type SafeApiStats = {\n  fetchKeyPackage: bigint;\n  queryGroupMessages: bigint;\n  queryWelcomeMessages: bigint;\n  sendGroupMessages: bigint;\n  sendWelcomeMessages: bigint;\n  subscribeMessages: bigint;\n  subscribeWelcomes: bigint;\n  uploadKeyPackage: bigint;\n};\n\nexport const toSafeApiStats = (stats: ApiStats): SafeApiStats => ({\n  uploadKeyPackage: stats.upload_key_package,\n  fetchKeyPackage: stats.fetch_key_package,\n  sendGroupMessages: stats.send_group_messages,\n  sendWelcomeMessages: stats.send_welcome_messages,\n  queryGroupMessages: stats.query_group_messages,\n  queryWelcomeMessages: stats.query_welcome_messages,\n  subscribeMessages: stats.subscribe_messages,\n  subscribeWelcomes: stats.subscribe_welcomes,\n});\n\nexport type SafeIdentityStats = {\n  getIdentityUpdatesV2: bigint;\n  getInboxIds: bigint;\n  publishIdentityUpdate: bigint;\n  verifySmartContractWalletSignature: bigint;\n};\n\nexport const toSafeIdentityStats = (\n  stats: IdentityStats,\n): SafeIdentityStats => ({\n  getIdentityUpdatesV2: stats.get_identity_updates_v2,\n  getInboxIds: stats.get_inbox_ids,\n  publishIdentityUpdate: stats.publish_identity_update,\n  verifySmartContractWalletSignature:\n    stats.verify_smart_contract_wallet_signature,\n});\n",
      "size_bytes": 16325
    },
    "sdks/agent-sdk/src/user/User.ts": {
      "content": "import {\n  IdentifierKind,\n  type HexString,\n  type Identifier,\n  type Signer,\n} from \"@xmtp/node-sdk\";\nimport {\n  createWalletClient,\n  http,\n  toBytes,\n  type Chain,\n  type Hex,\n  type PrivateKeyAccount,\n  type WalletClient,\n} from \"viem\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { sepolia } from \"viem/chains\";\n\nexport type User = {\n  key: Hex;\n  account: PrivateKeyAccount;\n  wallet: WalletClient;\n};\n\nexport const createUser = (key?: HexString, chain: Chain = sepolia): User => {\n  const accountKey = key ?? generatePrivateKey();\n  const account = privateKeyToAccount(accountKey);\n  return {\n    key: accountKey,\n    account,\n    wallet: createWalletClient({\n      account,\n      chain,\n      transport: http(),\n    }),\n  };\n};\n\nexport const createIdentifier = (user: User): Identifier => ({\n  identifier: user.account.address.toLowerCase(),\n  identifierKind: IdentifierKind.Ethereum,\n});\n\nexport const createSigner = (user: User): Signer => {\n  const identifier = createIdentifier(user);\n  return {\n    type: \"EOA\",\n    getIdentifier: () => identifier,\n    signMessage: async (message: string) => {\n      const signature = await user.wallet.signMessage({\n        account: user.account,\n        message,\n      });\n      return toBytes(signature);\n    },\n  };\n};\n",
      "size_bytes": 1307
    },
    "content-types/content-type-remote-attachment/rollup.config.js": {
      "content": "import terser from \"@rollup/plugin-terser\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { resolveExtensions } from \"@xmtp/rollup-plugin-resolve-extensions\";\nimport { defineConfig } from \"rollup\";\nimport { dts } from \"rollup-plugin-dts\";\n\nconst plugins = [\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n];\n\nconst external = [\n  \"@noble/secp256k1\",\n  \"@xmtp/content-type-primitives\",\n  \"@xmtp/proto\",\n  \"node:crypto\",\n];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/browser/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins: [\n      resolveExtensions({ extensions: [\".browser\"] }),\n      terser(),\n      ...plugins,\n    ],\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.d.ts\",\n      format: \"es\",\n    },\n    plugins: [dts()],\n  },\n]);\n",
      "size_bytes": 1043
    },
    "apps/xmtp.chat/src/components/App/DisableAnalytics.tsx": {
      "content": "import { Anchor, Group, Stack, Switch, Text } from \"@mantine/core\";\nimport { useLocalStorage } from \"@mantine/hooks\";\nimport React from \"react\";\n\nexport const DisableAnalytics: React.FC = () => {\n  const [checked, setChecked] = useLocalStorage({\n    key: \"plausible_ignore\",\n    defaultValue: false,\n  });\n\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setChecked(event.currentTarget.checked);\n  };\n\n  return (\n    <Stack>\n      <Group gap=\"xs\" justify=\"space-between\" align=\"center\">\n        <Text fw=\"bold\" size=\"xl\">\n          Disable analytics\n        </Text>\n        <Switch\n          size=\"md\"\n          checked={checked}\n          onChange={handleChange}\n          withThumbIndicator={false}\n        />\n      </Group>\n      <Text>\n        We use{\" \"}\n        <Anchor\n          href=\"https://plausible.io/privacy-focused-web-analytics\"\n          target=\"_blank\">\n          Plausible Analytics\n        </Anchor>{\" \"}\n        to track usage and improve the app.\n      </Text>\n    </Stack>\n  );\n};\n",
      "size_bytes": 1032
    },
    "apps/xmtp.chat/src/components/Conversation/Members.tsx": {
      "content": "import { Badge, Group, Stack, Text } from \"@mantine/core\";\nimport { useCallback, useMemo } from \"react\";\nimport {\n  AddMembers,\n  type AddMembersProps,\n  type PendingMember,\n} from \"@/components/Conversation/AddMembers\";\nimport { Member } from \"@/components/Conversation/Member\";\nimport { RemoveMembers } from \"@/components/Conversation/RemoveMembers\";\nimport { useClient } from \"@/contexts/XMTPContext\";\nimport type { ClientPermissions } from \"@/hooks/useClientPermissions\";\nimport { type MemberProfile } from \"@/hooks/useMemberProfiles\";\n\nexport type MembersProps = {\n  addedMembers: PendingMember[];\n  clientPermissions?: ClientPermissions;\n  existingMembers: MemberProfile[];\n  onMembersAdded?: AddMembersProps[\"onMembersAdded\"];\n  onMembersRemoved?: (members: MemberProfile[]) => void;\n  removedMembers: MemberProfile[];\n};\n\nexport const Members: React.FC<MembersProps> = ({\n  addedMembers,\n  clientPermissions,\n  existingMembers,\n  onMembersAdded,\n  onMembersRemoved,\n  removedMembers,\n}) => {\n  const client = useClient();\n  const handleRemoveMember = useCallback(\n    (inboxId: string) => {\n      const member = existingMembers.find((m) => m.inboxId === inboxId);\n      if (!member) {\n        return;\n      }\n      onMembersRemoved?.([...removedMembers, member]);\n    },\n    [existingMembers, removedMembers, onMembersRemoved],\n  );\n\n  const showAddMembersSection =\n    !existingMembers.length ||\n    (clientPermissions && clientPermissions.canAddMembers);\n  const showRemovedMembersSection =\n    !existingMembers.length ||\n    (clientPermissions && clientPermissions.canRemoveMembers);\n\n  const finalMembers = useMemo(() => {\n    return existingMembers.filter(\n      (member) => !removedMembers.some((m) => m.inboxId === member.inboxId),\n    );\n  }, [existingMembers, removedMembers]);\n\n  const superAdmins = useMemo(() => {\n    return finalMembers.filter(\n      // @ts-expect-error - the types are wrong\n      (member) => member.permissionLevel === \"SuperAdmin\",\n    );\n  }, [finalMembers]);\n\n  const admins = useMemo(() => {\n    return finalMembers.filter(\n      // @ts-expect-error - the types are wrong\n      (member) => member.permissionLevel === \"Admin\",\n    );\n  }, [finalMembers]);\n\n  const members = useMemo(() => {\n    return finalMembers.filter(\n      // @ts-expect-error - the types are wrong\n      (member) => member.permissionLevel === \"Member\",\n    );\n  }, [finalMembers]);\n\n  return (\n    <Stack gap=\"md\" p=\"md\">\n      {showAddMembersSection && (\n        <AddMembers\n          existingMembers={existingMembers}\n          addedMembers={addedMembers}\n          onMembersAdded={onMembersAdded}\n        />\n      )}\n      {existingMembers.length > 0 && (\n        <>\n          {showRemovedMembersSection && (\n            <RemoveMembers\n              removedMembers={removedMembers}\n              onMembersRemoved={onMembersRemoved}\n            />\n          )}\n          <Stack gap=\"xs\">\n            <Group gap=\"xs\" justify=\"space-between\" align=\"center\">\n              <Text fw={700}>Members</Text>\n              <Badge color=\"gray\" size=\"lg\">\n                {finalMembers.length}\n              </Badge>\n            </Group>\n            {superAdmins.length > 0 && (\n              <>\n                <Group gap=\"xs\">\n                  <Text size=\"sm\" fw={700}>\n                    Super admins\n                  </Text>\n                  <Badge color=\"gray\" size=\"md\">\n                    {superAdmins.length}\n                  </Badge>\n                </Group>\n                <Stack gap=\"0\">\n                  {superAdmins.map((member) => (\n                    <Member\n                      key={member.inboxId}\n                      address={member.address}\n                      displayName={member.displayName}\n                      avatar={member.avatar}\n                      description={member.description}\n                    />\n                  ))}\n                </Stack>\n              </>\n            )}\n            {admins.length > 0 && (\n              <>\n                <Group gap=\"xs\">\n                  <Text size=\"sm\" fw={700}>\n                    Admins\n                  </Text>\n                  <Badge color=\"gray\" size=\"md\">\n                    {admins.length}\n                  </Badge>\n                </Group>\n                <Stack gap=\"0\">\n                  {admins.map((member) => (\n                    <Member\n                      key={member.inboxId}\n                      address={member.address}\n                      displayName={member.displayName}\n                      avatar={member.avatar}\n                      description={member.description}\n                      onClick={\n                        showRemovedMembersSection &&\n                        member.inboxId !== client.inboxId\n                          ? () => {\n                              handleRemoveMember(member.inboxId);\n                            }\n                          : undefined\n                      }\n                    />\n                  ))}\n                </Stack>\n              </>\n            )}\n            {members.length > 0 && (\n              <>\n                <Group gap=\"xs\">\n                  <Text size=\"sm\" fw={700}>\n                    Members\n                  </Text>\n                  <Badge color=\"gray\" size=\"md\">\n                    {members.length}\n                  </Badge>\n                </Group>\n                <Stack gap=\"0\">\n                  {members.map((member) => (\n                    <Member\n                      key={member.inboxId}\n                      address={member.address}\n                      displayName={member.displayName}\n                      avatar={member.avatar}\n                      description={member.description}\n                      onClick={\n                        showRemovedMembersSection &&\n                        member.inboxId !== client.inboxId\n                          ? () => {\n                              handleRemoveMember(member.inboxId);\n                            }\n                          : undefined\n                      }\n                    />\n                  ))}\n                </Stack>\n              </>\n            )}\n          </Stack>\n        </>\n      )}\n    </Stack>\n  );\n};\n",
      "size_bytes": 6221
    },
    "apps/xmtp.chat/src/components/InboxTools/InboxToolsLayout.tsx": {
      "content": "import { Outlet } from \"react-router\";\nimport { AppFooter } from \"@/components/App/AppFooter\";\nimport { InboxToolsHeader } from \"@/components/InboxTools/InboxToolsHeader\";\nimport {\n  MainLayout,\n  MainLayoutContent,\n  MainLayoutFooter,\n  MainLayoutHeader,\n} from \"@/layouts/MainLayout\";\n\nexport const InboxToolsLayout: React.FC = () => {\n  return (\n    <MainLayout>\n      <MainLayoutHeader>\n        <InboxToolsHeader />\n      </MainLayoutHeader>\n      <MainLayoutContent>\n        <Outlet />\n      </MainLayoutContent>\n      <MainLayoutFooter>\n        <AppFooter />\n      </MainLayoutFooter>\n    </MainLayout>\n  );\n};\n",
      "size_bytes": 617
    },
    "content-types/content-type-wallet-send-calls/CHANGELOG.md": {
      "content": "# @xmtp/content-type-wallet-send-calls\n\n## 2.0.0\n\n### BREAKING CHANGES\n\n- Replaced `Record<string, any>` types with `Record<string, string>`\n\n### Minor Changes\n\n- Removed redundant `| undefined` types\n\n## 1.0.1\n\n### Patch Changes\n\n- Updated dependencies [779fd0c]\n  - @xmtp/content-type-primitives@2.0.2\n",
      "size_bytes": 304
    },
    "apps/xmtp.chat/src/hooks/useEphemeralSigner.ts": {
      "content": "import { useMemo } from \"react\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { createEphemeralSigner } from \"@/helpers/createSigner\";\nimport { useSettings } from \"@/hooks/useSettings\";\n\nexport const useEphemeralSigner = () => {\n  const { ephemeralAccountKey, setEphemeralAccountKey } = useSettings();\n\n  const accountKey = useMemo(() => {\n    let accountKey = ephemeralAccountKey;\n    if (!accountKey) {\n      accountKey = generatePrivateKey();\n      setEphemeralAccountKey(accountKey);\n    }\n    return accountKey;\n  }, [ephemeralAccountKey, setEphemeralAccountKey]);\n\n  const signer = useMemo(() => {\n    return createEphemeralSigner(accountKey);\n  }, [accountKey]);\n\n  const address = useMemo(() => {\n    const account = privateKeyToAccount(accountKey);\n    return account.address.toLowerCase();\n  }, [accountKey]);\n\n  return {\n    address,\n    signer,\n  };\n};\n",
      "size_bytes": 900
    },
    "apps/xmtp.chat/src/hooks/useConnectWallet.ts": {
      "content": "import { useCallback } from \"react\";\nimport { useAccount, useConnect, useConnectors, useDisconnect } from \"wagmi\";\n\nexport type ConnectorString =\n  | \"Injected\"\n  | \"Coinbase Wallet\"\n  | \"MetaMask\"\n  | \"WalletConnect\";\n\nexport const useConnectWallet = () => {\n  const account = useAccount();\n  const { connect, isPending: connectLoading } = useConnect();\n  const connectors = useConnectors();\n  const { disconnect, isPending: disconnectLoading } = useDisconnect();\n\n  const connectWallet = useCallback(\n    (connectorString: ConnectorString) => () => {\n      const connector = connectors.find((c) => c.name === connectorString);\n      if (!connector) {\n        throw new Error(`Connector ${connectorString} not found`);\n      }\n      connect({ connector });\n    },\n    [connectors, connect],\n  );\n\n  return {\n    account,\n    connect: connectWallet,\n    disconnect,\n    isConnected: !!account.address,\n    loading: connectLoading || disconnectLoading,\n    address: account.address,\n    chainId: account.chainId,\n  };\n};\n",
      "size_bytes": 1020
    },
    "apps/xmtp.chat/src/components/Conversation/RemoveMembers.tsx": {
      "content": "import { Badge, Group, Stack, Text } from \"@mantine/core\";\nimport { useCallback } from \"react\";\nimport { Member } from \"@/components/Conversation/Member\";\nimport type { MemberProfile } from \"@/hooks/useMemberProfiles\";\n\nexport type RemoveMembersProps = {\n  removedMembers: MemberProfile[];\n  onMembersRemoved?: (members: MemberProfile[]) => void;\n};\n\nexport const RemoveMembers: React.FC<RemoveMembersProps> = ({\n  removedMembers,\n  onMembersRemoved,\n}) => {\n  const handleRestoreRemovedMember = useCallback(\n    (inboxId: string) => {\n      const newRemovedMembers = removedMembers.filter(\n        (m) => m.inboxId !== inboxId,\n      );\n      if (newRemovedMembers.length === removedMembers.length) {\n        return;\n      }\n      onMembersRemoved?.(newRemovedMembers);\n    },\n    [removedMembers],\n  );\n\n  return (\n    <>\n      <Group gap=\"xs\" justify=\"space-between\" align=\"center\">\n        <Text fw={700}>Removed members</Text>\n        <Badge color=\"gray\" size=\"lg\">\n          {removedMembers.length}\n        </Badge>\n      </Group>\n      {removedMembers.length > 0 && (\n        <Stack gap=\"4px\">\n          {removedMembers.map((member) => (\n            <Member\n              key={member.inboxId}\n              buttonLabel=\"Restore\"\n              address={member.address}\n              displayName={member.displayName}\n              avatar={member.avatar}\n              description={member.description}\n              onClick={() => {\n                handleRestoreRemovedMember(member.inboxId);\n              }}\n            />\n          ))}\n        </Stack>\n      )}\n    </>\n  );\n};\n",
      "size_bytes": 1585
    },
    "apps/xmtp.chat/src/components/Conversation/ManageMembersModal.tsx": {
      "content": "import { Button, Group } from \"@mantine/core\";\nimport { Group as XmtpGroup } from \"@xmtp/browser-sdk\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport { useNavigate, useOutletContext } from \"react-router\";\nimport type { PendingMember } from \"@/components/Conversation/AddMembers\";\nimport type { ConversationOutletContext } from \"@/components/Conversation/ConversationOutletContext\";\nimport { Members } from \"@/components/Conversation/Members\";\nimport { Modal } from \"@/components/Modal\";\nimport { isValidEthereumAddress, isValidInboxId } from \"@/helpers/strings\";\nimport { useClientPermissions } from \"@/hooks/useClientPermissions\";\nimport { useCollapsedMediaQuery } from \"@/hooks/useCollapsedMediaQuery\";\nimport { useConversation } from \"@/hooks/useConversation\";\nimport {\n  useMemberProfiles,\n  type MemberProfile,\n} from \"@/hooks/useMemberProfiles\";\nimport { ContentLayout } from \"@/layouts/ContentLayout\";\nimport { useActions } from \"@/stores/inbox/hooks\";\n\nexport const ManageMembersModal: React.FC = () => {\n  const { conversationId } = useOutletContext<ConversationOutletContext>();\n  const { conversation, members } = useConversation(conversationId);\n  const existingMembers = useMemberProfiles(Array.from(members.values()));\n  const clientPermissions = useClientPermissions(conversationId);\n  const { addConversation } = useActions();\n  const navigate = useNavigate();\n  const [isLoading, setIsLoading] = useState(false);\n  const [addedMembers, setAddedMembers] = useState<PendingMember[]>([]);\n  const [removedMembers, setRemovedMembers] = useState<MemberProfile[]>([]);\n\n  const fullScreen = useCollapsedMediaQuery();\n  const contentHeight = fullScreen ? \"auto\" : 500;\n\n  const handleClose = useCallback(() => {\n    void navigate(`/conversations/${conversation.id}`);\n  }, [navigate, conversation.id]);\n\n  const handleUpdate = useCallback(async () => {\n    if (!(conversation instanceof XmtpGroup)) {\n      return;\n    }\n\n    setIsLoading(true);\n\n    try {\n      let hasUpdated = false;\n      if (addedMembers.length > 0) {\n        const addedMemberInboxIds = addedMembers\n          .filter((member) => isValidInboxId(member.inboxId))\n          .map((member) => member.inboxId);\n        if (addedMemberInboxIds.length > 0) {\n          await conversation.addMembers(addedMemberInboxIds);\n          hasUpdated = true;\n        }\n        const addedMemberAddresses = addedMembers.filter((member) =>\n          isValidEthereumAddress(member.address),\n        );\n        if (addedMemberAddresses.length > 0) {\n          await conversation.addMembersByIdentifiers(\n            addedMemberAddresses.map((member) => ({\n              identifier: member.address.toLowerCase(),\n              identifierKind: \"Ethereum\",\n            })),\n          );\n          hasUpdated = true;\n        }\n      }\n\n      if (removedMembers.length > 0) {\n        await conversation.removeMembers(\n          removedMembers.map((member) => member.inboxId),\n        );\n        hasUpdated = true;\n      }\n\n      if (hasUpdated) {\n        void addConversation(conversation);\n      }\n\n      void navigate(`/conversations/${conversation.id}`);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [conversation.id, addedMembers, removedMembers, navigate]);\n\n  const footer = useMemo(() => {\n    return (\n      <Group justify=\"flex-end\" flex={1} p=\"md\">\n        <Button variant=\"default\" onClick={handleClose}>\n          Cancel\n        </Button>\n        <Button\n          variant=\"filled\"\n          disabled={isLoading}\n          loading={isLoading}\n          onClick={() => void handleUpdate()}>\n          Save\n        </Button>\n      </Group>\n    );\n  }, [isLoading, handleUpdate]);\n\n  return (\n    <Modal\n      closeOnClickOutside={false}\n      closeOnEscape={false}\n      withCloseButton={false}\n      opened\n      centered\n      fullScreen={fullScreen}\n      onClose={handleClose}\n      size=\"600\"\n      padding={0}>\n      <ContentLayout\n        title=\"Manage members\"\n        maxHeight={contentHeight}\n        footer={footer}\n        loading={isLoading}\n        withScrollAreaPadding={false}>\n        <Members\n          addedMembers={addedMembers}\n          clientPermissions={clientPermissions}\n          existingMembers={existingMembers}\n          removedMembers={removedMembers}\n          onMembersAdded={setAddedMembers}\n          onMembersRemoved={setRemovedMembers}\n        />\n      </ContentLayout>\n    </Modal>\n  );\n};\n",
      "size_bytes": 4421
    },
    "sdks/browser-sdk/src/types/actions/preferences.ts": {
      "content": "import type { ConsentEntityType, ConsentState } from \"@xmtp/wasm-bindings\";\nimport type { SafeConsent, SafeInboxState } from \"@/utils/conversions\";\n\nexport type PreferencesAction =\n  | {\n      action: \"preferences.inboxState\";\n      id: string;\n      result: SafeInboxState;\n      data: {\n        refreshFromNetwork: boolean;\n      };\n    }\n  | {\n      action: \"preferences.inboxStateFromInboxIds\";\n      id: string;\n      result: SafeInboxState[];\n      data: {\n        inboxIds: string[];\n        refreshFromNetwork: boolean;\n      };\n    }\n  | {\n      action: \"preferences.getLatestInboxState\";\n      id: string;\n      result: SafeInboxState;\n      data: {\n        inboxId: string;\n      };\n    }\n  | {\n      action: \"preferences.setConsentStates\";\n      id: string;\n      result: undefined;\n      data: {\n        records: SafeConsent[];\n      };\n    }\n  | {\n      action: \"preferences.getConsentState\";\n      id: string;\n      result: ConsentState;\n      data: {\n        entityType: ConsentEntityType;\n        entity: string;\n      };\n    }\n  | {\n      action: \"preferences.sync\";\n      id: string;\n      result: number;\n      data: undefined;\n    }\n  | {\n      action: \"preferences.streamConsent\";\n      id: string;\n      result: undefined;\n      data: {\n        streamId: string;\n      };\n    }\n  | {\n      action: \"preferences.streamPreferences\";\n      id: string;\n      result: undefined;\n      data: {\n        streamId: string;\n      };\n    };\n",
      "size_bytes": 1453
    },
    "apps/xmtp.chat-api-service/src/api/v1/index.ts": {
      "content": "import { Router } from \"express\";\nimport pinataRouter from \"./pinata.router.js\";\nimport resolveRouter from \"./resolve.router.js\";\n\nconst v1Router = Router();\n\nv1Router.use(\"/pinata\", pinataRouter);\nv1Router.use(\"/resolve\", resolveRouter);\n\nexport default v1Router;\n",
      "size_bytes": 265
    },
    "apps/xmtp.chat/src/helpers/profiles.ts": {
      "content": "import {\n  createEmptyProfile,\n  profilesStore,\n  type Profile,\n} from \"@/stores/profiles\";\n\nexport const resolveAddresses = async (addresses: string[], force = false) => {\n  // check if any of the addresses are cached\n  const cachedProfiles = profilesStore.getState().findProfiles(addresses);\n  const unresolvedAddresses = addresses.filter(\n    (address) => !cachedProfiles.has(address),\n  );\n\n  if (!force && unresolvedAddresses.length === 0) {\n    return cachedProfiles;\n  }\n\n  const response = await fetch(\n    `${import.meta.env.VITE_API_SERVICE_URL}/api/v1/resolve/profiles`,\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        addresses: force ? addresses : unresolvedAddresses,\n      }),\n    },\n  );\n\n  if (!response.ok) {\n    // failed to resolve addresses, return the cached profiles\n    return cachedProfiles;\n  }\n\n  const data = (await response.json()) as {\n    profiles: Profile[];\n  };\n\n  // addresses that don't have web3 profiles\n  const missingProfiles = unresolvedAddresses.filter(\n    (address) => !data.profiles.some((profile) => profile.address === address),\n  );\n\n  // add empty profiles for addresses that don't have web3 profiles so that\n  // we don't try to resolve them again in this session\n  missingProfiles.forEach((address) => {\n    data.profiles.push(createEmptyProfile(address));\n  });\n\n  if (data.profiles.length > 0) {\n    // cache the profiles\n    profilesStore.getState().addProfiles(data.profiles);\n  }\n\n  // return updated cached profiles\n  return profilesStore.getState().findProfiles(addresses);\n};\n",
      "size_bytes": 1622
    },
    "apps/xmtp.chat/src/components/Conversation/LoadDM.tsx": {
      "content": "import type { XmtpEnv } from \"@xmtp/browser-sdk\";\nimport { useEffect, useState } from \"react\";\nimport { useNavigate, useParams, useSearchParams } from \"react-router\";\nimport { LoadingMessage } from \"@/components/LoadingMessage\";\nimport { useClient, useXMTP } from \"@/contexts/XMTPContext\";\nimport { isValidEthereumAddress } from \"@/helpers/strings\";\nimport { useSettings } from \"@/hooks/useSettings\";\nimport { useActions } from \"@/stores/inbox/hooks\";\n\nconst isValidEnvironment = (env: string): env is XmtpEnv =>\n  [\"production\", \"dev\", \"local\"].includes(env);\n\nconst REDIRECT_TIMEOUT = 2000;\n\nexport const LoadDM: React.FC = () => {\n  const [message, setMessage] = useState(\"\");\n  const { address } = useParams();\n  const [searchParams] = useSearchParams();\n  const { setEnvironment, environment } = useSettings();\n  const { addConversation } = useActions();\n  const navigate = useNavigate();\n  const { disconnect } = useXMTP();\n  const client = useClient();\n\n  useEffect(() => {\n    let timeout: NodeJS.Timeout;\n    const loadDm = async () => {\n      setMessage(\"Checking environment...\");\n\n      const env = searchParams.get(\"env\");\n      if (env) {\n        // check for invalid environment\n        if (!isValidEnvironment(env)) {\n          setMessage(\"Invalid environment, redirecting...\");\n          timeout = setTimeout(() => {\n            void navigate(\"/\");\n          }, REDIRECT_TIMEOUT);\n          return;\n        }\n\n        if (env !== environment) {\n          setMessage(\"Environment mismatch, switching and redirecting...\");\n          setEnvironment(env);\n          timeout = setTimeout(() => {\n            disconnect();\n            void navigate(\"/\");\n          }, REDIRECT_TIMEOUT);\n          return;\n        }\n      }\n\n      // no address, redirect to root\n      if (!address || !isValidEthereumAddress(address)) {\n        setMessage(\"Invalid address, redirecting...\");\n        timeout = setTimeout(() => {\n          void navigate(\"/\");\n        }, REDIRECT_TIMEOUT);\n        return;\n      }\n\n      try {\n        setMessage(\"Verifying address...\");\n        const inboxId = await client.findInboxIdByIdentifier({\n          identifier: address.toLowerCase(),\n          identifierKind: \"Ethereum\",\n        });\n        // no inbox ID, redirect to root\n\n        if (!inboxId) {\n          setMessage(\n            \"Address not registered on the XMTP network, redirecting...\",\n          );\n          timeout = setTimeout(() => {\n            void navigate(\"/\");\n          }, REDIRECT_TIMEOUT);\n          return;\n        }\n\n        // look for existing DM group\n        setMessage(\"Looking for existing DM...\");\n        const dm = await client.conversations.getDmByInboxId(inboxId);\n        let dmId = dm?.id;\n        if (!dmId) {\n          // no DM group, create it\n          setMessage(\"Creating new DM...\");\n          const newDm = await client.conversations.newDmWithIdentifier({\n            identifier: address.toLowerCase(),\n            identifierKind: \"Ethereum\",\n          });\n          dmId = newDm.id;\n          // add new DM to store\n          await addConversation(newDm);\n        }\n        await navigate(`/conversations/${dmId}`);\n      } catch (e) {\n        console.error(e);\n        setMessage(\"Error loading DM, redirecting...\");\n        // if any errors occur during this process, redirect to root\n        timeout = setTimeout(() => {\n          void navigate(\"/\");\n        }, REDIRECT_TIMEOUT);\n\n        // rethrow error for error modal\n        throw e;\n      }\n    };\n    void loadDm();\n\n    return () => {\n      clearTimeout(timeout);\n    };\n  }, [client, address]);\n\n  return <LoadingMessage message={message} />;\n};\n",
      "size_bytes": 3643
    },
    "sdks/browser-sdk/src/types/actions/dm.ts": {
      "content": "import type { SafeConversation } from \"@/utils/conversions\";\n\nexport type DmAction =\n  | {\n      action: \"dm.peerInboxId\";\n      id: string;\n      result: string;\n      data: {\n        id: string;\n      };\n    }\n  | {\n      action: \"dm.getDuplicateDms\";\n      id: string;\n      result: SafeConversation[];\n      data: {\n        id: string;\n      };\n    };\n",
      "size_bytes": 356
    },
    "apps/xmtp.chat/src/components/Conversation/LoadConversation.tsx": {
      "content": "import { LoadingOverlay } from \"@mantine/core\";\nimport type { Conversation as XmtpConversation } from \"@xmtp/browser-sdk\";\nimport { useEffect, useState } from \"react\";\nimport { useNavigate, useParams } from \"react-router\";\nimport type { ContentTypes } from \"@/contexts/XMTPContext\";\nimport { CenteredLayout } from \"@/layouts/CenteredLayout\";\nimport { useActions, useLastSyncedAt } from \"@/stores/inbox/hooks\";\nimport { Conversation } from \"./Conversation\";\n\nexport const LoadConversation: React.FC = () => {\n  const navigate = useNavigate();\n  const { conversationId } = useParams();\n  const lastSyncedAt = useLastSyncedAt();\n  const { getConversation } = useActions();\n  const [conversation, setConversation] = useState<\n    XmtpConversation<ContentTypes> | undefined\n  >(undefined);\n\n  useEffect(() => {\n    // wait for initial sync to complete\n    if (lastSyncedAt && conversationId) {\n      const conversation = getConversation(conversationId);\n      if (conversation) {\n        setConversation(conversation);\n      } else {\n        void navigate(\"/conversations\");\n      }\n    }\n  }, [conversationId, lastSyncedAt]);\n\n  return conversation ? (\n    <Conversation conversationId={conversation.id} />\n  ) : (\n    <CenteredLayout>\n      <LoadingOverlay visible />\n    </CenteredLayout>\n  );\n};\n",
      "size_bytes": 1295
    },
    "sdks/node-sdk/test/inboxId.test.ts": {
      "content": "import { describe, expect, it } from \"vitest\";\nimport { generateInboxId, getInboxIdForIdentifier } from \"@/utils/inboxId\";\nimport {\n  createRegisteredClient,\n  createSigner,\n  createUser,\n} from \"@test/helpers\";\n\ndescribe(\"generateInboxId\", () => {\n  it(\"should generate an inbox id\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const inboxId = generateInboxId(await signer.getIdentifier());\n    expect(inboxId).toBeDefined();\n  });\n});\n\ndescribe(\"getInboxIdForAddress\", () => {\n  it(\"should return `null` inbox ID for unregistered address\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const inboxId = await getInboxIdForIdentifier(\n      await signer.getIdentifier(),\n      \"local\",\n    );\n    expect(inboxId).toBe(null);\n  });\n\n  it(\"should return inbox ID for registered address\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const inboxId = await getInboxIdForIdentifier(\n      await signer.getIdentifier(),\n      \"local\",\n    );\n    expect(inboxId).toBe(client.inboxId);\n  });\n});\n",
      "size_bytes": 1174
    },
    "sdks/agent-sdk/src/core/MessageContext.test.ts": {
      "content": "import {\n  ContentTypeReply,\n  ReplyCodec,\n  type Reply,\n} from \"@xmtp/content-type-reply\";\nimport { ContentTypeText } from \"@xmtp/content-type-text\";\nimport { Dm } from \"@xmtp/node-sdk\";\nimport { describe, expect, expectTypeOf, it } from \"vitest\";\nimport {\n  createMockMessage,\n  mockClient,\n  type CurrentClientTypes,\n} from \"@/utils/TestUtil.js\";\nimport { MessageContext } from \"./MessageContext.js\";\n\ndescribe(\"MessageContext\", () => {\n  describe(\"usesCodec\", () => {\n    const mockDm = Object.create(Dm.prototype) as Dm;\n\n    it(\"should properly type the content when using ReplyCodec as input\", () => {\n      const replyMessage = createMockMessage<Reply>({\n        id: \"reply-message-id\",\n        senderInboxId: \"other-inbox-id\",\n        contentType: ContentTypeReply,\n        content: {\n          content: \"This is a reply\",\n          reference: \"original-message-id\",\n          referenceInboxId: \"original-sender-inbox-id\",\n          contentType: ContentTypeText,\n        },\n      });\n\n      const messageContext = new MessageContext<CurrentClientTypes>({\n        message: replyMessage,\n        conversation: mockDm,\n        client: mockClient,\n      });\n\n      expect(messageContext.usesCodec(ReplyCodec)).toBe(true);\n      const typedContext = messageContext as MessageContext<Reply>;\n      expectTypeOf(typedContext.message.content).toEqualTypeOf<Reply>();\n      const { content } = typedContext.message;\n      expect(content.content).toBe(replyMessage.content.content);\n    });\n\n    it(\"should return false for ReplyCodec when message is not a reply\", () => {\n      const textMessage = createMockMessage({\n        id: \"text-message-id\",\n        senderInboxId: \"sender-inbox-id\",\n        contentType: ContentTypeText,\n        content: \"This is just a regular text message\",\n      });\n\n      const messageContext = new MessageContext<CurrentClientTypes>({\n        message: textMessage,\n        conversation: mockDm,\n        client: mockClient,\n      });\n\n      const isReplyCodec = messageContext.usesCodec(ReplyCodec);\n      expect(isReplyCodec).toBe(false);\n    });\n  });\n});\n",
      "size_bytes": 2088
    },
    "content-types/content-type-wallet-send-calls/README.md": {
      "content": "# Wallet Send Calls content type\n\nThis package provides an XMTP content type to support wallet transactions using the `wallet_sendCalls` RPC specification from [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792).\n\n> **Open for feedback**  \n> You are welcome to provide feedback on this implementation by commenting on [XIP-59: Trigger on-chain calls via wallet_sendCalls](https://community.xmtp.org/t/xip-59-trigger-on-chain-calls-via-wallet-sendcalls/889).\n\n## Install the package\n\n```bash\n# npm\nnpm i @xmtp/content-type-wallet-send-calls\n\n# yarn\nyarn add @xmtp/content-type-wallet-send-calls\n\n# pnpm\npnpm i @xmtp/content-type-wallet-send-calls\n```\n\n## Create a transaction request\n\nWith XMTP, a transaction request is represented using `wallet_sendCalls` with additional metadata for display:\n\n```tsx\nconst walletSendCalls: WalletSendCallsParams = {\n  version: \"1.0\",\n  from: \"0x123...abc\",\n  chainId: \"0x2105\",\n  calls: [\n    {\n      to: \"0x456...def\",\n      value: \"0x5AF3107A4000\",\n      metadata: {\n        description: \"Send 0.0001 ETH on base to 0x456...def\",\n        transactionType: \"transfer\",\n        currency: \"ETH\",\n        amount: 100000000000000,\n        decimals: 18,\n        toAddress: \"0x456...def\",\n      },\n    },\n    {\n      to: \"0x789...cba\",\n      data: \"0xdead...beef\",\n      metadata: {\n        description: \"Lend 10 USDC on base with Morpho @ 8.5% APY\",\n        transactionType: \"lend\",\n        currency: \"USDC\",\n        amount: 10000000,\n        decimals: 6,\n        platform: \"morpho\",\n        apy: \"8.5\",\n      },\n    },\n  ],\n};\n```\n\n## Send a transaction request\n\nOnce you have a transaction reference, you can send it as part of your conversation:\n\n```tsx\nawait conversation.messages.send(walletSendCalls, {\n  contentType: ContentTypeWalletSendCalls,\n});\n```\n\n## Receive a transaction request\n\nTo receive and process a transaction request:\n\n```tsx\n// Assume `loadLastMessage` is a thing you have\nconst message: DecodedMessage = await loadLastMessage();\n\nif (!message.contentType.sameAs(ContentTypeWalletSendCalls)) {\n  // Handle non-transaction request message\n  return;\n}\n\nconst walletSendCalls: WalletSendCallsParams = message.content;\n// Process the transaction request here\n```\n\n## Developing\n\nRun `yarn dev` to build the content type and watch for changes, which will trigger a rebuild.\n\nFor more information on contributing to this repository, see our [contributing guidelines](../../CONTRIBUTING.md).\n",
      "size_bytes": 2440
    },
    "apps/xmtp.chat/src/components/IdentityBadge.tsx": {
      "content": "import { Badge, Text, Tooltip, type MantineStyleProps } from \"@mantine/core\";\nimport { forwardRef } from \"react\";\nimport { useMemberPopover } from \"@/components/Conversation/MemberPopover\";\nimport { shortAddress } from \"@/helpers/strings\";\n\nexport type IdentityBadgeProps = {\n  address: string;\n  displayName: string | null;\n  size?: \"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\";\n  tooltip?: string;\n} & Pick<MantineStyleProps, \"w\">;\n\nexport const IdentityBadge = forwardRef<HTMLDivElement, IdentityBadgeProps>(\n  ({ address, displayName, size = \"lg\", w, tooltip }, ref) => {\n    const { setOpened } = useMemberPopover();\n    return (\n      <Tooltip\n        label={tooltip ? <Text size=\"xs\">{tooltip}</Text> : null}\n        disabled={!tooltip}>\n        <Badge\n          ref={ref}\n          radius=\"md\"\n          variant=\"default\"\n          size={size}\n          tabIndex={0}\n          w={w}\n          styles={{\n            label: {\n              textTransform: \"none\",\n            },\n            root: {\n              cursor: \"pointer\",\n            },\n          }}\n          onClick={(e) => {\n            e.stopPropagation();\n            setOpened((o) => !o);\n          }}>\n          {displayName || shortAddress(address)}\n        </Badge>\n      </Tooltip>\n    );\n  },\n);\n",
      "size_bytes": 1260
    },
    "sdks/agent-sdk/CHANGELOG.md": {
      "content": "# @xmtp/agent-sdk\n\n## 1.1.9\n\n### Patch Changes\n\n- bde0bfb: Expose `XMTP_DB_DIRECTORY` for `Agent.createFromEnv`\n\n## 1.1.8\n\n### Patch Changes\n\n- 9003bb9: Enable hex strings as database encryption keys\n- Updated dependencies [9003bb9]\n  - @xmtp/node-sdk@4.2.4\n\n## 1.1.7\n\n### Patch Changes\n\n- 8279497: Added warning about installation limit\n\n## 1.1.6\n\n### Patch Changes\n\n- 932f01d: - Fixed an issue where duplicate welcome errors were fired erroneously\n  - Fixed a bug where building a client did a network request when not needed\n\n## 1.1.5\n\n### Patch Changes\n\n- d0798bc: Updated `@xmtp/node-sdk` dependency to `^4.2.2`\n\n## 1.1.4\n\n### Patch Changes\n\n- 45160dc: Added `MessageContext.useCodec` to identify custom content types\n\n## 1.1.3\n\n### Patch Changes\n\n- 3c28612: Added XMTP_FORCE_DEBUG_LEVEL env variable\n\n## 1.1.2\n\n### Patch Changes\n\n- 9538002: Added ENS name resolution\n\n## 1.1.1\n\n### Patch Changes\n\n- a0b5d11: Updated Node SDK in Agent SDK\n\n## 1.1.0\n\n### Minor Changes\n\n- 70d1a21: Added listening to conversation events\n\n## 1.0.1\n\n### Patch Changes\n\n- 54577da: Added \"group-update\" events\n\n## 1.0.0\n\n### Major Changes\n\n- 5b0c9f8: Removed Beta label\n\n## 0.0.17\n\n### Patch Changes\n\n- e0b035c: - Added conversation creation\n\n## 0.0.16\n\n### Patch Changes\n\n- 07ea5c3: - Exposed `debug`, `middleware`, and `user` packages\n  - Passed `ClientContext` to `start` and `stop` event listeners\n\n## 0.0.15\n\n### Patch Changes\n\n- 07fa1c3: Implemented message streaming with callbacks\n\n## 0.0.14\n\n### Patch Changes\n\n- 4da121f: Remove listening to `'dm'` and `'group'` events\n\n## 0.0.13\n\n### Patch Changes\n\n- b4f86cc: - Simplified filter usage with parameter-based API\n  - Removed `withFilter`\n  - Changed all interface definitions to type definitions\n  - Updated `ConversationContext` to use new filter methods\n  - Introduced unified context types in `AgentContext`\n\n## 0.0.12\n\n### Patch Changes\n\n- 2bcf5ee: - Renamed `ctx.getOwnAddress()` to `ctx.getClientAddress()`\n  - Added `AgentError` class with `cause` attribute (keeping the originating error)\n  - Introduced error `code` values for programmatic handling of `AgentError` instances\n  - Added Context hierarchy: `ClientContext` → client, `ConversationContext` → client, conversation, `MessageContext` → client, conversation, message\n  - Added `AgentContext` union type for all contexts\n  - Error middleware now receives `AgentErrorContext` (holds client, conversation, message if available)\n\n## 0.0.11\n\n### Patch Changes\n\n- 7e0c321: - Removed \"crypto\" and \"message\" utils\n  - Removed `filter.notFromSelf` in favor of `!filter.fromSelf`\n  - Added `filter.hasDefinedContent`\n  - Added `filter.isDM`\n  - Added `filter.isGroup`\n  - Added `filter.isReaction`\n  - Added `filter.isRemoteAttachment`\n  - Added `filter.isReply`\n  - Added `filter.isTextReply`\n  - Allowed async filters\n  - Added tests to verify typed message content in event callbacks\n\n## 0.0.10\n\n### Patch Changes\n\n- 20d64c3: Skipped messages from agent itself in middleware\n\n## 0.0.9\n\n### Patch Changes\n\n- 854a9d1: - Renamed `filter.textOnly` to `filter.isText`\n  - Renamed `AgentContext` to `MessageContext`\n  - Renamed event `on(\"message\")` to `on(\"unhandledMessage\")`\n  - Added `on(\"dm\")` for direct messages\n  - Added `on(\"attachment\")` for remote attachments\n  - Added `on(\"group\")` for group messages\n  - Added `on(\"reaction\")` for reactions\n  - Added `on(\"reply\")` for replies\n  - Introduced `ConversationContext` for handling new conversations\n\n## 0.0.8\n\n### Patch Changes\n\n- 0857103: - Forced middleware to call `next` to execute the next middleware or `return` to break the middleware chain\n  - Made `use` accept an array of middlewares\n  - Forwarded options to `streamAllMessages`\n  - Replaced `generatePrivateKey` with implementation from `viem/accounts`\n  - Removed `@noble/curves` package\n  - Renamed `AgentEventHandler` to `AgentMessageHandler`\n  - Introduced error-handling middleware chain (`agent.errors.on`)\n\n## 0.0.7\n\n### Patch Changes\n\n- b296a2a: - Exposed default middleware\n  - Exposed debug utils\n  - Added default Reaction schema\n\n## 0.0.6\n\n### Patch Changes\n\n- 8277202: Locked dependency versions\n\n## 0.0.5\n\n### Patch Changes\n\n- 071aed4: - Made `signer` optional in `Agent.create` to allow Agent configuration via env variables\n  - Introduced `crypto` utils\n  - Exposed `filter` with `f` alias\n  - Introduced `XMTP_FORCE_REVOKE_INSTALLATIONS` and `XMTP_FORCE_DEBUG`\n  - Removed `Agent.build`\n  - Added `gen:keys` command for agent contributors\n  - Added `CommandRouter` middleware\n  - Added `startsWith` filter\n  - Added codecs for `Reaction` and `RemoteAttachment`\n  - Added `sendReaction` functionality through `AgentContext`\n  - Added `getOwnAddress()` in `AgentContext`\n  - Added `debug` util with `logDetails()` functionality\n  - Added `message` utils with type guards for different content types\n\n## 0.0.4\n\n### Patch Changes\n\n- 880f8f2: Added path alias resolution\n\n## 0.0.3\n\n### Patch Changes\n\n- f83dcf9: Fixed module resolution for ESM\n\n## 0.0.2\n\n### Patch Changes\n\n- 5a2bd1e: Fixed dist reference in Agent SDK\n",
      "size_bytes": 5054
    },
    "apps/xmtp.chat/src/components/Conversation/Conversation.tsx": {
      "content": "import { ActionIcon, Group, Text, Tooltip } from \"@mantine/core\";\nimport { useDisclosure } from \"@mantine/hooks\";\nimport { Group as XmtpGroup } from \"@xmtp/browser-sdk\";\nimport { useCallback, useEffect } from \"react\";\nimport { Outlet } from \"react-router\";\nimport { ConversationMenu } from \"@/components/Conversation/ConversationMenu\";\nimport { MembersList } from \"@/components/Conversation/MembersList\";\nimport { Messages } from \"@/components/Messages/Messages\";\nimport { ConversationProvider } from \"@/contexts/ConversationContext\";\nimport { resolveAddresses } from \"@/helpers/profiles\";\nimport { getMemberAddress } from \"@/helpers/xmtp\";\nimport { useConversation } from \"@/hooks/useConversation\";\nimport { IconUsers } from \"@/icons/IconUsers\";\nimport { ContentLayout } from \"@/layouts/ContentLayout\";\nimport { Composer } from \"./Composer\";\nimport classes from \"./Conversation.module.css\";\n\nexport type ConversationProps = {\n  conversationId: string;\n};\n\nexport const Conversation: React.FC<ConversationProps> = ({\n  conversationId,\n}) => {\n  const [opened, { toggle }] = useDisclosure();\n  const {\n    conversation,\n    name,\n    sync,\n    loading: conversationLoading,\n    messages,\n    members,\n    syncing: conversationSyncing,\n  } = useConversation(conversationId);\n\n  useEffect(() => {\n    const loadMessages = async () => {\n      await sync(true);\n    };\n    void loadMessages();\n  }, [conversationId]);\n\n  useEffect(() => {\n    void resolveAddresses(\n      Array.from(members.values()).map((m) => getMemberAddress(m)),\n    );\n  }, [members]);\n\n  const handleSync = useCallback(async () => {\n    await sync(true);\n  }, [sync, conversationId]);\n\n  return (\n    <>\n      <ConversationProvider\n        key={conversationId}\n        conversationId={conversationId}>\n        <ContentLayout\n          className={classes.shell}\n          headerClassName={classes.header}\n          contentClassName={classes.content}\n          footerClassName={classes.footer}\n          asideClassName={classes.membersAside}\n          title={name || \"Untitled\"}\n          loading={messages.length === 0 && conversationLoading}\n          headerActions={\n            <Group gap=\"xxs\">\n              <ConversationMenu\n                conversationId={conversationId}\n                type={conversation instanceof XmtpGroup ? \"group\" : \"dm\"}\n                onSync={() => void handleSync()}\n                disabled={conversationSyncing}\n              />\n              <Tooltip\n                label={\n                  opened ? (\n                    <Text size=\"xs\">Hide members</Text>\n                  ) : (\n                    <Text size=\"xs\">Show members</Text>\n                  )\n                }>\n                <ActionIcon\n                  variant=\"default\"\n                  onClick={() => {\n                    toggle();\n                  }}>\n                  <IconUsers />\n                </ActionIcon>\n              </Tooltip>\n            </Group>\n          }\n          aside={\n            <MembersList conversationId={conversationId} toggle={toggle} />\n          }\n          asideOpened={opened}\n          footer={<Composer conversationId={conversationId} />}\n          withScrollArea={false}>\n          <Messages messages={messages} />\n        </ContentLayout>\n      </ConversationProvider>\n      <Outlet context={{ conversationId }} />\n    </>\n  );\n};\n",
      "size_bytes": 3350
    },
    "content-types/content-type-group-updated/README.md": {
      "content": "# Group updated content type\n\nThis package provides an XMTP content type to support group updated messages.\n\n> [!NOTE]\n> This content type is included by default in official XMTP SDKs.\n\n## Install the package\n\n```bash\n# npm\nnpm i @xmtp/content-type-group-updated\n\n# yarn\nyarn add @xmtp/content-type-group-updated\n\n# pnpm\npnpm i @xmtp/content-type-group-updated\n```\n\n## Developing\n\nRun `yarn dev` to build the content type and watch for changes, which will trigger a rebuild.\n\nFor more information on contributing to this repository, see our [contributing guidelines](../../CONTRIBUTING.md).\n",
      "size_bytes": 591
    },
    "content-types/content-type-reaction/src/Reaction.ts": {
      "content": "import {\n  ContentTypeId,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\n\nexport const ContentTypeReaction = new ContentTypeId({\n  authorityId: \"xmtp.org\",\n  typeId: \"reaction\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\nexport type Reaction = {\n  /**\n   * The message ID for the message that is being reacted to\n   */\n  reference: string;\n  /**\n   * The inbox ID of the user who sent the message that is being reacted to\n   *\n   * This only applies to group messages\n   */\n  referenceInboxId?: string;\n  /**\n   * The action of the reaction\n   */\n  action: \"added\" | \"removed\";\n  /**\n   * The content of the reaction\n   */\n  content: string;\n  /**\n   * The schema of the content to provide guidance on how to display it\n   */\n  schema: \"unicode\" | \"shortcode\" | \"custom\";\n};\n\nexport type LegacyReactionParameters = Pick<\n  Reaction,\n  \"action\" | \"reference\" | \"schema\"\n> & {\n  encoding: \"UTF-8\";\n};\n\nexport class ReactionCodec\n  implements\n    ContentCodec<Reaction, LegacyReactionParameters | Record<string, never>>\n{\n  get contentType(): ContentTypeId {\n    return ContentTypeReaction;\n  }\n\n  encode(reaction: Reaction) {\n    const { action, reference, referenceInboxId, schema, content } = reaction;\n    return {\n      type: this.contentType,\n      parameters: {},\n      content: new TextEncoder().encode(\n        JSON.stringify({\n          action,\n          reference,\n          referenceInboxId,\n          schema,\n          content,\n        }),\n      ),\n    };\n  }\n\n  decode(encodedContent: EncodedContent<LegacyReactionParameters>): Reaction {\n    const decodedContent = new TextDecoder().decode(encodedContent.content);\n\n    // First try to decode it in the canonical form.\n    try {\n      const reaction = JSON.parse(decodedContent) as Reaction;\n      const { action, reference, referenceInboxId, schema, content } = reaction;\n      return { action, reference, referenceInboxId, schema, content };\n    } catch {\n      // ignore, fall through to legacy decoding\n    }\n\n    // If that fails, try to decode it in the legacy form.\n    const parameters = encodedContent.parameters;\n    return {\n      action: parameters.action,\n      reference: parameters.reference,\n      schema: parameters.schema,\n      content: decodedContent,\n    };\n  }\n\n  fallback(content: Reaction): string | undefined {\n    switch (content.action) {\n      case \"added\":\n        return `Reacted “${content.content}” to an earlier message`;\n      case \"removed\":\n        return `Removed “${content.content}” from an earlier message`;\n      default:\n        return undefined;\n    }\n  }\n\n  shouldPush(): boolean {\n    return false;\n  }\n}\n",
      "size_bytes": 2657
    },
    "sdks/node-sdk/src/types.ts": {
      "content": "import type { ContentCodec } from \"@xmtp/content-type-primitives\";\nimport type { LogLevel } from \"@xmtp/node-bindings\";\nimport type { ApiUrls } from \"@/constants\";\nimport type { HexString } from \"./utils/validation\";\n\n/**\n * XMTP environment\n */\nexport type XmtpEnv = keyof typeof ApiUrls;\n\n/**\n * Network options\n */\nexport type NetworkOptions = {\n  /**\n   * Specify which XMTP environment to connect to. (default: `dev`)\n   *\n   * @see https://docs.xmtp.org/chat-apps/core-messaging/create-a-client#xmtp-network-environments\n   */\n  env?: XmtpEnv;\n  /**\n   * apiUrl can be used to override the `env` flag and connect to a\n   * specific endpoint\n   */\n  apiUrl?: string;\n  /**\n   * historySyncUrl can be used to override the `env` flag and connect to a\n   * specific endpoint for syncing history\n   *\n   * @see https://docs.xmtp.org/chat-apps/list-stream-sync/history-sync\n   */\n  historySyncUrl?: string | null;\n};\n\n/**\n * Storage options\n */\nexport type StorageOptions = {\n  /**\n   * Path to the local DB\n   *\n   * There are 4 value types that can be used to specify the database path:\n   *\n   * - `undefined` (or excluded from the client options)\n   *    The database will be created in the current working directory and is based on\n   *    the XMTP environment and client inbox ID.\n   *    Example: `xmtp-dev-<inbox-id>.db3`\n   *\n   * - `null`\n   *    No database will be created and all data will be lost once the client disconnects.\n   *\n   * - `string`\n   *    The given path will be used to create the database.\n   *    Example: `./my-db.db3`\n   *\n   * - `function`\n   *    A callback function that receives the inbox ID and returns a string path.\n   *    Example: `(inboxId) => string`\n   */\n  dbPath?: string | null | ((inboxId: string) => string);\n  /**\n   * Encryption key for the local DB (32 bytes, hex)\n   *\n   * @see https://docs.xmtp.org/chat-apps/core-messaging/create-a-client#view-an-encrypted-database\n   */\n  dbEncryptionKey?: Uint8Array | HexString;\n};\n\nexport type ContentOptions = {\n  /**\n   * Allow configuring codecs for additional content types\n   */\n  codecs?: ContentCodec[];\n};\n\nexport type OtherOptions = {\n  /**\n   * Enable structured JSON logging\n   */\n  structuredLogging?: boolean;\n  /**\n   * Logging level\n   */\n  loggingLevel?: LogLevel;\n  /**\n   * Disable automatic registration when creating a client\n   */\n  disableAutoRegister?: boolean;\n  /**\n   * Disable device sync\n   */\n  disableDeviceSync?: boolean;\n  /**\n   * Custom app version\n   */\n  appVersion?: string;\n  /**\n   * Should debug events be tracked\n   * (default: false)\n   */\n  debugEventsEnabled?: boolean;\n};\n\nexport type ClientOptions = NetworkOptions &\n  StorageOptions &\n  ContentOptions &\n  OtherOptions;\n",
      "size_bytes": 2713
    },
    "apps/xmtp.chat/src/components/App/ConnectWallet.tsx": {
      "content": "import { Button } from \"@mantine/core\";\nimport { useCallback } from \"react\";\nimport { useConnectWallet } from \"@/hooks/useConnectWallet\";\nimport { useSettings } from \"@/hooks/useSettings\";\n\nexport const ConnectWallet: React.FC = () => {\n  const { connect, disconnect, loading, isConnected } = useConnectWallet();\n  const { connector, ephemeralAccountEnabled } = useSettings();\n\n  const handleConnect = useCallback(() => {\n    if (isConnected) {\n      disconnect();\n    } else {\n      connect(connector)();\n    }\n  }, [connect, connector, isConnected, disconnect]);\n\n  return (\n    <Button\n      color={isConnected ? \"red\" : \"var(--mantine-color-primary)\"}\n      onClick={handleConnect}\n      loading={loading}\n      disabled={ephemeralAccountEnabled}>\n      {isConnected ? \"Disconnect\" : \"Connect\"}\n    </Button>\n  );\n};\n",
      "size_bytes": 821
    },
    "apps/xmtp.chat/src/components/Conversation/Permissions.tsx": {
      "content": "import { Box, Group, NativeSelect, Stack, Text, Tooltip } from \"@mantine/core\";\nimport {\n  GroupPermissionsOptions,\n  MetadataField,\n  PermissionPolicy,\n  PermissionUpdateType,\n  Group as XmtpGroup,\n  type Conversation,\n} from \"@xmtp/browser-sdk\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport type { PolicySet } from \"@/types\";\n\nconst PERMISSION_VALUES = [\n  { value: \"0\", label: \"Everyone\" },\n  { value: \"1\", label: \"Disabled\" },\n  { value: \"2\", label: \"Admin only\" },\n  { value: \"3\", label: \"Super admin only\" },\n];\n\nexport const defaultPolicySet: PolicySet = {\n  addAdminPolicy: PermissionPolicy.SuperAdmin,\n  addMemberPolicy: PermissionPolicy.Allow,\n  removeAdminPolicy: PermissionPolicy.SuperAdmin,\n  removeMemberPolicy: PermissionPolicy.Admin,\n  updateGroupNamePolicy: PermissionPolicy.Allow,\n  updateGroupDescriptionPolicy: PermissionPolicy.Allow,\n  updateGroupImageUrlSquarePolicy: PermissionPolicy.Allow,\n  updateMessageDisappearingPolicy: PermissionPolicy.Admin,\n};\n\nexport const adminPolicySet: PolicySet = {\n  addAdminPolicy: PermissionPolicy.SuperAdmin,\n  addMemberPolicy: PermissionPolicy.Admin,\n  removeAdminPolicy: PermissionPolicy.SuperAdmin,\n  removeMemberPolicy: PermissionPolicy.Admin,\n  updateGroupNamePolicy: PermissionPolicy.Admin,\n  updateGroupDescriptionPolicy: PermissionPolicy.Admin,\n  updateGroupImageUrlSquarePolicy: PermissionPolicy.Admin,\n  updateMessageDisappearingPolicy: PermissionPolicy.Admin,\n};\n\nexport const processPermissionsUpdate = async (\n  conversation: Conversation,\n  permissionsPolicy: GroupPermissionsOptions,\n  policySet: PolicySet,\n) => {\n  if (!(conversation instanceof XmtpGroup)) {\n    return;\n  }\n\n  const permissions = await conversation.permissions();\n\n  // policy type has changed and is not a custom policy\n  if (\n    permissions.policyType !== permissionsPolicy &&\n    permissionsPolicy !== GroupPermissionsOptions.CustomPolicy\n  ) {\n    switch (permissionsPolicy) {\n      case GroupPermissionsOptions.Default: {\n        await conversation.updatePermission(\n          PermissionUpdateType.AddMember,\n          defaultPolicySet.addMemberPolicy,\n        );\n        await conversation.updatePermission(\n          PermissionUpdateType.RemoveMember,\n          defaultPolicySet.removeMemberPolicy,\n        );\n        await conversation.updatePermission(\n          PermissionUpdateType.AddAdmin,\n          defaultPolicySet.addAdminPolicy,\n        );\n        await conversation.updatePermission(\n          PermissionUpdateType.RemoveAdmin,\n          defaultPolicySet.removeAdminPolicy,\n        );\n        await conversation.updatePermission(\n          PermissionUpdateType.UpdateMetadata,\n          defaultPolicySet.updateGroupNamePolicy,\n          MetadataField.GroupName,\n        );\n        await conversation.updatePermission(\n          PermissionUpdateType.UpdateMetadata,\n          defaultPolicySet.updateGroupDescriptionPolicy,\n          MetadataField.Description,\n        );\n        await conversation.updatePermission(\n          PermissionUpdateType.UpdateMetadata,\n          defaultPolicySet.updateGroupImageUrlSquarePolicy,\n          MetadataField.ImageUrlSquare,\n        );\n        break;\n      }\n      case GroupPermissionsOptions.AdminOnly: {\n        await conversation.updatePermission(\n          PermissionUpdateType.AddMember,\n          adminPolicySet.addMemberPolicy,\n        );\n        await conversation.updatePermission(\n          PermissionUpdateType.RemoveMember,\n          adminPolicySet.removeMemberPolicy,\n        );\n        await conversation.updatePermission(\n          PermissionUpdateType.AddAdmin,\n          adminPolicySet.addAdminPolicy,\n        );\n        await conversation.updatePermission(\n          PermissionUpdateType.RemoveAdmin,\n          adminPolicySet.removeAdminPolicy,\n        );\n        await conversation.updatePermission(\n          PermissionUpdateType.UpdateMetadata,\n          adminPolicySet.updateGroupNamePolicy,\n          MetadataField.GroupName,\n        );\n        await conversation.updatePermission(\n          PermissionUpdateType.UpdateMetadata,\n          adminPolicySet.updateGroupDescriptionPolicy,\n          MetadataField.Description,\n        );\n        await conversation.updatePermission(\n          PermissionUpdateType.UpdateMetadata,\n          adminPolicySet.updateGroupImageUrlSquarePolicy,\n          MetadataField.ImageUrlSquare,\n        );\n      }\n    }\n  }\n\n  // policy type is a custom policy\n  if (permissionsPolicy === GroupPermissionsOptions.CustomPolicy) {\n    await conversation.updatePermission(\n      PermissionUpdateType.AddMember,\n      policySet.addMemberPolicy,\n    );\n    await conversation.updatePermission(\n      PermissionUpdateType.RemoveMember,\n      policySet.removeMemberPolicy,\n    );\n    await conversation.updatePermission(\n      PermissionUpdateType.AddAdmin,\n      policySet.addAdminPolicy,\n    );\n    await conversation.updatePermission(\n      PermissionUpdateType.RemoveAdmin,\n      policySet.removeAdminPolicy,\n    );\n    await conversation.updatePermission(\n      PermissionUpdateType.UpdateMetadata,\n      policySet.updateGroupNamePolicy,\n      MetadataField.GroupName,\n    );\n    await conversation.updatePermission(\n      PermissionUpdateType.UpdateMetadata,\n      policySet.updateGroupDescriptionPolicy,\n      MetadataField.Description,\n    );\n    await conversation.updatePermission(\n      PermissionUpdateType.UpdateMetadata,\n      policySet.updateGroupImageUrlSquarePolicy,\n      MetadataField.ImageUrlSquare,\n    );\n  }\n};\n\nexport type PermissionsProps = {\n  conversation?: Conversation;\n  onPermissionsPolicyChange: (\n    permissionsPolicy: GroupPermissionsOptions,\n  ) => void;\n  onPolicySetChange: (policySet: PolicySet) => void;\n};\n\nexport const Permissions: React.FC<PermissionsProps> = ({\n  conversation,\n  onPermissionsPolicyChange,\n  onPolicySetChange,\n}) => {\n  const [permissionsPolicy, setPermissionsPolicy] =\n    useState<GroupPermissionsOptions>(GroupPermissionsOptions.Default);\n  const [policySet, setPolicySet] = useState<PolicySet>(defaultPolicySet);\n\n  const policyTooltip = useMemo(() => {\n    if (permissionsPolicy === GroupPermissionsOptions.Default) {\n      return \"All members of the group can perform group actions\";\n    } else if (permissionsPolicy === GroupPermissionsOptions.AdminOnly) {\n      return \"Only admins can perform group actions\";\n    }\n    return \"Custom policy as defined below\";\n  }, [permissionsPolicy]);\n\n  useEffect(() => {\n    if (\n      permissionsPolicy === GroupPermissionsOptions.Default ||\n      permissionsPolicy === GroupPermissionsOptions.CustomPolicy\n    ) {\n      setPolicySet(defaultPolicySet);\n    } else {\n      setPolicySet(adminPolicySet);\n    }\n    onPermissionsPolicyChange(permissionsPolicy);\n  }, [permissionsPolicy]);\n\n  useEffect(() => {\n    onPolicySetChange(policySet);\n  }, [policySet]);\n\n  useEffect(() => {\n    if (!conversation || !(conversation instanceof XmtpGroup)) {\n      return;\n    }\n\n    const loadPermissions = async () => {\n      const permissions = await conversation.permissions();\n      const policyType = permissions.policyType;\n      switch (policyType) {\n        case GroupPermissionsOptions.Default:\n          setPermissionsPolicy(GroupPermissionsOptions.Default);\n          setPolicySet(defaultPolicySet);\n          break;\n        case GroupPermissionsOptions.AdminOnly:\n          setPermissionsPolicy(GroupPermissionsOptions.AdminOnly);\n          setPolicySet(adminPolicySet);\n          break;\n        case GroupPermissionsOptions.CustomPolicy:\n          setPermissionsPolicy(GroupPermissionsOptions.CustomPolicy);\n          setPolicySet(permissions.policySet);\n          break;\n      }\n    };\n    void loadPermissions();\n  }, [conversation?.id]);\n\n  return (\n    <Box p=\"md\">\n      <Stack gap=\"md\">\n        <Group gap=\"md\" justify=\"space-between\" align=\"center\">\n          <Text size=\"sm\">Policy</Text>\n          <Tooltip withArrow label={<Text size=\"xs\">{policyTooltip}</Text>}>\n            <NativeSelect\n              value={permissionsPolicy}\n              onChange={(event) => {\n                setPermissionsPolicy(\n                  parseInt(\n                    event.currentTarget.value,\n                    10,\n                  ) as GroupPermissionsOptions,\n                );\n              }}\n              data={[\n                { value: \"0\", label: \"Default\" },\n                { value: \"1\", label: \"Admin only\" },\n                { value: \"2\", label: \"Custom policy\" },\n              ]}\n            />\n          </Tooltip>\n        </Group>\n        <Group gap=\"md\" justify=\"space-between\" align=\"center\">\n          <Text size=\"sm\">Add members</Text>\n          <NativeSelect\n            disabled={\n              permissionsPolicy !== GroupPermissionsOptions.CustomPolicy\n            }\n            value={policySet.addMemberPolicy}\n            onChange={(event) => {\n              setPolicySet({\n                ...policySet,\n                addMemberPolicy: parseInt(\n                  event.currentTarget.value,\n                  10,\n                ) as PermissionPolicy,\n              });\n            }}\n            data={PERMISSION_VALUES}\n          />\n        </Group>\n        <Group gap=\"md\" justify=\"space-between\" align=\"center\">\n          <Text size=\"sm\">Remove members</Text>\n          <NativeSelect\n            disabled={\n              permissionsPolicy !== GroupPermissionsOptions.CustomPolicy\n            }\n            value={policySet.removeMemberPolicy}\n            onChange={(event) => {\n              setPolicySet({\n                ...policySet,\n                removeMemberPolicy: parseInt(\n                  event.currentTarget.value,\n                  10,\n                ) as PermissionPolicy,\n              });\n            }}\n            data={PERMISSION_VALUES}\n          />\n        </Group>\n        <Group gap=\"md\" justify=\"space-between\" align=\"center\">\n          <Text size=\"sm\">Add admins</Text>\n          <NativeSelect\n            disabled={\n              permissionsPolicy !== GroupPermissionsOptions.CustomPolicy\n            }\n            value={policySet.addAdminPolicy}\n            onChange={(event) => {\n              setPolicySet({\n                ...policySet,\n                addAdminPolicy: parseInt(\n                  event.currentTarget.value,\n                  10,\n                ) as PermissionPolicy,\n              });\n            }}\n            data={PERMISSION_VALUES}\n          />\n        </Group>\n        <Group gap=\"md\" justify=\"space-between\" align=\"center\">\n          <Text size=\"sm\">Remove admins</Text>\n          <NativeSelect\n            disabled={\n              permissionsPolicy !== GroupPermissionsOptions.CustomPolicy\n            }\n            value={policySet.removeAdminPolicy}\n            onChange={(event) => {\n              setPolicySet({\n                ...policySet,\n                removeAdminPolicy: parseInt(\n                  event.currentTarget.value,\n                  10,\n                ) as PermissionPolicy,\n              });\n            }}\n            data={PERMISSION_VALUES}\n          />\n        </Group>\n        <Group gap=\"md\" justify=\"space-between\" align=\"center\">\n          <Text size=\"sm\">Update group name</Text>\n          <NativeSelect\n            disabled={\n              permissionsPolicy !== GroupPermissionsOptions.CustomPolicy\n            }\n            value={policySet.updateGroupNamePolicy}\n            onChange={(event) => {\n              setPolicySet({\n                ...policySet,\n                updateGroupNamePolicy: parseInt(\n                  event.currentTarget.value,\n                  10,\n                ) as PermissionPolicy,\n              });\n            }}\n            data={PERMISSION_VALUES}\n          />\n        </Group>\n        <Group gap=\"md\" justify=\"space-between\" align=\"center\">\n          <Text size=\"sm\">Update group description</Text>\n          <NativeSelect\n            disabled={\n              permissionsPolicy !== GroupPermissionsOptions.CustomPolicy\n            }\n            value={policySet.updateGroupDescriptionPolicy}\n            onChange={(event) => {\n              setPolicySet({\n                ...policySet,\n                updateGroupDescriptionPolicy: parseInt(\n                  event.currentTarget.value,\n                  10,\n                ) as PermissionPolicy,\n              });\n            }}\n            data={PERMISSION_VALUES}\n          />\n        </Group>\n        <Group gap=\"md\" justify=\"space-between\" align=\"center\">\n          <Text size=\"sm\">Update group image</Text>\n          <NativeSelect\n            disabled={\n              permissionsPolicy !== GroupPermissionsOptions.CustomPolicy\n            }\n            value={policySet.updateGroupImageUrlSquarePolicy}\n            onChange={(event) => {\n              setPolicySet({\n                ...policySet,\n                updateGroupImageUrlSquarePolicy: parseInt(\n                  event.currentTarget.value,\n                  10,\n                ) as PermissionPolicy,\n              });\n            }}\n            data={PERMISSION_VALUES}\n          />\n        </Group>\n      </Stack>\n    </Box>\n  );\n};\n",
      "size_bytes": 13083
    },
    "apps/xmtp.chat/src/components/Conversations/ConversationCard.tsx": {
      "content": "import { Box, Card, Flex, Stack, Text } from \"@mantine/core\";\nimport type { DecodedMessage } from \"@xmtp/browser-sdk\";\nimport { ContentTypeGroupUpdated } from \"@xmtp/content-type-group-updated\";\nimport { ContentTypeReadReceipt } from \"@xmtp/content-type-read-receipt\";\nimport { ContentTypeRemoteAttachment } from \"@xmtp/content-type-remote-attachment\";\nimport { ContentTypeReply } from \"@xmtp/content-type-reply\";\nimport { differenceInCalendarDays, format, isToday } from \"date-fns\";\nimport { useMemo } from \"react\";\nimport { useNavigate, useParams } from \"react-router\";\nimport { useConversation } from \"@/hooks/useConversation\";\nimport { nsToDate } from \"@/helpers/date\";\nimport styles from \"./ConversationCard.module.css\";\n\nexport type ConversationCardProps = {\n  conversationId: string;\n};\n\nexport const ConversationCard: React.FC<ConversationCardProps> = ({\n  conversationId,\n}) => {\n  const { name, members, messages } = useConversation(conversationId);\n  const navigate = useNavigate();\n  const { conversationId: paramsConversationId } = useParams();\n\n  const memberCount = useMemo(() => {\n    return members.size;\n  }, [members]);\n\n  const { previewText, sentAtLabel } = useMemo(() => {\n    const latest = messages[messages.length - 1];\n\n    const resolvePreview = (message?: DecodedMessage) => {\n      if (!message) {\n        return `${memberCount} member${memberCount !== 1 ? \"s\" : \"\"}`;\n      }\n      if (typeof message.content === \"string\") {\n        return message.content;\n      }\n      if (typeof message.fallback === \"string\") {\n        return message.fallback;\n      }\n      if (message.contentType.sameAs(ContentTypeRemoteAttachment)) {\n        return \"📎 Attachment\";\n      }\n      if (message.contentType.sameAs(ContentTypeGroupUpdated)) {\n        return \"Group update\";\n      }\n      if (message.contentType.sameAs(ContentTypeReadReceipt)) {\n        return \"Read receipt\";\n      }\n      if (message.contentType.sameAs(ContentTypeReply)) {\n        return \"↩︎ Reply\";\n      }\n      return \"Unsupported content\";\n    };\n\n    const resolveSentAt = (message?: DecodedMessage) => {\n      if (!message) return null;\n      const sentAt = nsToDate(message.sentAtNs);\n      if (isToday(sentAt)) {\n        return format(sentAt, \"HH:mm\");\n      }\n      if (differenceInCalendarDays(new Date(), sentAt) < 7) {\n        return format(sentAt, \"EEE\");\n      }\n      return format(sentAt, \"MMM d\");\n    };\n\n    return {\n      previewText: resolvePreview(latest),\n      sentAtLabel: resolveSentAt(latest),\n    };\n  }, [messages, memberCount]);\n\n  return (\n    <Box px=\"sm\">\n      <Card\n        shadow=\"sm\"\n        padding=\"sm\"\n        radius=\"md\"\n        withBorder\n        tabIndex={0}\n        onKeyDown={(e) => {\n          if (e.key === \"Enter\") {\n            void navigate(`/conversations/${conversationId}`);\n          }\n        }}\n        onClick={() => void navigate(`/conversations/${conversationId}`)}\n        className={[\n          styles.root,\n          conversationId === paramsConversationId && styles.selected,\n        ].join(\" \")}>\n        <Stack gap=\"xs\">\n          <Flex align=\"flex-start\" justify=\"space-between\" gap=\"xs\">\n            <Text fw={700} className={styles.title} lineClamp={1}>\n              {name || \"Untitled\"}\n            </Text>\n            {sentAtLabel && (\n              <Text size=\"xs\" c=\"dimmed\" className={styles.time}>\n                {sentAtLabel}\n              </Text>\n            )}\n          </Flex>\n          <Text size=\"sm\" c=\"dimmed\" className={styles.preview} lineClamp={2}>\n            {previewText}\n          </Text>\n          <Text size=\"xs\" c=\"dimmed\" className={styles.meta}>\n            {memberCount} member{memberCount !== 1 ? \"s\" : \"\"}\n          </Text>\n        </Stack>\n      </Card>\n    </Box>\n  );\n};\n",
      "size_bytes": 3767
    },
    "apps/xmtp.chat/public/sw.js": {
      "content": "const CACHE_NAME = \"mumblechat-shell-v1\";\nconst APP_SHELL = [\n  \"/\",\n  \"/index.html\",\n  \"/manifest.webmanifest\",\n  \"/favicon.svg\",\n  \"/apple-touch-icon.png\",\n];\n\nself.addEventListener(\"install\", (event) => {\n  event.waitUntil(\n    caches\n      .open(CACHE_NAME)\n      .then((cache) => cache.addAll(APP_SHELL))\n      .then(() => self.skipWaiting()),\n  );\n});\n\nself.addEventListener(\"activate\", (event) => {\n  event.waitUntil(\n    caches\n      .keys()\n      .then((keys) =>\n        Promise.all(\n          keys.map((key) => {\n            if (key !== CACHE_NAME) {\n              return caches.delete(key);\n            }\n            return undefined;\n          }),\n        ),\n      )\n      .then(() => self.clients.claim()),\n  );\n});\n\nself.addEventListener(\"fetch\", (event) => {\n  if (event.request.method !== \"GET\") {\n    return;\n  }\n\n  event.respondWith(\n    caches.match(event.request).then((cachedResponse) => {\n      if (cachedResponse) {\n        return cachedResponse;\n      }\n\n      return fetch(event.request)\n        .then((networkResponse) => {\n          if (\n            !networkResponse ||\n            networkResponse.status !== 200 ||\n            networkResponse.type !== \"basic\"\n          ) {\n            return networkResponse;\n          }\n\n          const responseClone = networkResponse.clone();\n          caches.open(CACHE_NAME).then((cache) => {\n            cache.put(event.request, responseClone).catch(() => {\n              // Ignore cache errors to avoid breaking responses\n            });\n          });\n          return networkResponse;\n        })\n        .catch(() => caches.match(\"/\"));\n    }),\n  );\n});\n",
      "size_bytes": 1624
    },
    "sdks/node-sdk/src/Client.ts": {
      "content": "import {\n  ContentTypeGroupUpdated,\n  GroupUpdatedCodec,\n} from \"@xmtp/content-type-group-updated\";\nimport type {\n  ContentCodec,\n  ContentTypeId,\n  EncodedContent,\n} from \"@xmtp/content-type-primitives\";\nimport { TextCodec } from \"@xmtp/content-type-text\";\nimport {\n  applySignatureRequest,\n  GroupMessageKind,\n  inboxStateFromInboxIds,\n  isAddressAuthorized as isAddressAuthorizedBinding,\n  isInstallationAuthorized as isInstallationAuthorizedBinding,\n  revokeInstallationsSignatureRequest,\n  verifySignedWithPublicKey as verifySignedWithPublicKeyBinding,\n  type Identifier,\n  type Message,\n  type Client as NodeClient,\n  type SignatureRequestHandle,\n} from \"@xmtp/node-bindings\";\nimport { ApiUrls } from \"@/constants\";\nimport { Conversations } from \"@/Conversations\";\nimport { DebugInformation } from \"@/DebugInformation\";\nimport { Preferences } from \"@/Preferences\";\nimport type { ClientOptions, XmtpEnv } from \"@/types\";\nimport { createClient } from \"@/utils/createClient\";\nimport {\n  AccountAlreadyAssociatedError,\n  ClientNotInitializedError,\n  CodecNotFoundError,\n  InboxReassignError,\n  InvalidGroupMembershipChangeError,\n  SignerUnavailableError,\n} from \"@/utils/errors\";\nimport { getInboxIdForIdentifier } from \"@/utils/inboxId\";\nimport { type Signer } from \"@/utils/signer\";\nimport { version } from \"@/utils/version\";\n\nexport type ExtractCodecContentTypes<C extends ContentCodec[] = []> =\n  [...C, GroupUpdatedCodec, TextCodec][number] extends ContentCodec<infer T>\n    ? T\n    : never;\n\n/**\n * Client for interacting with the XMTP network\n */\nexport class Client<ContentTypes = ExtractCodecContentTypes> {\n  #client?: NodeClient;\n  #conversations?: Conversations<ContentTypes>;\n  #debugInformation?: DebugInformation;\n  #preferences?: Preferences;\n  #signer?: Signer;\n  #codecs: Map<string, ContentCodec>;\n  #identifier?: Identifier;\n  #options?: ClientOptions;\n\n  /**\n   * Creates a new XMTP client instance\n   *\n   * This class is not intended to be initialized directly.\n   * Use `Client.create` or `Client.build` instead.\n   *\n   * @param options - Optional configuration for the client\n   */\n  constructor(options?: ClientOptions) {\n    this.#options = options;\n    const codecs = [\n      new GroupUpdatedCodec(),\n      new TextCodec(),\n      ...(options?.codecs ?? []),\n    ];\n    this.#codecs = new Map(\n      codecs.map((codec) => [codec.contentType.toString(), codec]),\n    );\n  }\n\n  /**\n   * Initializes the client with the provided identifier\n   *\n   * This is not meant to be called directly.\n   * Use `Client.create` or `Client.build` instead.\n   *\n   * @param identifier - The identifier to initialize the client with\n   */\n  async init(identifier: Identifier) {\n    if (this.#client) {\n      return;\n    }\n\n    this.#identifier = identifier;\n    this.#client = await createClient(identifier, this.#options);\n    const conversations = this.#client.conversations();\n    this.#conversations = new Conversations(this, conversations);\n    this.#debugInformation = new DebugInformation(this.#client, this.#options);\n    this.#preferences = new Preferences(this.#client, conversations);\n  }\n\n  /**\n   * Creates a new client instance with a signer\n   *\n   * @param signer - The signer to use for authentication\n   * @param options - Optional configuration for the client\n   * @returns A new client instance\n   */\n  static async create<ContentCodecs extends ContentCodec[] = []>(\n    signer: Signer,\n    options?: Omit<ClientOptions, \"codecs\"> & {\n      codecs?: ContentCodecs;\n    },\n  ) {\n    const identifier = await signer.getIdentifier();\n    const client = new Client<ExtractCodecContentTypes<ContentCodecs>>(options);\n    client.#signer = signer;\n    await client.init(identifier);\n\n    if (!options?.disableAutoRegister) {\n      await client.register();\n    }\n\n    return client;\n  }\n\n  /**\n   * Creates a new client instance with an identifier\n   *\n   * Clients created with this method must already be registered.\n   * Any methods called that require a signer will throw an error.\n   *\n   * @param identifier - The identifier to use\n   * @param options - Optional configuration for the client\n   * @returns A new client instance\n   */\n  static async build<ContentCodecs extends ContentCodec[] = []>(\n    identifier: Identifier,\n    options?: Omit<ClientOptions, \"codecs\"> & {\n      codecs?: ContentCodecs;\n    },\n  ) {\n    const client = new Client<ExtractCodecContentTypes<ContentCodecs>>({\n      ...options,\n      disableAutoRegister: true,\n    });\n    await client.init(identifier);\n    return client;\n  }\n\n  /**\n   * Gets the client options\n   */\n  get options() {\n    return this.#options;\n  }\n\n  /**\n   * Gets the signer associated with this client\n   */\n  get signer() {\n    return this.#signer;\n  }\n\n  /**\n   * Gets the account identifier for this client\n   */\n  get accountIdentifier() {\n    return this.#identifier;\n  }\n\n  /**\n   * Gets the inbox ID associated with this client\n   */\n  get inboxId() {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n    return this.#client.inboxId();\n  }\n\n  /**\n   * Gets the installation ID for this client\n   */\n  get installationId() {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n    return this.#client.installationId();\n  }\n\n  /**\n   * Gets the installation ID bytes for this client\n   */\n  get installationIdBytes() {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n    return this.#client.installationIdBytes();\n  }\n\n  /**\n   * Gets whether the client is registered with the XMTP network\n   *\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  get isRegistered() {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n    return this.#client.isRegistered();\n  }\n\n  /**\n   * Gets the conversations manager for this client\n   *\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  get conversations() {\n    if (!this.#conversations) {\n      throw new ClientNotInitializedError();\n    }\n    return this.#conversations;\n  }\n\n  /**\n   * Gets the debug information helpersfor this client\n   *\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  get debugInformation() {\n    if (!this.#debugInformation) {\n      throw new ClientNotInitializedError();\n    }\n    return this.#debugInformation;\n  }\n\n  /**\n   * Gets the preferences manager for this client\n   *\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  get preferences() {\n    if (!this.#preferences) {\n      throw new ClientNotInitializedError();\n    }\n    return this.#preferences;\n  }\n\n  /**\n   * Adds a signature to a signature request using the client's signer (or the\n   * provided signer)\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `register`, `unsafe_addAccount`,\n   * `removeAccount`, `revokeAllOtherInstallations`, or `revokeInstallations`\n   * methods instead.\n   *\n   * @param signatureRequest - The signature request to add the signature to\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   * @throws {SignerUnavailableError} if no signer is available\n   */\n  async unsafe_addSignature(\n    signatureRequest: SignatureRequestHandle,\n    signer?: Signer,\n  ) {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    if (!this.#signer) {\n      throw new SignerUnavailableError();\n    }\n\n    const finalSigner = signer ?? this.#signer;\n    const signature = await finalSigner.signMessage(\n      await signatureRequest.signatureText(),\n    );\n    const identifier = await finalSigner.getIdentifier();\n\n    switch (finalSigner.type) {\n      case \"SCW\":\n        await signatureRequest.addScwSignature(\n          identifier,\n          signature,\n          finalSigner.getChainId(),\n          finalSigner.getBlockNumber?.(),\n        );\n        break;\n      case \"EOA\":\n        await signatureRequest.addEcdsaSignature(signature);\n        break;\n    }\n  }\n\n  /**\n   * Returns a signature request handler for creating a new inbox\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `register` method instead.\n   *\n   * @returns The signature text\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  async unsafe_createInboxSignatureRequest() {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    return this.#client.createInboxSignatureRequest();\n  }\n\n  /**\n   * Returns a signature request handler for adding a new account to the\n   * client's inbox\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `unsafe_addAccount` method instead.\n   *\n   * The `allowInboxReassign` parameter must be true or this function will\n   * throw an error.\n   *\n   * @param newAccountIdentifier - The identifier of the new account\n   * @param allowInboxReassign - Whether to allow inbox reassignment\n   * @returns The signature text\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  async unsafe_addAccountSignatureRequest(\n    newAccountIdentifier: Identifier,\n    allowInboxReassign: boolean = false,\n  ) {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    if (!allowInboxReassign) {\n      throw new InboxReassignError();\n    }\n\n    return this.#client.addIdentifierSignatureRequest(newAccountIdentifier);\n  }\n\n  /**\n   * Returns a signature request handler for removing an account from the\n   * client's inbox\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `removeAccount` method instead.\n   *\n   * @param identifier - The identifier of the account to remove\n   * @returns The signature text\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  async unsafe_removeAccountSignatureRequest(identifier: Identifier) {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    return this.#client.revokeIdentifierSignatureRequest(identifier);\n  }\n\n  /**\n   * Returns a signature request handler for revoking all other installations\n   * of the client's inbox\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `revokeAllOtherInstallations` method instead.\n   *\n   * @returns The signature text\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  async unsafe_revokeAllOtherInstallationsSignatureRequest() {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    return this.#client.revokeAllOtherInstallationsSignatureRequest();\n  }\n\n  /**\n   * Returns a signature request handler for revoking specific installations\n   * of the client's inbox\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `revokeInstallations` method instead.\n   *\n   * @param installationIds - The installation IDs to revoke\n   * @returns The signature text\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  async unsafe_revokeInstallationsSignatureRequest(\n    installationIds: Uint8Array[],\n  ) {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    return this.#client.revokeInstallationsSignatureRequest(installationIds);\n  }\n\n  /**\n   * Returns a signature request handler for changing the recovery identifier\n   * for this client's inbox\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `changeRecoveryIdentifier` method instead.\n   *\n   * @param identifier - The new recovery identifier\n   * @returns The signature text\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  async unsafe_changeRecoveryIdentifierSignatureRequest(\n    identifier: Identifier,\n  ) {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    return this.#client.changeRecoveryIdentifierSignatureRequest(identifier);\n  }\n\n  /**\n   * Applies a signature request to the client\n   *\n   * WARNING: This function should be used with caution. It is only provided\n   * for use in special cases where the provided workflows do not meet the\n   * requirements of an application.\n   *\n   * It is highly recommended to use the `register`, `unsafe_addAccount`,\n   * `removeAccount`, `revokeAllOtherInstallations`, or `revokeInstallations`\n   * methods instead.\n   *\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  async unsafe_applySignatureRequest(signatureRequest: SignatureRequestHandle) {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    return this.#client.applySignatureRequest(signatureRequest);\n  }\n\n  /**\n   * Registers the client with the XMTP network\n   *\n   * Requires a signer, use `Client.create` to create a client with a signer.\n   *\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   * @throws {SignerUnavailableError} if no signer is available\n   */\n  async register() {\n    const signatureRequest = await this.unsafe_createInboxSignatureRequest();\n    if (!signatureRequest) {\n      return;\n    }\n\n    await this.unsafe_addSignature(signatureRequest);\n    await this.#client?.registerIdentity(signatureRequest);\n  }\n\n  /**\n   * Adds a new account to the client inbox\n   *\n   * WARNING: This function should be used with caution. Adding a wallet already\n   * associated with an inbox ID will cause the wallet to lose access to\n   * that inbox.\n   *\n   * The `allowInboxReassign` parameter must be true to reassign an inbox\n   * already associated with a different account.\n   *\n   * Requires a signer, use `Client.create` to create a client with a signer.\n   *\n   * @param newAccountSigner - The signer for the new account\n   * @param allowInboxReassign - Whether to allow inbox reassignment\n   * @throws {AccountAlreadyAssociatedError} if the account is already associated with an inbox ID\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   * @throws {SignerUnavailableError} if no signer is available\n   */\n  async unsafe_addAccount(\n    newAccountSigner: Signer,\n    allowInboxReassign: boolean = false,\n  ) {\n    // check for existing inbox id\n    const identifier = await newAccountSigner.getIdentifier();\n    const existingInboxId = await this.getInboxIdByIdentifier(identifier);\n\n    if (existingInboxId && !allowInboxReassign) {\n      throw new AccountAlreadyAssociatedError(existingInboxId);\n    }\n\n    const signatureRequest = await this.unsafe_addAccountSignatureRequest(\n      identifier,\n      allowInboxReassign,\n    );\n\n    await this.unsafe_addSignature(signatureRequest, newAccountSigner);\n    await this.unsafe_applySignatureRequest(signatureRequest);\n  }\n\n  /**\n   * Removes an account from the client's inbox\n   *\n   * Requires a signer, use `Client.create` to create a client with a signer.\n   *\n   * @param identifier - The identifier of the account to remove\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   * @throws {SignerUnavailableError} if no signer is available\n   */\n  async removeAccount(identifier: Identifier) {\n    const signatureRequest =\n      await this.unsafe_removeAccountSignatureRequest(identifier);\n\n    await this.unsafe_addSignature(signatureRequest);\n    await this.unsafe_applySignatureRequest(signatureRequest);\n  }\n\n  /**\n   * Revokes all other installations of the client's inbox\n   *\n   * Requires a signer, use `Client.create` to create a client with a signer.\n   *\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   * @throws {SignerUnavailableError} if no signer is available\n   */\n  async revokeAllOtherInstallations() {\n    const signatureRequest =\n      await this.unsafe_revokeAllOtherInstallationsSignatureRequest();\n\n    await this.unsafe_addSignature(signatureRequest);\n    await this.unsafe_applySignatureRequest(signatureRequest);\n  }\n\n  /**\n   * Revokes specific installations of the client's inbox\n   *\n   * Requires a signer, use `Client.create` to create a client with a signer.\n   *\n   * @param installationIds - The installation IDs to revoke\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   * @throws {SignerUnavailableError} if no signer is available\n   */\n  async revokeInstallations(installationIds: Uint8Array[]) {\n    const signatureRequest =\n      await this.unsafe_revokeInstallationsSignatureRequest(installationIds);\n\n    await this.unsafe_addSignature(signatureRequest);\n    await this.unsafe_applySignatureRequest(signatureRequest);\n  }\n\n  /**\n   * Revokes specific installations of the client's inbox without a client\n   *\n   * @param env - The environment to use\n   * @param signer - The signer to use\n   * @param inboxId - The inbox ID to revoke installations for\n   * @param installationIds - The installation IDs to revoke\n   */\n  static async revokeInstallations(\n    signer: Signer,\n    inboxId: string,\n    installationIds: Uint8Array[],\n    env?: XmtpEnv,\n  ) {\n    const host = ApiUrls[env ?? \"dev\"];\n    const identifier = await signer.getIdentifier();\n    const signatureRequest = await revokeInstallationsSignatureRequest(\n      host,\n      identifier,\n      inboxId,\n      installationIds,\n    );\n    const signatureText = await signatureRequest.signatureText();\n    const signature = await signer.signMessage(signatureText);\n\n    switch (signer.type) {\n      case \"SCW\":\n        await signatureRequest.addScwSignature(\n          identifier,\n          signature,\n          signer.getChainId(),\n          signer.getBlockNumber?.(),\n        );\n        break;\n      case \"EOA\":\n        await signatureRequest.addEcdsaSignature(signature);\n        break;\n    }\n\n    await applySignatureRequest(host, signatureRequest);\n  }\n\n  /**\n   * Gets the inbox state for the specified inbox IDs without a client\n   *\n   * @param env - The environment to use\n   * @param inboxIds - The inbox IDs to get the state for\n   * @returns The inbox state for the specified inbox IDs\n   */\n  static async inboxStateFromInboxIds(inboxIds: string[], env?: XmtpEnv) {\n    const host = ApiUrls[env ?? \"dev\"];\n    return inboxStateFromInboxIds(host, inboxIds);\n  }\n\n  /**\n   * Changes the recovery identifier for the client's inbox\n   *\n   * Requires a signer, use `Client.create` to create a client with a signer.\n   *\n   * @param identifier - The new recovery identifier\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   * @throws {SignerUnavailableError} if no signer is available\n   */\n  async changeRecoveryIdentifier(identifier: Identifier) {\n    const signatureRequest =\n      await this.unsafe_changeRecoveryIdentifierSignatureRequest(identifier);\n\n    await this.unsafe_addSignature(signatureRequest);\n    await this.unsafe_applySignatureRequest(signatureRequest);\n  }\n\n  /**\n   * Checks if the client can message the specified identifiers\n   *\n   * @param identifiers - The identifiers to check\n   * @returns Whether the client can message the identifiers\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  async canMessage(identifiers: Identifier[]) {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    const canMessage = await this.#client.canMessage(identifiers);\n    return new Map(Object.entries(canMessage));\n  }\n\n  /**\n   * Checks if the specified identifiers can be messaged\n   *\n   * @param identifiers - The identifiers to check\n   * @param env - Optional XMTP environment\n   * @returns Map of identifiers to whether they can be messaged\n   */\n  static async canMessage(identifiers: Identifier[], env?: XmtpEnv) {\n    const canMessageMap = new Map<string, boolean>();\n    for (const identifier of identifiers) {\n      const inboxId = await getInboxIdForIdentifier(identifier, env);\n      canMessageMap.set(identifier.identifier.toLowerCase(), inboxId !== null);\n    }\n    return canMessageMap;\n  }\n\n  /**\n   * Gets the key package statuses for the specified installation IDs\n   *\n   * @param installationIds - The installation IDs to check\n   * @returns The key package statuses\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  async getKeyPackageStatusesForInstallationIds(installationIds: string[]) {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    return this.#client.getKeyPackageStatusesForInstallationIds(\n      installationIds,\n    );\n  }\n\n  /**\n   * Gets the codec for a given content type\n   *\n   * @param contentType - The content type to get the codec for\n   * @returns The codec, if found\n   */\n  codecFor<ContentType = unknown>(contentType: ContentTypeId) {\n    return this.#codecs.get(contentType.toString()) as\n      | ContentCodec<ContentType>\n      | undefined;\n  }\n\n  /**\n   * Encodes content for a given content type\n   *\n   * @param content - The content to encode\n   * @param contentType - The content type to encode for\n   * @returns The encoded content\n   * @throws {CodecNotFoundError} if no codec is found for the content type\n   */\n  encodeContent(content: ContentTypes, contentType: ContentTypeId) {\n    const codec = this.codecFor(contentType);\n    if (!codec) {\n      throw new CodecNotFoundError(contentType);\n    }\n    const encoded = codec.encode(content, this);\n    const fallback = codec.fallback(content);\n    if (fallback) {\n      encoded.fallback = fallback;\n    }\n    return encoded;\n  }\n\n  /**\n   * Decodes a message for a given content type\n   *\n   * @param message - The message to decode\n   * @param contentType - The content type to decode for\n   * @returns The decoded content\n   * @throws {CodecNotFoundError} if no codec is found for the content type\n   * @throws {InvalidGroupMembershipChangeError} if the message is an invalid group membership change\n   */\n  decodeContent<ContentType = unknown>(\n    message: Message,\n    contentType: ContentTypeId,\n  ) {\n    const codec = this.codecFor<ContentType>(contentType);\n    if (!codec) {\n      throw new CodecNotFoundError(contentType);\n    }\n\n    // throw an error if there's an invalid group membership change message\n    if (\n      contentType.sameAs(ContentTypeGroupUpdated) &&\n      message.kind !== GroupMessageKind.MembershipChange\n    ) {\n      throw new InvalidGroupMembershipChangeError(message.id);\n    }\n\n    return codec.decode(message.content as EncodedContent, this);\n  }\n\n  /**\n   * Finds the inbox ID for a given identifier\n   *\n   * @param identifier - The identifier to look up\n   * @returns The inbox ID, if found\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  async getInboxIdByIdentifier(identifier: Identifier) {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    return this.#client.findInboxIdByIdentifier(identifier);\n  }\n\n  /**\n   * Signs a message with the installation key\n   *\n   * @param signatureText - The text to sign\n   * @returns The signature\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  signWithInstallationKey(signatureText: string) {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    return this.#client.signWithInstallationKey(signatureText);\n  }\n\n  /**\n   * Verifies a signature was made with the installation key\n   *\n   * @param signatureText - The text that was signed\n   * @param signatureBytes - The signature bytes to verify\n   * @returns Whether the signature is valid\n   * @throws {ClientNotInitializedError} if the client is not initialized\n   */\n  verifySignedWithInstallationKey(\n    signatureText: string,\n    signatureBytes: Uint8Array,\n  ) {\n    if (!this.#client) {\n      throw new ClientNotInitializedError();\n    }\n\n    try {\n      this.#client.verifySignedWithInstallationKey(\n        signatureText,\n        signatureBytes,\n      );\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Verifies a signature was made with a public key\n   *\n   * @param signatureText - The text that was signed\n   * @param signatureBytes - The signature bytes to verify\n   * @param publicKey - The public key to verify against\n   * @returns Whether the signature is valid\n   */\n  static verifySignedWithPublicKey(\n    signatureText: string,\n    signatureBytes: Uint8Array,\n    publicKey: Uint8Array,\n  ) {\n    try {\n      verifySignedWithPublicKeyBinding(\n        signatureText,\n        signatureBytes,\n        publicKey,\n      );\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Checks if an address is authorized for an inbox\n   *\n   * @param inboxId - The inbox ID to check\n   * @param address - The address to check\n   * @param options - Optional network options\n   * @returns Whether the address is authorized\n   */\n  static async isAddressAuthorized(\n    inboxId: string,\n    address: string,\n    env?: XmtpEnv,\n  ): Promise<boolean> {\n    const host = ApiUrls[env ?? \"dev\"];\n    return await isAddressAuthorizedBinding(host, inboxId, address);\n  }\n\n  /**\n   * Checks if an installation is authorized for an inbox\n   *\n   * @param inboxId - The inbox ID to check\n   * @param installation - The installation to check\n   * @param options - Optional network options\n   * @returns Whether the installation is authorized\n   */\n  static async isInstallationAuthorized(\n    inboxId: string,\n    installation: Uint8Array,\n    env?: XmtpEnv,\n  ): Promise<boolean> {\n    const host = ApiUrls[env ?? \"dev\"];\n    return await isInstallationAuthorizedBinding(host, inboxId, installation);\n  }\n\n  /**\n   * Gets the version of the Node bindings\n   */\n  static get version() {\n    return version;\n  }\n}\n",
      "size_bytes": 26686
    },
    "sdks/node-sdk/src/Conversation.ts": {
      "content": "import type { ContentTypeId } from \"@xmtp/content-type-primitives\";\nimport { ContentTypeText } from \"@xmtp/content-type-text\";\nimport {\n  SortDirection,\n  type ConsentState,\n  type ListMessagesOptions,\n  type Message,\n  type Conversation as XmtpConversation,\n} from \"@xmtp/node-bindings\";\nimport type { Client } from \"@/Client\";\nimport { DecodedMessage } from \"@/DecodedMessage\";\nimport { nsToDate } from \"@/utils/date\";\nimport { MissingContentTypeError } from \"@/utils/errors\";\nimport {\n  createStream,\n  type StreamCallback,\n  type StreamOptions,\n} from \"@/utils/streams\";\n\n/**\n * Represents a conversation\n *\n * This class is not intended to be initialized directly.\n */\nexport class Conversation<ContentTypes = unknown> {\n  #client: Client<ContentTypes>;\n  #conversation: XmtpConversation;\n  #isCommitLogForked: boolean | null = null;\n\n  /**\n   * Creates a new conversation instance\n   *\n   * @param client - The client instance managing the conversation\n   * @param conversation - The underlying conversation instance\n   * @param isCommitLogForked\n   */\n  constructor(\n    client: Client<ContentTypes>,\n    conversation: XmtpConversation,\n    isCommitLogForked?: boolean | null,\n  ) {\n    this.#client = client;\n    this.#conversation = conversation;\n    this.#isCommitLogForked = isCommitLogForked ?? null;\n  }\n\n  /**\n   * Gets the unique identifier for this conversation\n   */\n  get id() {\n    return this.#conversation.id();\n  }\n\n  /**\n   * Gets whether this conversation is currently active\n   */\n  get isActive() {\n    return this.#conversation.isActive();\n  }\n\n  get isCommitLogForked() {\n    return this.#isCommitLogForked;\n  }\n\n  /**\n   * Gets the inbox ID that added this client's inbox to the conversation\n   */\n  get addedByInboxId() {\n    return this.#conversation.addedByInboxId();\n  }\n\n  /**\n   * Gets the timestamp when the conversation was created in nanoseconds\n   */\n  get createdAtNs() {\n    return this.#conversation.createdAtNs();\n  }\n\n  /**\n   * Gets the date when the conversation was created\n   */\n  get createdAt() {\n    return nsToDate(this.createdAtNs);\n  }\n\n  /**\n   * Gets the metadata for this conversation\n   *\n   * @returns Promise that resolves with the conversation metadata\n   */\n  async metadata() {\n    const metadata = await this.#conversation.groupMetadata();\n    return {\n      creatorInboxId: metadata.creatorInboxId(),\n      conversationType: metadata.conversationType(),\n    };\n  }\n\n  /**\n   * Gets the members of this conversation\n   *\n   * @returns Promise that resolves with the conversation members\n   */\n  async members() {\n    return this.#conversation.listMembers();\n  }\n\n  /**\n   * Synchronizes conversation data from the network\n   *\n   * @returns Promise that resolves when synchronization is complete\n   */\n  async sync() {\n    return this.#conversation.sync();\n  }\n\n  /**\n   * Creates a stream for new messages in this conversation\n   *\n   * @param options - Optional stream options\n   * @returns Stream instance for new messages\n   */\n  async stream(options?: StreamOptions<Message, DecodedMessage<ContentTypes>>) {\n    const stream = async (\n      callback: StreamCallback<Message>,\n      onFail: () => void,\n    ) => {\n      await this.sync();\n      return this.#conversation.stream(callback, onFail);\n    };\n    const convertMessage = (value: Message) => {\n      return new DecodedMessage(this.#client, value);\n    };\n\n    return createStream(stream, convertMessage, options);\n  }\n\n  /**\n   * Publishes pending messages that were sent optimistically\n   *\n   * @returns Promise that resolves when publishing is complete\n   */\n  async publishMessages() {\n    return this.#conversation.publishMessages();\n  }\n\n  /**\n   * Prepares a message to be published\n   *\n   * @param content - The content to send\n   * @param contentType - Optional content type of the message content\n   * @returns Promise that resolves with the message ID\n   * @throws {MissingContentTypeError} if content type is required but not provided\n   */\n  sendOptimistic(content: ContentTypes, contentType?: ContentTypeId) {\n    if (typeof content !== \"string\" && !contentType) {\n      throw new MissingContentTypeError();\n    }\n\n    const encodedContent =\n      typeof content === \"string\"\n        ? this.#client.encodeContent(content, contentType ?? ContentTypeText)\n        : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this.#client.encodeContent(content, contentType!);\n\n    return this.#conversation.sendOptimistic(encodedContent);\n  }\n\n  /**\n   * Publishes a new message\n   *\n   * @param content - The content to send\n   * @param contentType - Optional content type of the message content\n   * @returns Promise that resolves with the message ID after it has been sent\n   * @throws {MissingContentTypeError} if content type is required but not provided\n   */\n  async send(content: ContentTypes, contentType?: ContentTypeId) {\n    if (typeof content !== \"string\" && !contentType) {\n      throw new MissingContentTypeError();\n    }\n\n    const encodedContent =\n      typeof content === \"string\"\n        ? this.#client.encodeContent(content, contentType ?? ContentTypeText)\n        : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this.#client.encodeContent(content, contentType!);\n\n    return this.#conversation.send(encodedContent);\n  }\n\n  /**\n   * Lists messages in this conversation\n   *\n   * @param options - Optional filtering and pagination options\n   * @returns Promise that resolves with an array of decoded messages\n   */\n  async messages(options?: ListMessagesOptions) {\n    const messages = await this.#conversation.findMessages(options);\n    return messages.map((message) => new DecodedMessage(this.#client, message));\n  }\n\n  /**\n   * Gets the last message in this conversation\n   *\n   * @returns Promise that resolves with the last message or undefined if none exists\n   */\n  async lastMessage() {\n    const messages = await this.messages({\n      limit: 1,\n      direction: SortDirection.Descending,\n    });\n    if (messages.length > 0) {\n      return messages[0];\n    }\n    return undefined;\n  }\n\n  /**\n   * Gets the consent state for this conversation\n   */\n  get consentState() {\n    return this.#conversation.consentState();\n  }\n\n  /**\n   * Updates the consent state for this conversation\n   *\n   * @param consentState - The new consent state to set\n   */\n  updateConsentState(consentState: ConsentState) {\n    this.#conversation.updateConsentState(consentState);\n  }\n\n  /**\n   * Gets the message disappearing settings for this conversation\n   *\n   * @returns The current message disappearing settings or undefined if not set\n   */\n  messageDisappearingSettings() {\n    return this.#conversation.messageDisappearingSettings() ?? undefined;\n  }\n\n  /**\n   * Updates message disappearing settings for this conversation\n   *\n   * @param fromNs - The timestamp from which messages should start disappearing\n   * @param inNs - The duration after which messages should disappear\n   * @returns Promise that resolves when the update is complete\n   */\n  async updateMessageDisappearingSettings(fromNs: number, inNs: number) {\n    return this.#conversation.updateMessageDisappearingSettings({\n      fromNs,\n      inNs,\n    });\n  }\n\n  /**\n   * Removes message disappearing settings from this conversation\n   *\n   * @returns Promise that resolves when the settings are removed\n   */\n  async removeMessageDisappearingSettings() {\n    return this.#conversation.removeMessageDisappearingSettings();\n  }\n\n  /**\n   * Checks if message disappearing is enabled for this conversation\n   *\n   * @returns Whether message disappearing is enabled\n   */\n  isMessageDisappearingEnabled() {\n    return this.#conversation.isMessageDisappearingEnabled();\n  }\n\n  pausedForVersion() {\n    return this.#conversation.pausedForVersion() ?? undefined;\n  }\n\n  /**\n   * Retrieves HMAC keys for this conversation\n   *\n   * @returns The HMAC keys for this conversation\n   */\n  getHmacKeys() {\n    return this.#conversation.getHmacKeys();\n  }\n\n  /**\n   * Retrieves information for this conversation to help with debugging\n   *\n   * @returns The debug information for this conversation\n   */\n  async debugInfo() {\n    return this.#conversation.debugInfo();\n  }\n}\n",
      "size_bytes": 8234
    },
    "apps/xmtp.chat-api-service/src/api/v2/index.ts": {
      "content": "import { Router } from \"express\";\nimport resolveRouter from \"./resolve.router.js\";\n\nconst v2Router = Router();\n\nv2Router.use(\"/resolve\", resolveRouter);\n\nexport default v2Router;\n",
      "size_bytes": 179
    },
    "apps/xmtp.chat/vite.config.ts": {
      "content": "import react from \"@vitejs/plugin-react\";\nimport { defineConfig } from \"vite\";\nimport tsconfigPaths from \"vite-tsconfig-paths\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [tsconfigPaths(), react()],\n  optimizeDeps: {\n    exclude: [\"@xmtp/wasm-bindings\"],\n  },\n  server: {\n    port: 5173, // 👈 set your custom port here\n    open: true, // optional: auto-open browser\n  },\n});\n",
      "size_bytes": 407
    },
    "apps/xmtp.chat-api-service/src/helpers/prisma.ts": {
      "content": "import { PrismaClient } from \"@prisma/client\";\n\nexport const prisma = new PrismaClient();\n",
      "size_bytes": 90
    },
    "apps/xmtp.chat-api-service/rollup.config.js": {
      "content": "import json from \"@rollup/plugin-json\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { defineConfig } from \"rollup\";\nimport tsConfigPaths from \"rollup-plugin-tsconfig-paths\";\n\nconst external = [\n  \"cors\",\n  \"express\",\n  \"helmet\",\n  \"express-rate-limit\",\n  \"pinata\",\n  \"web3bio-profile-kit/types\",\n  \"web3bio-profile-kit/utils\",\n  \"zod\",\n  \"date-fns\",\n  \"@prisma/client\",\n  \"node:querystring\",\n];\n\nconst plugins = [\n  tsConfigPaths(),\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n  json({\n    preferConst: true,\n  }),\n];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: false,\n      importAttributesKey: \"with\",\n    },\n    plugins,\n    external,\n  },\n]);\n",
      "size_bytes": 788
    },
    "apps/xmtp.chat/src/hooks/useAnalytics.ts": {
      "content": "import Plausible from \"plausible-tracker\";\nimport { useEffect } from \"react\";\n\nexport const useAnalytics = () => {\n  useEffect(() => {\n    const plausible = Plausible({\n      domain: \"xmtp.chat\",\n    });\n    const cleanupAutoPageviews = plausible.enableAutoPageviews();\n    return () => {\n      cleanupAutoPageviews();\n    };\n  }, []);\n};\n",
      "size_bytes": 339
    },
    "apps/xmtp.chat/src/components/App/BasicLayout.tsx": {
      "content": "import { Outlet } from \"react-router\";\nimport { CenteredLayout } from \"@/layouts/CenteredLayout\";\n\nexport const BasicLayout: React.FC = () => {\n  return (\n    <CenteredLayout>\n      <Outlet />\n    </CenteredLayout>\n  );\n};\n",
      "size_bytes": 223
    },
    "apps/xmtp.chat/src/components/Messages/MessageContentWrapper.tsx": {
      "content": "import { Flex, Group, Stack } from \"@mantine/core\";\nimport { Dm } from \"@xmtp/browser-sdk\";\nimport { useMemo } from \"react\";\nimport { DateLabel } from \"@/components/DateLabel\";\nimport { Identity } from \"@/components/Identity\";\nimport { useConversationContext } from \"@/contexts/ConversationContext\";\nimport { nsToDate } from \"@/helpers/date\";\nimport { getMemberAddress } from \"@/helpers/xmtp\";\nimport { useConversation } from \"@/hooks/useConversation\";\nimport { combineProfiles, useAllProfiles } from \"@/stores/profiles\";\n\nexport type MessageContentAlign = \"left\" | \"right\";\n\nexport type MessageContentWrapperProps = React.PropsWithChildren<{\n  align: MessageContentAlign;\n  senderInboxId: string;\n  sentAtNs: bigint;\n  stopClickPropagation?: boolean;\n}>;\n\nexport const MessageContentWrapper: React.FC<MessageContentWrapperProps> = ({\n  align,\n  senderInboxId,\n  children,\n  sentAtNs,\n  stopClickPropagation = true,\n}) => {\n  const { conversationId } = useConversationContext();\n  const { members, conversation } = useConversation(conversationId);\n  const profiles = useAllProfiles();\n  const senderMember = members.get(senderInboxId);\n  const senderProfile = useMemo(() => {\n    const address = senderMember ? getMemberAddress(senderMember) : \"\";\n    return combineProfiles(address, profiles.get(address) ?? []);\n  }, [profiles, senderMember]);\n  return (\n    <Group justify={align === \"left\" ? \"flex-start\" : \"flex-end\"}>\n      <Stack gap=\"xs\" align={align === \"left\" ? \"flex-start\" : \"flex-end\"}>\n        <Flex\n          gap=\"xs\"\n          direction={align === \"right\" ? \"row\" : \"row-reverse\"}\n          align=\"center\">\n          <DateLabel date={nsToDate(sentAtNs)} />\n          {senderMember && (\n            <Identity\n              address={senderProfile.address}\n              avatar={senderProfile.avatar}\n              permissionLevel={senderMember.permissionLevel}\n              conversationId={conversationId}\n              description={senderProfile.description}\n              displayName={senderProfile.displayName}\n              inboxId={senderMember.inboxId}\n              showDm={!(conversation instanceof Dm)}\n              position=\"top\"\n            />\n          )}\n        </Flex>\n        <Group\n          justify={align === \"left\" ? \"flex-start\" : \"flex-end\"}\n          maw=\"80%\"\n          onClick={(event) => {\n            if (stopClickPropagation) {\n              event.stopPropagation();\n            }\n          }}>\n          {children}\n        </Group>\n      </Stack>\n    </Group>\n  );\n};\n",
      "size_bytes": 2513
    },
    "content-types/content-type-text/src/Text.ts": {
      "content": "import {\n  ContentTypeId,\n  type ContentCodec,\n  type EncodedContent,\n} from \"@xmtp/content-type-primitives\";\n\nexport const ContentTypeText = new ContentTypeId({\n  authorityId: \"xmtp.org\",\n  typeId: \"text\",\n  versionMajor: 1,\n  versionMinor: 0,\n});\n\nexport enum Encoding {\n  utf8 = \"UTF-8\",\n  unknown = \"unknown\",\n}\n\nexport type TextParameters = {\n  encoding: Encoding;\n};\n\nexport class TextCodec implements ContentCodec<string, TextParameters> {\n  get contentType(): ContentTypeId {\n    return ContentTypeText;\n  }\n\n  encode(content: string) {\n    return {\n      type: ContentTypeText,\n      parameters: { encoding: Encoding.utf8 },\n      content: new TextEncoder().encode(content),\n    };\n  }\n\n  decode(content: EncodedContent<TextParameters>) {\n    if (content.parameters.encoding !== Encoding.utf8) {\n      throw new Error(`unrecognized encoding ${content.parameters.encoding}`);\n    }\n    return new TextDecoder().decode(content.content);\n  }\n\n  fallback() {\n    return undefined;\n  }\n\n  shouldPush() {\n    return true;\n  }\n}\n",
      "size_bytes": 1031
    },
    "apps/xmtp.chat/src/helpers/messages.test.ts": {
      "content": "import { ContentTypeId } from \"@xmtp/content-type-primitives\";\nimport {\n  ContentTypeReaction,\n  type Reaction,\n} from \"@xmtp/content-type-reaction\";\nimport { ContentTypeReply, type Reply } from \"@xmtp/content-type-reply\";\nimport { ContentTypeText } from \"@xmtp/content-type-text\";\nimport { describe, expect, it } from \"vitest\";\nimport { stringify } from \"./messages\";\n\nconst wrapInReply = (content: Reply | string, depth = 1): Reply => {\n  if (depth < 1) throw new Error(\"Depth must be at least 1.\");\n  let current: Reply | string = content;\n  for (let i = 0; i < depth; i++) {\n    const wrapped: Reply = {\n      reference: \"id\",\n      referenceInboxId: \"inbox\",\n      content: current,\n      contentType:\n        typeof current === \"string\" ? ContentTypeText : ContentTypeReply,\n    };\n    current = wrapped;\n  }\n  return current as Reply;\n};\n\ndescribe(\"stringify\", () => {\n  it(\"returns plain text for ContentTypeText\", () => {\n    const content = \"Hello, World!\";\n    expect(\n      stringify({\n        content,\n        contentType: ContentTypeText,\n        fallback: \"fallback\",\n      }),\n    ).toBe(content);\n  });\n\n  it(\"returns plain text for ContentTypeReply\", () => {\n    const content: Reply = {\n      reference: \"id\",\n      referenceInboxId: \"inbox\",\n      content: \"hi\",\n      contentType: ContentTypeText,\n    };\n    expect(\n      stringify({\n        content,\n        contentType: ContentTypeReply,\n        fallback: \"fallback\",\n      }),\n    ).toBe(content.content);\n  });\n\n  it(\"returns fallback text for a wrapped reply\", () => {\n    const content: Reply = {\n      reference: \"id\",\n      referenceInboxId: \"inbox\",\n      content: \"hi\",\n      contentType: ContentTypeText,\n    };\n\n    const wrappedReply = wrapInReply(content, 5);\n    const fallback = \"fallback\";\n\n    expect(\n      stringify({\n        content: wrappedReply,\n        contentType: ContentTypeReply,\n        fallback,\n      }),\n    ).toBe(fallback);\n  });\n\n  it(\"returns plain text for ContentTypeReaction\", () => {\n    const content: Reaction = {\n      action: \"added\",\n      reference: \"id\",\n      referenceInboxId: \"inbox\",\n      content: \"👍\",\n      schema: \"unicode\",\n    };\n    expect(\n      stringify({\n        content,\n        contentType: ContentTypeReaction,\n        fallback: \"fallback\",\n      }),\n    ).toBe(content.content);\n  });\n\n  it(\"returns fallback text when the content type is unknown\", () => {\n    const fallback = \"fallback\";\n    expect(\n      stringify({\n        content: {},\n        contentType: new ContentTypeId({\n          authorityId: \"test\",\n          typeId: \"unknown.content.type\",\n          versionMajor: 3,\n          versionMinor: 0,\n        }),\n        fallback,\n      }),\n    ).toBe(fallback);\n  });\n});\n",
      "size_bytes": 2722
    },
    "content-types/content-type-reaction/rollup.config.js": {
      "content": "import terser from \"@rollup/plugin-terser\";\nimport typescript from \"@rollup/plugin-typescript\";\nimport { defineConfig } from \"rollup\";\nimport { dts } from \"rollup-plugin-dts\";\n\nconst plugins = [\n  typescript({\n    declaration: false,\n    declarationMap: false,\n  }),\n];\n\nconst external = [\"@xmtp/content-type-primitives\"];\n\nexport default defineConfig([\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins,\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/browser/index.js\",\n      format: \"es\",\n      sourcemap: true,\n    },\n    plugins: [...plugins, terser()],\n    external,\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      file: \"dist/index.d.ts\",\n      format: \"es\",\n    },\n    plugins: [dts()],\n  },\n]);\n",
      "size_bytes": 832
    },
    "content-types/content-type-reply/CHANGELOG.md": {
      "content": "# @xmtp/content-type-reply\n\n## 2.0.2\n\n### Patch Changes\n\n- Updated dependencies [779fd0c]\n  - @xmtp/content-type-primitives@2.0.2\n\n## 2.0.1\n\n### Patch Changes\n\n- Updated dependencies [340fcf4]\n  - @xmtp/content-type-primitives@2.0.1\n  - @xmtp/proto@3.78.0\n\n## 2.0.0\n\n### Major Changes\n\n- 1777a23: Dropped support for CommonJS\n\n### Patch Changes\n\n- Updated dependencies [1777a23]\n  - @xmtp/content-type-primitives@2.0.0\n\n## 1.1.12\n\n### Patch Changes\n\n- Updated dependencies [63e5276]\n  - @xmtp/content-type-primitives@1.0.3\n\n## 1.1.11\n\n### Patch Changes\n\n- [#75](https://github.com/xmtp/xmtp-js-content-types/pull/75) [`da0bd85`](https://github.com/xmtp/xmtp-js-content-types/commit/da0bd8578d5f5032b221e25f02e8492b27929d6c)\n  - Use primitives package for types\n\n## 1.1.10\n\n### Patch Changes\n\n- [#68](https://github.com/xmtp/xmtp-js-content-types/pull/68) [`8896b33`](https://github.com/xmtp/xmtp-js-content-types/commit/8896b33501b2860d68ea8be5e33a9cca5dd9315c)\n  - Add optional referenceInboxId\n\n## 1.1.9\n\n### Patch Changes\n\n- [#65](https://github.com/xmtp/xmtp-js-content-types/pull/65) [`c4d43dc`](https://github.com/xmtp/xmtp-js-content-types/commit/c4d43dc948231de5c7f730e06f0931076de0673b)\n  - Add `shouldPush` to all content codecs\n\n## 1.1.8\n\n### Patch Changes\n\n- [#60](https://github.com/xmtp/xmtp-js-content-types/pull/60) [`5b9310a`](https://github.com/xmtp/xmtp-js-content-types/commit/5b9310ac89fd23e5cfd74903894073b6ef8af7c3)\n  - Upgraded JS SDK to `11.3.12`\n\n## 1.1.7\n\n### Patch Changes\n\n- [#54](https://github.com/xmtp/xmtp-js-content-types/pull/54) [`718cb9f`](https://github.com/xmtp/xmtp-js-content-types/commit/718cb9fec51f74bf2402f3f22160687cae35dda8)\n  - Updated Turbo config to remove `generate:types` command and instead rely on `build`\n  - Removed all `generate:types` commands from `package.json` files\n  - Updated shared ESLint config and local ESLint configs\n  - Updated `include` field of `tsconfig.json` and `tsconfig.eslint.json` files\n  - Replaced `tsup` with `rollup`\n\n## 1.1.6\n\n### Patch Changes\n\n- [#51](https://github.com/xmtp/xmtp-js-content-types/pull/51) [`aeb6db7`](https://github.com/xmtp/xmtp-js-content-types/commit/aeb6db73a63409a33c7d3d3431e33682b0ce4c4d)\n  - Only publish files in the `/dist` directory\n\n## 1.1.5\n\n### Patch Changes\n\n- Upgraded `@xmtp/proto` package\n- Upgraded `@xmtp/xmtp-js` package\n\n## 1.1.4\n\n### Patch Changes\n\n- Update `@xmtp/proto` to latest version\n\n## 1.1.3\n\n### Patch Changes\n\n- Upgrade to JS SDK v11\n- Update client initialization for tests to use `codecs` option for proper types\n\n## 1.1.2\n\n### Patch Changes\n\n- fix: update the copy for the default fallbacks\n\n## 1.1.1\n\n### Patch Changes\n\n- Gets the nested type of a reply from the deserialized EncodedContent instead of inspecting the parameter map\n\n## 1.1.0\n\n### Minor Changes\n\n- Add dummy fallback field to all content types\n",
      "size_bytes": 2850
    },
    "apps/xmtp.chat/src/hooks/useCollapsedMediaQuery.ts": {
      "content": "import { useMediaQuery } from \"@mantine/hooks\";\n\nexport const useCollapsedMediaQuery = () => {\n  return useMediaQuery(\"(max-width: 1080px)\");\n};\n",
      "size_bytes": 145
    },
    "sdks/node-sdk/test/Conversations.test.ts": {
      "content": "import { ConsentState, GroupPermissionsOptions } from \"@xmtp/node-bindings\";\nimport { v4 } from \"uuid\";\nimport { describe, expect, it } from \"vitest\";\nimport {\n  createRegisteredClient,\n  createSigner,\n  createUser,\n  sleep,\n} from \"@test/helpers\";\n\ndescribe(\"Conversations\", () => {\n  it(\"should not have initial conversations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n\n    expect((await client.conversations.list()).length).toBe(0);\n    expect(client.conversations.listDms().length).toBe(0);\n    expect(client.conversations.listGroups().length).toBe(0);\n  });\n\n  it(\"should create a group\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId,\n    ]);\n    expect(conversation).toBeDefined();\n    expect(\n      (await client1.conversations.getConversationById(conversation.id))?.id,\n    ).toBe(conversation.id);\n    expect(conversation.id).toBeDefined();\n    expect(conversation.createdAt).toBeDefined();\n    expect(conversation.createdAtNs).toBeDefined();\n    expect(conversation.isActive).toBe(true);\n    expect(conversation.isCommitLogForked).toBe(null);\n    expect(conversation.name).toBe(\"\");\n    expect(conversation.permissions.policyType).toBe(\n      GroupPermissionsOptions.Default,\n    );\n    expect(conversation.permissions.policySet).toEqual({\n      addMemberPolicy: 0,\n      removeMemberPolicy: 2,\n      addAdminPolicy: 3,\n      removeAdminPolicy: 3,\n      updateGroupNamePolicy: 0,\n      updateGroupDescriptionPolicy: 0,\n      updateGroupImageUrlSquarePolicy: 0,\n      updateMessageDisappearingPolicy: 2,\n    });\n    expect(conversation.addedByInboxId).toBe(client1.inboxId);\n    expect((await conversation.messages()).length).toBe(1);\n\n    const members = await conversation.members();\n    expect(members.length).toBe(2);\n    const memberInboxIds = members.map((member) => member.inboxId);\n    expect(memberInboxIds).toContain(client1.inboxId);\n    expect(memberInboxIds).toContain(client2.inboxId);\n    expect(await conversation.metadata()).toEqual({\n      conversationType: \"group\",\n      creatorInboxId: client1.inboxId,\n    });\n\n    const conversations1 = client1.conversations.listGroups();\n    expect(conversations1.length).toBe(1);\n    expect(conversations1[0].id).toBe(conversation.id);\n\n    expect(client2.conversations.listGroups().length).toBe(0);\n\n    await client2.conversations.sync();\n\n    const conversations2 = client2.conversations.listGroups();\n    expect(conversations2.length).toBe(1);\n    expect(conversations2[0].id).toBe(conversation.id);\n\n    expect(client2.conversations.listDms().length).toBe(0);\n    expect(client2.conversations.listGroups().length).toBe(1);\n\n    const conversation2 = await client1.conversations.newGroup([\n      client3.inboxId,\n    ]);\n    expect(conversation2).toBeDefined();\n    expect(conversation2.id).toBeDefined();\n    expect(conversation2.createdAt).toBeDefined();\n    expect(conversation2.createdAtNs).toBeDefined();\n    expect(conversation2.isActive).toBe(true);\n    expect(conversation2.name).toBe(\"\");\n    expect(conversation2.permissions.policyType).toBe(\n      GroupPermissionsOptions.Default,\n    );\n    expect(conversation2.permissions.policySet).toEqual({\n      addMemberPolicy: 0,\n      removeMemberPolicy: 2,\n      addAdminPolicy: 3,\n      removeAdminPolicy: 3,\n      updateGroupNamePolicy: 0,\n      updateGroupDescriptionPolicy: 0,\n      updateGroupImageUrlSquarePolicy: 0,\n      updateMessageDisappearingPolicy: 2,\n    });\n    expect(conversation2.addedByInboxId).toBe(client1.inboxId);\n    expect((await conversation2.messages()).length).toBe(1);\n\n    const members2 = await conversation2.members();\n    expect(members2.length).toBe(2);\n    const memberInboxIds2 = members2.map((member) => member.inboxId);\n    expect(memberInboxIds2).toContain(client1.inboxId);\n    expect(memberInboxIds2).toContain(client3.inboxId);\n    expect(await conversation2.metadata()).toEqual({\n      conversationType: \"group\",\n      creatorInboxId: client1.inboxId,\n    });\n\n    const conversations3 = client3.conversations.listGroups();\n    expect(conversations3.length).toBe(0);\n\n    await client3.conversations.sync();\n\n    const conversations4 = client3.conversations.listGroups();\n    expect(conversations4.length).toBe(1);\n    expect(conversations4[0].id).toBe(conversation2.id);\n\n    expect(client2.conversations.listDms().length).toBe(0);\n    expect(client2.conversations.listGroups().length).toBe(1);\n  });\n\n  it(\"should create a dm\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const group = await client1.conversations.newDm(client2.inboxId);\n    expect(group).toBeDefined();\n    expect(group.id).toBeDefined();\n    expect(group.createdAtNs).toBeDefined();\n    expect(group.createdAt).toBeDefined();\n    expect(group.isActive).toBe(true);\n    expect(group.isCommitLogForked).toBe(null);\n    expect(group.addedByInboxId).toBe(client1.inboxId);\n    expect((await group.messages()).length).toBe(1);\n    const members = await group.members();\n    expect(members.length).toBe(2);\n    const memberInboxIds = members.map((member) => member.inboxId);\n    expect(memberInboxIds).toContain(client1.inboxId);\n    expect(memberInboxIds).toContain(client2.inboxId);\n    expect((await group.metadata()).conversationType).toBe(\"dm\");\n    expect((await group.metadata()).creatorInboxId).toBe(client1.inboxId);\n\n    expect(group.consentState).toBe(ConsentState.Allowed);\n\n    const group1 = client1.conversations.listDms();\n    expect(group1.length).toBe(1);\n    expect(group1[0].id).toBe(group.id);\n    expect(group1[0].peerInboxId).toBe(client2.inboxId);\n\n    expect(client1.conversations.listDms().length).toBe(1);\n    expect(client1.conversations.listGroups().length).toBe(0);\n\n    expect(client2.conversations.listDms().length).toBe(0);\n\n    await client2.conversations.sync();\n\n    const group2 = client2.conversations.listDms();\n    expect(group2.length).toBe(1);\n    expect(group2[0].id).toBe(group.id);\n    expect(group2[0].peerInboxId).toBe(client1.inboxId);\n\n    expect(client2.conversations.listDms().length).toBe(1);\n    expect(client2.conversations.listGroups().length).toBe(0);\n\n    const dm1 = client1.conversations.getDmByInboxId(client2.inboxId);\n    expect(dm1).toBeDefined();\n    expect(dm1!.id).toBe(group.id);\n\n    const dm2 = client2.conversations.getDmByInboxId(client1.inboxId);\n    expect(dm2).toBeDefined();\n    expect(dm2!.id).toBe(group.id);\n\n    const group3 = await client1.conversations.newDm(client3.inboxId);\n    expect(group3).toBeDefined();\n    expect(group3.id).toBeDefined();\n    expect(group3.peerInboxId).toBe(client3.inboxId);\n    expect(group3.addedByInboxId).toBe(client1.inboxId);\n    expect((await group3.messages()).length).toBe(1);\n    const members3 = await group3.members();\n    expect(members3.length).toBe(2);\n    const memberInboxIds3 = members3.map((member) => member.inboxId);\n    expect(memberInboxIds3).toContain(client1.inboxId);\n    expect(memberInboxIds3).toContain(client3.inboxId);\n    expect(await group3.metadata()).toEqual({\n      conversationType: \"dm\",\n      creatorInboxId: client1.inboxId,\n    });\n\n    expect(client3.conversations.listDms().length).toBe(0);\n\n    await client3.conversations.sync();\n\n    const groups4 = client3.conversations.listDms();\n    expect(groups4.length).toBe(1);\n    expect(groups4[0].id).toBe(group3.id);\n    expect(groups4[0].peerInboxId).toBe(client1.inboxId);\n\n    expect(client3.conversations.listDms().length).toBe(1);\n    expect(client3.conversations.listGroups().length).toBe(0);\n\n    const dm3 = client1.conversations.getDmByInboxId(client3.inboxId);\n    expect(dm3).toBeDefined();\n    expect(dm3!.id).toBe(group3.id);\n\n    const dm4 = client3.conversations.getDmByInboxId(client1.inboxId);\n    expect(dm4).toBeDefined();\n    expect(dm4!.id).toBe(group3.id);\n\n    const dupeDms1 = await group.getDuplicateDms();\n    const dupeDms2 = await group3.getDuplicateDms();\n    expect(dupeDms1.length).toEqual(0);\n    expect(dupeDms2.length).toEqual(0);\n  });\n\n  it(\"should create groups with identifiers\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    await createRegisteredClient(signer2);\n    await createRegisteredClient(signer3);\n    const group = await client1.conversations.newGroupWithIdentifiers([\n      await signer2.getIdentifier(),\n    ]);\n    expect(group).toBeDefined();\n    const dm = await client1.conversations.newDmWithIdentifier(\n      await signer3.getIdentifier(),\n    );\n    expect(dm).toBeDefined();\n  });\n\n  it(\"should get a group by ID\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const group = await client1.conversations.newGroup([client2.inboxId]);\n    expect(group).toBeDefined();\n    expect(group.id).toBeDefined();\n    const foundGroup = await client1.conversations.getConversationById(\n      group.id,\n    );\n    expect(foundGroup).toBeDefined();\n    expect(foundGroup!.id).toBe(group.id);\n  });\n\n  it(\"should get a message by ID\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const group = await client1.conversations.newGroup([client2.inboxId]);\n    const messageId = await group.send(\"gm!\");\n    expect(messageId).toBeDefined();\n\n    const message = client1.conversations.getMessageById(messageId);\n    expect(message).toBeDefined();\n    expect(message!.id).toBe(messageId);\n  });\n\n  it(\"should create a group with options\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const user4 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const signer4 = createSigner(user4);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const client4 = await createRegisteredClient(signer4);\n    const groupWithName = await client1.conversations.newGroup(\n      [client2.inboxId],\n      {\n        groupName: \"foo\",\n      },\n    );\n    expect(groupWithName).toBeDefined();\n    expect(groupWithName.name).toBe(\"foo\");\n    expect(groupWithName.imageUrl).toBe(\"\");\n\n    const groupWithImageUrl = await client1.conversations.newGroup(\n      [client3.inboxId],\n      {\n        groupImageUrlSquare: \"https://foo/bar.png\",\n      },\n    );\n    expect(groupWithImageUrl).toBeDefined();\n    expect(groupWithImageUrl.name).toBe(\"\");\n    expect(groupWithImageUrl.imageUrl).toBe(\"https://foo/bar.png\");\n\n    const groupWithNameAndImageUrl = await client1.conversations.newGroup(\n      [client4.inboxId],\n      {\n        groupImageUrlSquare: \"https://foo/bar.png\",\n        groupName: \"foo\",\n      },\n    );\n    expect(groupWithNameAndImageUrl).toBeDefined();\n    expect(groupWithNameAndImageUrl.name).toBe(\"foo\");\n    expect(groupWithNameAndImageUrl.imageUrl).toBe(\"https://foo/bar.png\");\n\n    const groupWithPermissions = await client1.conversations.newGroup(\n      [client4.inboxId],\n      {\n        permissions: GroupPermissionsOptions.AdminOnly,\n      },\n    );\n    expect(groupWithPermissions).toBeDefined();\n    expect(groupWithPermissions.name).toBe(\"\");\n    expect(groupWithPermissions.imageUrl).toBe(\"\");\n    expect(groupWithPermissions.permissions.policyType).toBe(\n      GroupPermissionsOptions.AdminOnly,\n    );\n\n    expect(groupWithPermissions.permissions.policySet).toEqual({\n      addMemberPolicy: 2,\n      removeMemberPolicy: 2,\n      addAdminPolicy: 3,\n      removeAdminPolicy: 3,\n      updateGroupNamePolicy: 2,\n      updateGroupDescriptionPolicy: 2,\n      updateGroupImageUrlSquarePolicy: 2,\n      updateMessageDisappearingPolicy: 2,\n    });\n\n    const groupWithDescription = await client1.conversations.newGroup(\n      [client2.inboxId],\n      {\n        groupDescription: \"foo\",\n      },\n    );\n    expect(groupWithDescription).toBeDefined();\n    expect(groupWithDescription.name).toBe(\"\");\n    expect(groupWithDescription.imageUrl).toBe(\"\");\n    expect(groupWithDescription.description).toBe(\"foo\");\n  });\n\n  it(\"should create a group with custom permissions\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const group = await client1.conversations.newGroup([client2.inboxId], {\n      permissions: GroupPermissionsOptions.CustomPolicy,\n      customPermissionPolicySet: {\n        addAdminPolicy: 1,\n        addMemberPolicy: 0,\n        removeAdminPolicy: 1,\n        removeMemberPolicy: 1,\n        updateGroupNamePolicy: 1,\n        updateGroupDescriptionPolicy: 1,\n        updateGroupImageUrlSquarePolicy: 1,\n        updateMessageDisappearingPolicy: 2,\n      },\n    });\n    expect(group).toBeDefined();\n    expect(group.permissions.policyType).toBe(\n      GroupPermissionsOptions.CustomPolicy,\n    );\n    expect(group.permissions.policySet).toEqual({\n      addAdminPolicy: 1,\n      addMemberPolicy: 0,\n      removeAdminPolicy: 1,\n      removeMemberPolicy: 1,\n      updateGroupNamePolicy: 1,\n      updateGroupDescriptionPolicy: 1,\n      updateGroupImageUrlSquarePolicy: 1,\n      updateMessageDisappearingPolicy: 2,\n    });\n  });\n\n  it(\"should stream new conversations\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const stream = await client3.conversations.stream();\n    const conversation1 = await client1.conversations.newGroup([\n      client3.inboxId,\n    ]);\n    const conversation2 = await client2.conversations.newGroup([\n      client3.inboxId,\n    ]);\n\n    const expectedIds = [conversation1.id, conversation2.id];\n    const receivedIds: string[] = [];\n\n    setTimeout(() => {\n      void stream.end();\n    }, 2000);\n\n    for await (const convo of stream) {\n      if (convo === undefined) {\n        break;\n      }\n      expect(convo).toBeDefined();\n      receivedIds.push(convo.id);\n    }\n\n    expect(receivedIds.length).toBe(2);\n    expect(receivedIds.sort()).toEqual(expectedIds.sort());\n    expect(\n      (await client3.conversations.getConversationById(conversation1.id))?.id,\n    ).toBe(conversation1.id);\n    expect(\n      (await client3.conversations.getConversationById(conversation2.id))?.id,\n    ).toBe(conversation2.id);\n  });\n\n  it(\"should only stream group conversations\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const user4 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const signer4 = createSigner(user4);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const client4 = await createRegisteredClient(signer4);\n    const stream = await client3.conversations.streamGroups();\n    await client4.conversations.newDm(client3.inboxId);\n    const group1 = await client1.conversations.newGroup([client3.inboxId]);\n    const group2 = await client2.conversations.newGroup([client3.inboxId]);\n\n    const expectedIds = [group1.id, group2.id];\n    const receivedIds: string[] = [];\n\n    setTimeout(() => {\n      void stream.end();\n    }, 2000);\n\n    for await (const convo of stream) {\n      expect(convo).toBeDefined();\n      receivedIds.push(convo.id);\n    }\n    expect(receivedIds.length).toBe(2);\n    expect(receivedIds.sort()).toEqual(expectedIds.sort());\n  });\n\n  it(\"should only stream dm conversations\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const user4 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const signer4 = createSigner(user4);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const client4 = await createRegisteredClient(signer4);\n    const stream = await client3.conversations.streamDms();\n    await client1.conversations.newGroup([client3.inboxId]);\n    await client2.conversations.newGroup([client3.inboxId]);\n    const group3 = await client4.conversations.newDm(client3.inboxId);\n\n    setTimeout(() => {\n      void stream.end();\n    }, 2000);\n\n    let count = 0;\n    for await (const convo of stream) {\n      count++;\n      expect(convo).toBeDefined();\n      if (count === 1) {\n        expect(convo.id).toBe(group3.id);\n      }\n    }\n    expect(count).toBe(1);\n  });\n\n  it(\"should stream all messages\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    await client1.conversations.newGroup([client2.inboxId]);\n    await client1.conversations.newGroup([client3.inboxId]);\n\n    await sleep(2000);\n\n    const stream = await client1.conversations.streamAllMessages();\n\n    await client2.conversations.sync();\n    const groups2 = client2.conversations.listGroups();\n\n    await client3.conversations.sync();\n    const groups3 = client3.conversations.listGroups();\n\n    await groups2[0].send(\"gm!\");\n    await groups3[0].send(\"gm2!\");\n\n    setTimeout(() => {\n      void stream.end();\n    }, 2000);\n\n    let count = 0;\n    for await (const message of stream) {\n      count++;\n      expect(message).toBeDefined();\n      if (count === 1) {\n        expect(message.senderInboxId).toBe(client2.inboxId);\n      }\n      if (count === 2) {\n        expect(message.senderInboxId).toBe(client3.inboxId);\n      }\n    }\n    expect(count).toBe(2);\n  });\n\n  it(\"should only stream group conversation messages\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const user4 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const signer4 = createSigner(user4);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const client4 = await createRegisteredClient(signer4);\n    await client1.conversations.newGroup([client2.inboxId]);\n    await client1.conversations.newGroup([client3.inboxId]);\n    await client1.conversations.newDm(client4.inboxId);\n\n    await sleep(2000);\n\n    const stream = await client1.conversations.streamAllGroupMessages();\n\n    const groups2 = client2.conversations;\n    await groups2.sync();\n    const groupsList2 = await groups2.list();\n\n    const groups3 = client3.conversations;\n    await groups3.sync();\n    const groupsList3 = await groups3.list();\n\n    const groups4 = client4.conversations;\n    await groups4.sync();\n    const groupsList4 = await groups4.list();\n\n    await groupsList4[0].send(\"gm3!\");\n    await groupsList2[0].send(\"gm!\");\n    await groupsList3[0].send(\"gm2!\");\n\n    setTimeout(() => {\n      void stream.end();\n    }, 2000);\n\n    let count = 0;\n    for await (const message of stream) {\n      count++;\n      expect(message).toBeDefined();\n      if (count === 1) {\n        expect(message.senderInboxId).toBe(client2.inboxId);\n      }\n      if (count === 2) {\n        expect(message.senderInboxId).toBe(client3.inboxId);\n      }\n    }\n    expect(count).toBe(2);\n  });\n\n  it(\"should only stream dm messages\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const user4 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const signer4 = createSigner(user4);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const client4 = await createRegisteredClient(signer4);\n    await client1.conversations.newGroup([client2.inboxId]);\n    await client1.conversations.newGroup([client3.inboxId]);\n    await client1.conversations.newDm(client4.inboxId);\n\n    await sleep(2000);\n\n    const stream = await client1.conversations.streamAllDmMessages();\n\n    const groups2 = client2.conversations;\n    await groups2.sync();\n    const groupsList2 = await groups2.list();\n\n    const groups3 = client3.conversations;\n    await groups3.sync();\n    const groupsList3 = await groups3.list();\n\n    const groups4 = client4.conversations;\n    await groups4.sync();\n    const groupsList4 = await groups4.list();\n\n    await groupsList2[0].send(\"gm!\");\n    await groupsList3[0].send(\"gm2!\");\n    await groupsList4[0].send(\"gm3!\");\n\n    setTimeout(() => {\n      void stream.end();\n    }, 2000);\n\n    let count = 0;\n    for await (const message of stream) {\n      count++;\n      expect(message).toBeDefined();\n      if (count === 1) {\n        expect(message.senderInboxId).toBe(client4.inboxId);\n      }\n      expect(count).toBe(1);\n    }\n  });\n\n  it(\"should get hmac keys\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const group = await client1.conversations.newGroup([client2.inboxId]);\n    const dm = await client1.conversations.newDm(client2.inboxId);\n    const hmacKeys = client1.conversations.hmacKeys();\n    expect(hmacKeys).toBeDefined();\n    const keys = Object.keys(hmacKeys);\n    expect(keys.length).toBe(2);\n    expect(keys).toContain(group.id);\n    expect(keys).toContain(dm.id);\n    for (const values of Object.values(hmacKeys)) {\n      expect(values.length).toBe(3);\n      for (const value of values) {\n        expect(value.key).toBeDefined();\n        expect(value.key.length).toBe(42);\n        expect(value.epoch).toBeDefined();\n        expect(typeof value.epoch).toBe(\"bigint\");\n      }\n    }\n  });\n\n  it(\"should sync groups across installations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const user2 = createUser();\n    const signer2 = createSigner(user2);\n    await createRegisteredClient(signer2);\n\n    const group = await client.conversations.newGroup([client2.inboxId]);\n    await client2.conversations.sync();\n    const convos = client2.conversations.listGroups();\n    expect(convos.length).toBe(1);\n    expect(convos[0].id).toBe(group.id);\n\n    const group2 = await client.conversations.newDm(client2.inboxId);\n    await client2.conversations.sync();\n    const convos2 = await client2.conversations.list();\n    expect(convos2.length).toBe(2);\n    const convos2Ids = convos2.map((c) => c.id);\n    expect(convos2Ids).toContain(group.id);\n    expect(convos2Ids).toContain(group2.id);\n  });\n\n  it(\"should stitch DM groups together\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const dm1 = await client1.conversations.newDm(client2.inboxId);\n    const dm2 = await client2.conversations.newDm(client1.inboxId);\n\n    await dm1.send(\"hi\");\n    // since this is the last message sent, the stitched group ID will be\n    // this group ID\n    await dm2.send(\"hi\");\n\n    await client1.conversations.sync();\n    await client2.conversations.sync();\n    await dm1.sync();\n    await dm2.sync();\n\n    const dm1_2 = await client1.conversations.getConversationById(dm1.id);\n    const dm2_2 = await client2.conversations.getConversationById(dm2.id);\n    expect(dm1_2?.id).toBe(dm2.id);\n    expect(dm2_2?.id).toBe(dm2.id);\n\n    const dms1 = client1.conversations.listDms();\n    const dms2 = client2.conversations.listDms();\n    expect(dms1[0].id).toBe(dm2.id);\n    expect(dms2[0].id).toBe(dm2.id);\n\n    const dupeDms1 = await dms1[0].getDuplicateDms();\n    const dupeDms2 = await dms2[0].getDuplicateDms();\n    expect(dupeDms1.length).toBe(1);\n    expect(dupeDms2.length).toBe(1);\n    expect(dupeDms1[0].id).toBe(dm1.id);\n    expect(dupeDms2[0].id).toBe(dm1.id);\n  });\n\n  it(\"should create optimistic groups\", async () => {\n    const user1 = createUser();\n    const signer1 = createSigner(user1);\n    const client1 = await createRegisteredClient(signer1);\n    const group = client1.conversations.newGroupOptimistic();\n    expect(group).toBeDefined();\n    expect(group.id).toBeDefined();\n    expect(group.createdAtNs).toBeDefined();\n    expect(group.createdAt).toBeDefined();\n    expect(group.isActive).toBe(true);\n    expect(group.name).toBe(\"\");\n    expect(group.permissions.policyType).toBe(GroupPermissionsOptions.Default);\n    expect(group.permissions.policySet).toEqual({\n      addMemberPolicy: 0,\n      removeMemberPolicy: 2,\n      addAdminPolicy: 3,\n      removeAdminPolicy: 3,\n      updateGroupNamePolicy: 0,\n      updateGroupDescriptionPolicy: 0,\n      updateGroupImageUrlSquarePolicy: 0,\n      updateMessageDisappearingPolicy: 2,\n    });\n    expect(group.addedByInboxId).toBe(client1.inboxId);\n    expect((await group.messages()).length).toBe(0);\n\n    const group2 = client1.conversations.newGroupOptimistic({\n      groupName: \"test\",\n      groupDescription: \"test\",\n      groupImageUrlSquare: \"test\",\n      permissions: GroupPermissionsOptions.CustomPolicy,\n      customPermissionPolicySet: {\n        addAdminPolicy: 1,\n        addMemberPolicy: 0,\n        removeAdminPolicy: 1,\n        removeMemberPolicy: 1,\n        updateGroupNamePolicy: 1,\n        updateGroupDescriptionPolicy: 1,\n        updateGroupImageUrlSquarePolicy: 1,\n        updateMessageDisappearingPolicy: 2,\n      },\n      messageDisappearingSettings: {\n        fromNs: 1000,\n        inNs: 1000,\n      },\n    });\n    expect(group2).toBeDefined();\n    expect(group2.id).toBeDefined();\n    expect(group2.createdAtNs).toBeDefined();\n    expect(group2.createdAt).toBeDefined();\n    expect(group2.isActive).toBe(true);\n    expect(group2.name).toBe(\"test\");\n    expect(group2.description).toBe(\"test\");\n    expect(group2.imageUrl).toBe(\"test\");\n    expect(group2.addedByInboxId).toBe(client1.inboxId);\n    expect(group2.permissions.policyType).toBe(\n      GroupPermissionsOptions.CustomPolicy,\n    );\n    expect(group2.permissions.policySet).toEqual({\n      addAdminPolicy: 1,\n      addMemberPolicy: 0,\n      removeAdminPolicy: 1,\n      removeMemberPolicy: 1,\n      updateGroupNamePolicy: 1,\n      updateGroupDescriptionPolicy: 1,\n      updateGroupImageUrlSquarePolicy: 1,\n      updateMessageDisappearingPolicy: 2,\n    });\n    expect(group2.isMessageDisappearingEnabled()).toBe(true);\n    expect(group2.messageDisappearingSettings()).toEqual({\n      fromNs: 1000,\n      inNs: 1000,\n    });\n\n    expect((await group2.messages()).length).toBe(0);\n  });\n});\n",
      "size_bytes": 29283
    },
    "content-types/content-type-transaction-reference/CHANGELOG.md": {
      "content": "# @xmtp/content-type-transaction-reference\n\n## 2.0.2\n\n### Patch Changes\n\n- Updated dependencies [779fd0c]\n  - @xmtp/content-type-primitives@2.0.2\n\n## 2.0.1\n\n### Patch Changes\n\n- Updated dependencies [340fcf4]\n  - @xmtp/content-type-primitives@2.0.1\n\n## 2.0.0\n\n### Major Changes\n\n- 1777a23: Dropped support for CommonJS\n\n### Patch Changes\n\n- Updated dependencies [1777a23]\n  - @xmtp/content-type-primitives@2.0.0\n\n## 1.0.5\n\n### Patch Changes\n\n- Updated dependencies [63e5276]\n  - @xmtp/content-type-primitives@1.0.3\n\n## 1.0.4\n\n### Patch Changes\n\n- [#75](https://github.com/xmtp/xmtp-js-content-types/pull/75) [`da0bd85`](https://github.com/xmtp/xmtp-js-content-types/commit/da0bd8578d5f5032b221e25f02e8492b27929d6c)\n  - Use primitives package for types\n\n## 1.0.3\n\n### Patch Changes\n\n- [#65](https://github.com/xmtp/xmtp-js-content-types/pull/65) [`c4d43dc`](https://github.com/xmtp/xmtp-js-content-types/commit/c4d43dc948231de5c7f730e06f0931076de0673b)\n  - Add `shouldPush` to all content codecs\n\n## 1.0.2\n\n### Patch Changes\n\n- [#60](https://github.com/xmtp/xmtp-js-content-types/pull/60) [`5b9310a`](https://github.com/xmtp/xmtp-js-content-types/commit/5b9310ac89fd23e5cfd74903894073b6ef8af7c3)\n  - Upgraded JS SDK to `11.3.12`\n\n## 1.0.1\n\n### Patch Changes\n\n- [#51](https://github.com/xmtp/xmtp-js-content-types/pull/51) [`aeb6db7`](https://github.com/xmtp/xmtp-js-content-types/commit/aeb6db73a63409a33c7d3d3431e33682b0ce4c4d)\n  - Only publish files in the `/dist` directory\n",
      "size_bytes": 1476
    },
    "apps/xmtp.chat-api-service/src/index.ts": {
      "content": "import cors from \"cors\";\nimport express, { type Request, type Response } from \"express\";\nimport helmet from \"helmet\";\nimport apiRouter from \"./api/index.js\";\nimport { errorMiddleware } from \"./middleware/error.js\";\nimport { jsonMiddleware } from \"./middleware/json.js\";\nimport { noRouteMiddleware } from \"./middleware/noRoute.js\";\nimport { rateLimitMiddleware } from \"./middleware/rateLimit.js\";\n\nconst app = express();\n\nconst env = process.env.NODE_ENV || \"development\";\nconst allowedOrigins = [\n  \"https://xmtp.chat\",\n  \"https://d14n.xmtp.chat\",\n  // vercel preview domains\n  /^https:\\/\\/(.*)-ephemerahq\\.vercel\\.app$/,\n];\n\nif (env === \"development\") {\n  allowedOrigins.push(\"http://localhost:5173\");\n}\n\napp.set(\"trust proxy\", 1);\napp.use(helmet()); // Set security headers\napp.use(\n  cors({\n    origin: allowedOrigins,\n    methods: [\"GET\", \"OPTIONS\", \"POST\"],\n    allowedHeaders: [\"*\"],\n    credentials: true,\n    maxAge: 86400,\n  }),\n); // Handle CORS\napp.use(jsonMiddleware); // Parse JSON requests\n\n// Rate limiting should be before routes but after logging\napp.use(rateLimitMiddleware);\n\n// GET /healthcheck - Healthcheck endpoint\napp.get(\"/healthcheck\", (_req: Request, res: Response): void => {\n  res.status(200).send(\"OK\");\n});\n\n// add api routes\napp.use(\"/api\", apiRouter);\n\n// handle non-existent routes with 404 response\napp.use(noRouteMiddleware);\n\n// Error handling middleware should be last\napp.use(errorMiddleware);\n\nconst port = process.env.PORT || 4000;\nconst server = app.listen(port, () => {\n  console.log(`xmtp.chat API service is running on port ${port}`);\n  console.log(`Environment: ${env}`);\n});\n\nprocess.on(\"SIGTERM\", () => {\n  console.log(\"SIGTERM signal received: closing xmtp.chat API service\");\n  server.close(() => {\n    console.log(\"xmtp.chat API service closed\");\n  });\n});\n\nprocess.on(\"SIGINT\", () => {\n  console.log(\"SIGINT signal received: closing xmtp.chat API service\");\n  server.close(() => {\n    console.log(\"xmtp.chat API service closed\");\n  });\n});\n",
      "size_bytes": 1992
    },
    "sdks/browser-sdk/src/WorkerDebugInformation.ts": {
      "content": "import type { Client } from \"@xmtp/wasm-bindings\";\nimport { HistorySyncUrls } from \"@/constants\";\nimport type { ClientOptions } from \"@/types/options\";\n\n/**\n * Debug information helpers for the client\n *\n * This class is not intended to be initialized directly.\n */\nexport class WorkerDebugInformation {\n  #client: Client;\n  #options?: ClientOptions;\n\n  constructor(client: Client, options?: ClientOptions) {\n    this.#client = client;\n    this.#options = options;\n  }\n\n  apiStatistics() {\n    return this.#client.apiStatistics();\n  }\n\n  apiIdentityStatistics() {\n    return this.#client.apiIdentityStatistics();\n  }\n\n  apiAggregateStatistics() {\n    return this.#client.apiAggregateStatistics();\n  }\n\n  clearAllStatistics() {\n    this.#client.clearAllStatistics();\n  }\n\n  uploadDebugArchive(serverUrl?: string) {\n    const env = this.#options?.env || \"dev\";\n    const historySyncUrl =\n      this.#options?.historySyncUrl || HistorySyncUrls[env];\n    return this.#client.uploadDebugArchive(serverUrl || historySyncUrl);\n  }\n}\n",
      "size_bytes": 1026
    },
    "apps/xmtp.chat/src/layouts/MainLayout.tsx": {
      "content": "import { useClickOutside } from \"@mantine/hooks\";\nimport classes from \"./MainLayout.module.css\";\n\nexport const MainLayout: React.FC<React.PropsWithChildren> = ({ children }) => {\n  return <div className={classes.root}>{children}</div>;\n};\n\nexport const MainLayoutHeader: React.FC<React.PropsWithChildren> = ({\n  children,\n}) => {\n  return (\n    <header className={classes.header}>\n      <div className={classes.headerContent}>{children}</div>\n    </header>\n  );\n};\n\nexport const MainLayoutContent: React.FC<React.PropsWithChildren> = ({\n  children,\n}) => {\n  return (\n    <main className={classes.main}>\n      <div className={classes.mainContent}>{children}</div>\n    </main>\n  );\n};\n\nexport type MainLayoutNavProps = React.PropsWithChildren<{\n  opened?: boolean;\n  toggle?: () => void;\n}>;\n\nexport const MainLayoutNav: React.FC<MainLayoutNavProps> = ({\n  children,\n  opened,\n  toggle,\n}) => {\n  const ref = useClickOutside(() => {\n    if (opened) {\n      toggle?.();\n    }\n  });\n  const classNames = [classes.aside, opened && classes.showNavbar].filter(Boolean);\n  const overlayClassNames = [classes.overlay, opened && classes.overlayVisible]\n    .filter(Boolean)\n    .join(\" \");\n  return (\n    <>\n      <div\n        className={overlayClassNames}\n        onClick={() => {\n          if (opened) {\n            toggle?.();\n          }\n        }}\n      />\n      <aside className={classNames.join(\" \")} ref={ref}>\n        <nav className={classes.asideNav}>{children}</nav>\n      </aside>\n    </>\n  );\n};\n\nexport const MainLayoutFooter: React.FC<React.PropsWithChildren> = ({\n  children,\n}) => {\n  return (\n    <footer className={classes.footer}>\n      <div className={classes.footerContent}>{children}</div>\n    </footer>\n  );\n};\n",
      "size_bytes": 1726
    },
    "sdks/browser-sdk/test/Conversations.test.ts": {
      "content": "import { ConsentState, GroupPermissionsOptions } from \"@xmtp/wasm-bindings\";\nimport { v4 } from \"uuid\";\nimport { describe, expect, it } from \"vitest\";\nimport {\n  createRegisteredClient,\n  createSigner,\n  createUser,\n  sleep,\n} from \"@test/helpers\";\n\ndescribe(\"Conversations\", () => {\n  it(\"should not have initial conversations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n\n    expect((await client.conversations.list()).length).toBe(0);\n    expect((await client.conversations.listDms()).length).toBe(0);\n    expect((await client.conversations.listGroups()).length).toBe(0);\n  });\n\n  it(\"should create a new conversation\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const conversation = await client1.conversations.newGroup([\n      client2.inboxId!,\n    ]);\n    expect(conversation).toBeDefined();\n    expect(\n      (await client1.conversations.getConversationById(conversation.id))?.id,\n    ).toBe(conversation.id);\n    expect(conversation.id).toBeDefined();\n    expect(conversation.createdAtNs).toBeDefined();\n    expect(conversation.createdAt).toBeDefined();\n    expect(await conversation.isActive()).toBe(true);\n    expect(conversation.isCommitLogForked).toBeUndefined();\n    expect(conversation.name).toBe(\"\");\n    expect(await conversation.messageDisappearingSettings()).toBeUndefined();\n    expect(await conversation.isMessageDisappearingEnabled()).toBe(false);\n\n    const conversation2 = await client1.conversations.newGroup([\n      client3.inboxId!,\n    ]);\n    expect(\n      (await client1.conversations.getConversationById(conversation2.id))?.id,\n    ).toBe(conversation2.id);\n    expect(conversation2).toBeDefined();\n    expect(conversation2.id).toBeDefined();\n    expect(conversation2.createdAtNs).toBeDefined();\n    expect(conversation2.createdAt).toBeDefined();\n    expect(await conversation2.isActive()).toBe(true);\n    expect(conversation2.name).toBe(\"\");\n    expect(await conversation2.messageDisappearingSettings()).toBeUndefined();\n    expect(await conversation2.isMessageDisappearingEnabled()).toBe(false);\n\n    const permissions = await conversation.permissions();\n    expect(permissions.policyType).toBe(GroupPermissionsOptions.Default);\n    expect(permissions.policySet).toEqual({\n      addMemberPolicy: 0,\n      removeMemberPolicy: 2,\n      addAdminPolicy: 3,\n      removeAdminPolicy: 3,\n      updateGroupNamePolicy: 0,\n      updateGroupDescriptionPolicy: 0,\n      updateGroupImageUrlSquarePolicy: 0,\n      updateMessageDisappearingPolicy: 2,\n    });\n\n    const permissions2 = await conversation2.permissions();\n    expect(permissions2.policyType).toBe(GroupPermissionsOptions.Default);\n    expect(permissions2.policySet).toEqual({\n      addMemberPolicy: 0,\n      removeMemberPolicy: 2,\n      addAdminPolicy: 3,\n      removeAdminPolicy: 3,\n      updateGroupNamePolicy: 0,\n      updateGroupDescriptionPolicy: 0,\n      updateGroupImageUrlSquarePolicy: 0,\n      updateMessageDisappearingPolicy: 2,\n    });\n\n    expect(conversation.addedByInboxId).toBe(client1.inboxId);\n    expect((await conversation.messages()).length).toBe(1);\n\n    expect(conversation2.addedByInboxId).toBe(client1.inboxId);\n    expect((await conversation2.messages()).length).toBe(1);\n\n    const members = await conversation.members();\n    expect(members.length).toBe(2);\n    const memberInboxIds = members.map((member) => member.inboxId);\n    expect(memberInboxIds).toContain(client1.inboxId);\n    expect(memberInboxIds).toContain(client2.inboxId);\n\n    const members2 = await conversation2.members();\n    expect(members2.length).toBe(2);\n    const memberInboxIds2 = members2.map((member) => member.inboxId);\n    expect(memberInboxIds2).toContain(client1.inboxId);\n    expect(memberInboxIds2).toContain(client3.inboxId);\n\n    expect(conversation.metadata).toEqual({\n      conversationType: \"group\",\n      creatorInboxId: client1.inboxId,\n    });\n\n    expect(conversation2.metadata).toEqual({\n      conversationType: \"group\",\n      creatorInboxId: client1.inboxId,\n    });\n\n    const conversations1 = await client1.conversations.list();\n    expect(conversations1.length).toBe(2);\n\n    expect((await client2.conversations.list()).length).toBe(0);\n\n    await client2.conversations.sync();\n\n    const conversations2 = await client2.conversations.list();\n    expect(conversations2.length).toBe(1);\n    expect(conversations2[0].id).toBe(conversation.id);\n\n    expect((await client2.conversations.listDms()).length).toBe(0);\n    expect((await client2.conversations.listGroups()).length).toBe(1);\n\n    expect((await client3.conversations.list()).length).toBe(0);\n\n    await client3.conversations.sync();\n\n    const conversations3 = await client2.conversations.list();\n    expect(conversations3.length).toBe(1);\n    expect(conversations3[0].id).toBe(conversation.id);\n\n    expect((await client3.conversations.listDms()).length).toBe(0);\n    expect((await client3.conversations.listGroups()).length).toBe(1);\n  });\n\n  it(\"should create a dm group\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n\n    const group = await client1.conversations.newDm(client2.inboxId!);\n    expect(group).toBeDefined();\n    expect(group.id).toBeDefined();\n    expect(group.createdAtNs).toBeDefined();\n    expect(group.createdAt).toBeDefined();\n    expect(await group.isActive()).toBe(true);\n    expect(group.isCommitLogForked).toBeUndefined();\n    expect(await group.messageDisappearingSettings()).toBeUndefined();\n    expect(await group.isMessageDisappearingEnabled()).toBe(false);\n\n    const group2 = await client1.conversations.newDm(client3.inboxId!);\n    expect(group2).toBeDefined();\n    expect(group2.id).toBeDefined();\n    expect(group2.createdAtNs).toBeDefined();\n    expect(group2.createdAt).toBeDefined();\n    expect(await group2.isActive()).toBe(true);\n    expect(await group2.messageDisappearingSettings()).toBeUndefined();\n    expect(await group2.isMessageDisappearingEnabled()).toBe(false);\n\n    expect(group.addedByInboxId).toBe(client1.inboxId);\n    expect(group2.addedByInboxId).toBe(client1.inboxId);\n\n    expect((await group.messages()).length).toBe(1);\n    expect((await group2.messages()).length).toBe(1);\n\n    const members = await group.members();\n    expect(members.length).toBe(2);\n    const memberInboxIds = members.map((member) => member.inboxId);\n    expect(memberInboxIds).toContain(client1.inboxId);\n    expect(memberInboxIds).toContain(client2.inboxId);\n\n    const members2 = await group2.members();\n    expect(members2.length).toBe(2);\n    const memberInboxIds2 = members2.map((member) => member.inboxId);\n    expect(memberInboxIds2).toContain(client1.inboxId);\n    expect(memberInboxIds2).toContain(client3.inboxId);\n\n    expect(group.metadata?.conversationType).toBe(\"dm\");\n    expect(group.metadata?.creatorInboxId).toBe(client1.inboxId);\n\n    expect(group2.metadata?.conversationType).toBe(\"dm\");\n    expect(group2.metadata?.creatorInboxId).toBe(client1.inboxId);\n\n    expect(await group.consentState()).toBe(ConsentState.Allowed);\n    expect(await group2.consentState()).toBe(ConsentState.Allowed);\n\n    expect((await client1.conversations.listDms()).length).toBe(2);\n    expect((await client1.conversations.listGroups()).length).toBe(0);\n\n    expect((await client2.conversations.list()).length).toBe(0);\n    expect((await client3.conversations.list()).length).toBe(0);\n\n    await client2.conversations.sync();\n    await client3.conversations.sync();\n\n    const groups2 = await client2.conversations.listDms();\n    expect(groups2.length).toBe(1);\n    expect(groups2[0].id).toBe(group.id);\n    expect(await groups2[0].peerInboxId()).toBe(client1.inboxId);\n\n    expect((await client2.conversations.listDms()).length).toBe(1);\n    expect((await client2.conversations.listGroups()).length).toBe(0);\n\n    const groups3 = await client3.conversations.listDms();\n    expect(groups3.length).toBe(1);\n    expect(groups3[0].id).toBe(group2.id);\n    expect(await groups3[0].peerInboxId()).toBe(client1.inboxId);\n\n    const dm1 = await client1.conversations.getDmByInboxId(client2.inboxId!);\n    expect(dm1).toBeDefined();\n    expect(dm1!.id).toBe(group.id);\n\n    const peerInboxId = await dm1?.peerInboxId();\n    expect(peerInboxId).toBeDefined();\n    expect(peerInboxId).toBe(client2.inboxId);\n\n    const dm2 = await client2.conversations.getDmByInboxId(client1.inboxId!);\n    expect(dm2).toBeDefined();\n    expect(dm2!.id).toBe(group.id);\n\n    const peerInboxId2 = await dm2?.peerInboxId();\n    expect(peerInboxId2).toBeDefined();\n    expect(peerInboxId2).toBe(client1.inboxId);\n\n    const dm3 = await client1.conversations.getDmByInboxId(client3.inboxId!);\n    expect(dm3).toBeDefined();\n    expect(dm3!.id).toBe(group2.id);\n\n    const peerInboxId3 = await dm3?.peerInboxId();\n    expect(peerInboxId3).toBeDefined();\n    expect(peerInboxId3).toBe(client3.inboxId);\n\n    const dm4 = await client3.conversations.getDmByInboxId(client1.inboxId!);\n    expect(dm4).toBeDefined();\n    expect(dm4!.id).toBe(group2.id);\n\n    const peerInboxId4 = await dm4?.peerInboxId();\n    expect(peerInboxId4).toBeDefined();\n    expect(peerInboxId4).toBe(client1.inboxId);\n\n    const dupeDms1 = await group.getDuplicateDms();\n    const dupeDms2 = await group2.getDuplicateDms();\n    expect(dupeDms1.length).toEqual(0);\n    expect(dupeDms2.length).toEqual(0);\n  });\n\n  it(\"should get a group by ID\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const group = await client1.conversations.newGroup([client2.inboxId!]);\n    expect(group).toBeDefined();\n    expect(group.id).toBeDefined();\n    const foundGroup = await client1.conversations.getConversationById(\n      group.id,\n    );\n    expect(foundGroup).toBeDefined();\n    expect(foundGroup!.id).toBe(group.id);\n  });\n\n  it(\"should get a message by ID\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const group = await client1.conversations.newGroup([client2.inboxId!]);\n    const messageId = await group.send(\"gm!\");\n    expect(messageId).toBeDefined();\n\n    const message = await client1.conversations.getMessageById(messageId);\n    expect(message).toBeDefined();\n    expect(message!.id).toBe(messageId);\n  });\n\n  it(\"should create a new conversation with options\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const user4 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const signer4 = createSigner(user4);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const client4 = await createRegisteredClient(signer4);\n    const groupWithName = await client1.conversations.newGroup(\n      [client2.inboxId!],\n      {\n        name: \"foo\",\n      },\n    );\n    expect(groupWithName).toBeDefined();\n    expect(groupWithName.name).toBe(\"foo\");\n    expect(groupWithName.imageUrl).toBe(\"\");\n\n    const groupWithImageUrl = await client1.conversations.newGroup(\n      [client3.inboxId!],\n      {\n        imageUrlSquare: \"https://foo/bar.png\",\n      },\n    );\n    expect(groupWithImageUrl).toBeDefined();\n    expect(groupWithImageUrl.name).toBe(\"\");\n    expect(groupWithImageUrl.imageUrl).toBe(\"https://foo/bar.png\");\n\n    const groupWithNameAndImageUrl = await client1.conversations.newGroup(\n      [client4.inboxId!],\n      {\n        imageUrlSquare: \"https://foo/bar.png\",\n        name: \"foo\",\n      },\n    );\n    expect(groupWithNameAndImageUrl).toBeDefined();\n    expect(groupWithNameAndImageUrl.name).toBe(\"foo\");\n    expect(groupWithNameAndImageUrl.imageUrl).toBe(\"https://foo/bar.png\");\n\n    const groupWithPermissions = await client1.conversations.newGroup(\n      [client4.inboxId!],\n      {\n        permissions: GroupPermissionsOptions.AdminOnly,\n      },\n    );\n    expect(groupWithPermissions).toBeDefined();\n    expect(groupWithPermissions.name).toBe(\"\");\n    expect(groupWithPermissions.imageUrl).toBe(\"\");\n\n    const permissions = await groupWithPermissions.permissions();\n    expect(permissions.policyType).toBe(GroupPermissionsOptions.AdminOnly);\n    expect(permissions.policySet).toEqual({\n      addMemberPolicy: 2,\n      removeMemberPolicy: 2,\n      addAdminPolicy: 3,\n      removeAdminPolicy: 3,\n      updateGroupNamePolicy: 2,\n      updateGroupDescriptionPolicy: 2,\n      updateGroupImageUrlSquarePolicy: 2,\n      updateMessageDisappearingPolicy: 2,\n    });\n\n    const groupWithDescription = await client1.conversations.newGroup(\n      [client2.inboxId!],\n      {\n        description: \"foo\",\n      },\n    );\n    expect(groupWithDescription).toBeDefined();\n    expect(groupWithDescription.name).toBe(\"\");\n    expect(groupWithDescription.imageUrl).toBe(\"\");\n    expect(groupWithDescription.description).toBe(\"foo\");\n  });\n\n  it(\"should create a group with custom permissions\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const group = await client1.conversations.newGroup([client2.inboxId!], {\n      permissions: GroupPermissionsOptions.CustomPolicy,\n      customPermissionPolicySet: {\n        addAdminPolicy: 1,\n        addMemberPolicy: 0,\n        removeAdminPolicy: 1,\n        removeMemberPolicy: 1,\n        updateGroupNamePolicy: 1,\n        updateGroupDescriptionPolicy: 1,\n        updateGroupImageUrlSquarePolicy: 1,\n        updateMessageDisappearingPolicy: 1,\n      },\n    });\n    expect(group).toBeDefined();\n\n    const permissions = await group.permissions();\n    expect(permissions.policyType).toBe(GroupPermissionsOptions.CustomPolicy);\n    expect(permissions.policySet).toEqual({\n      addAdminPolicy: 1,\n      addMemberPolicy: 0,\n      removeAdminPolicy: 1,\n      removeMemberPolicy: 1,\n      updateGroupNamePolicy: 1,\n      updateGroupDescriptionPolicy: 1,\n      updateGroupImageUrlSquarePolicy: 1,\n      updateMessageDisappearingPolicy: 1,\n    });\n  });\n\n  it(\"should get conversation HMAC keys\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const user4 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const signer4 = createSigner(user4);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const client4 = await createRegisteredClient(signer4);\n    const group1 = await client1.conversations.newGroup([client2.inboxId!]);\n    const group2 = await client1.conversations.newGroup([client3.inboxId!]);\n    const group3 = await client1.conversations.newGroup([client4.inboxId!]);\n    const hmacKeys = await client1.conversations.getHmacKeys();\n    expect(hmacKeys).toBeDefined();\n    const groupIds = Object.keys(hmacKeys);\n    expect(groupIds).toContain(group1.id);\n    expect(groupIds).toContain(group2.id);\n    expect(groupIds).toContain(group3.id);\n    Object.values(hmacKeys).forEach((keys) => {\n      keys.forEach((key) => {\n        expect(key.epoch).toBeDefined();\n        expect(key.epoch).toBeGreaterThan(0);\n        expect(key.key).toBeDefined();\n        expect(key.key.length).toBe(42);\n      });\n    });\n  });\n\n  it(\"should sync groups across installations\", async () => {\n    const user = createUser();\n    const signer = createSigner(user);\n    const client = await createRegisteredClient(signer);\n    const client2 = await createRegisteredClient(signer, {\n      dbPath: `./test-${v4()}.db3`,\n    });\n    const user2 = createUser();\n    const signer2 = createSigner(user2);\n    await createRegisteredClient(signer2);\n\n    const group = await client.conversations.newGroup([client2.inboxId!]);\n\n    await client.conversations.sync();\n    await client2.conversations.sync();\n\n    const convos = await client2.conversations.list();\n    expect(convos.length).toBe(1);\n    expect(convos[0].id).toBe(group.id);\n\n    const group2 = await client.conversations.newDm(client2.inboxId!);\n\n    await client.conversations.sync();\n    await client2.conversations.sync();\n\n    const convos2 = await client2.conversations.list();\n    expect(convos2.length).toBe(2);\n    const convos2Ids = convos2.map((c) => c.id);\n    expect(convos2Ids).toContain(group.id);\n    expect(convos2Ids).toContain(group2.id);\n  });\n\n  it(\"should stitch DM groups together\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const dm1 = await client1.conversations.newDm(client2.inboxId!);\n    const dm2 = await client2.conversations.newDm(client1.inboxId!);\n\n    await dm1.send(\"hi\");\n    // since this is the last message sent, the stitched group ID will be\n    // this group ID\n    await dm2.send(\"hi\");\n\n    await client1.conversations.sync();\n    await client2.conversations.sync();\n    await dm1.sync();\n    await dm2.sync();\n\n    const dm1_2 = await client1.conversations.getConversationById(dm1.id);\n    const dm2_2 = await client2.conversations.getConversationById(dm2.id);\n    expect(dm1_2?.id).toBe(dm2.id);\n    expect(dm2_2?.id).toBe(dm2.id);\n\n    const dms1 = await client1.conversations.listDms();\n    const dms2 = await client2.conversations.listDms();\n    expect(dms1[0].id).toBe(dm2.id);\n    expect(dms2[0].id).toBe(dm2.id);\n\n    const dupeDms1 = await dms1[0].getDuplicateDms();\n    const dupeDms2 = await dms2[0].getDuplicateDms();\n    expect(dupeDms1.length).toBe(1);\n    expect(dupeDms2.length).toBe(1);\n    expect(dupeDms1[0].id).toBe(dm1.id);\n    expect(dupeDms2[0].id).toBe(dm1.id);\n  });\n});\n\ndescribe(\"Streaming\", () => {\n  it(\"should stream new conversations\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const stream = await client3.conversations.stream();\n    const conversation1 = await client1.conversations.newGroup([\n      client3.inboxId!,\n    ]);\n    const conversation2 = await client2.conversations.newGroup([\n      client3.inboxId!,\n    ]);\n\n    setTimeout(() => {\n      void stream.end();\n    }, 1000);\n\n    let count = 0;\n    for await (const convo of stream) {\n      count++;\n      if (count === 1) {\n        expect(convo.id).toBe(conversation1.id);\n      }\n      if (count === 2) {\n        expect(convo.id).toBe(conversation2.id);\n      }\n    }\n    expect(count).toBe(2);\n\n    const convo1 = await client3.conversations.getConversationById(\n      conversation1.id,\n    );\n    expect(convo1).toBeDefined();\n    expect(convo1!.id).toBe(conversation1.id);\n    const convo2 = await client3.conversations.getConversationById(\n      conversation2.id,\n    );\n    expect(convo2).toBeDefined();\n    expect(convo2!.id).toBe(conversation2.id);\n  });\n\n  it(\"should only stream group conversations\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const user4 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const signer4 = createSigner(user4);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const client4 = await createRegisteredClient(signer4);\n    const stream = await client3.conversations.streamGroups();\n    await client4.conversations.newDm(client3.inboxId!);\n    const group1 = await client1.conversations.newGroup([client3.inboxId!]);\n    const group2 = await client2.conversations.newGroup([client3.inboxId!]);\n\n    setTimeout(() => {\n      void stream.end();\n    }, 1000);\n\n    let count = 0;\n    for await (const convo of stream) {\n      count++;\n      if (count === 1) {\n        expect(convo.id).toBe(group1.id);\n      }\n      if (count === 2) {\n        expect(convo.id).toBe(group2.id);\n      }\n    }\n    expect(count).toBe(2);\n  });\n\n  it(\"should only stream dm conversations\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const user4 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const signer4 = createSigner(user4);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const client4 = await createRegisteredClient(signer4);\n    const stream = await client3.conversations.streamDms();\n    await client1.conversations.newGroup([client3.inboxId!]);\n    await client2.conversations.newGroup([client3.inboxId!]);\n    const group3 = await client4.conversations.newDm(client3.inboxId!);\n\n    setTimeout(() => {\n      void stream.end();\n    }, 1000);\n\n    let count = 0;\n    for await (const convo of stream) {\n      count++;\n      if (count === 1) {\n        expect(convo.id).toBe(group3.id);\n      }\n    }\n    expect(count).toBe(1);\n  });\n\n  it(\"should stream all messages\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    await client1.conversations.newGroup([client2.inboxId!]);\n    await client1.conversations.newGroup([client3.inboxId!]);\n\n    await sleep(2000);\n    const stream = await client1.conversations.streamAllMessages();\n\n    await client2.conversations.sync();\n    const groups2 = await client2.conversations.list();\n\n    await client3.conversations.sync();\n    const groups3 = await client3.conversations.list();\n\n    await groups2[0].send(\"gm!\");\n    await groups3[0].send(\"gm2!\");\n\n    setTimeout(() => {\n      void stream.end();\n    }, 1000);\n\n    let count = 0;\n    for await (const message of stream) {\n      count++;\n      if (count === 1) {\n        expect(message.senderInboxId).toBe(client2.inboxId);\n      }\n      if (count === 2) {\n        expect(message.senderInboxId).toBe(client3.inboxId);\n      }\n    }\n    expect(count).toBe(2);\n  });\n\n  it(\"should only stream group conversation messages\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const user4 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const signer4 = createSigner(user4);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const client4 = await createRegisteredClient(signer4);\n    await client1.conversations.newGroup([client2.inboxId!]);\n    await client1.conversations.newGroup([client3.inboxId!]);\n    await client1.conversations.newDm(client4.inboxId!);\n\n    await sleep(2000);\n    const stream = await client1.conversations.streamAllGroupMessages();\n\n    const groups2 = client2.conversations;\n    await groups2.sync();\n    const groupsList2 = await groups2.list();\n\n    const groups3 = client3.conversations;\n    await groups3.sync();\n    const groupsList3 = await groups3.list();\n\n    const groups4 = client4.conversations;\n    await groups4.sync();\n    const groupsList4 = await groups4.list();\n\n    await groupsList4[0].send(\"gm3!\");\n    await groupsList2[0].send(\"gm!\");\n    await groupsList3[0].send(\"gm2!\");\n\n    setTimeout(() => {\n      void stream.end();\n    }, 1000);\n\n    let count = 0;\n    for await (const message of stream) {\n      count++;\n      if (count === 1) {\n        expect(message.senderInboxId).toBe(client2.inboxId);\n      }\n      if (count === 2) {\n        expect(message.senderInboxId).toBe(client3.inboxId);\n      }\n    }\n    expect(count).toBe(2);\n  });\n\n  it(\"should only stream dm messages\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const user3 = createUser();\n    const user4 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const signer3 = createSigner(user3);\n    const signer4 = createSigner(user4);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const client3 = await createRegisteredClient(signer3);\n    const client4 = await createRegisteredClient(signer4);\n    await client1.conversations.newGroup([client2.inboxId!]);\n    await client1.conversations.newGroup([client3.inboxId!]);\n    await client1.conversations.newDm(client4.inboxId!);\n\n    await sleep(2000);\n    const stream = await client1.conversations.streamAllDmMessages();\n\n    await client2.conversations.sync();\n    const groupsList2 = await client2.conversations.list();\n\n    await client3.conversations.sync();\n    const groupsList3 = await client3.conversations.list();\n\n    await client4.conversations.sync();\n    const groupsList4 = await client4.conversations.list();\n\n    await groupsList2[0].send(\"gm!\");\n    await groupsList3[0].send(\"gm2!\");\n    await groupsList4[0].send(\"gm3!\");\n\n    setTimeout(() => {\n      void stream.end();\n    }, 1000);\n\n    let count = 0;\n    for await (const message of stream) {\n      count++;\n      if (count === 1) {\n        expect(message.senderInboxId).toBe(client4.inboxId);\n      }\n    }\n    expect(count).toBe(1);\n  });\n\n  it(\"should filter streamed messages by consent states\", async () => {\n    const user1 = createUser();\n    const user2 = createUser();\n    const signer1 = createSigner(user1);\n    const signer2 = createSigner(user2);\n    const client1 = await createRegisteredClient(signer1);\n    const client2 = await createRegisteredClient(signer2);\n    const group1 = await client1.conversations.newGroup([client2.inboxId!]);\n\n    await group1.updateConsentState(ConsentState.Denied);\n\n    await sleep(2000);\n    const stream = await client1.conversations.streamAllMessages({\n      consentStates: [ConsentState.Denied],\n    });\n\n    await client2.conversations.sync();\n    const groupsList2 = await client2.conversations.list();\n    const group2 = groupsList2[0];\n\n    await group2.send(\"gm\");\n\n    setTimeout(() => {\n      void stream.end();\n    }, 1000);\n\n    let count = 0;\n    for await (const message of stream) {\n      expect(message.content).toBe(\"gm\");\n      count++;\n    }\n    expect(count).toBe(1);\n  });\n\n  it(\"should create optimistic groups\", async () => {\n    const user1 = createUser();\n    const signer1 = createSigner(user1);\n    const client1 = await createRegisteredClient(signer1);\n    const group = await client1.conversations.newGroupOptimistic();\n    expect(group).toBeDefined();\n    expect(group.id).toBeDefined();\n    expect(group.createdAtNs).toBeDefined();\n    expect(group.createdAt).toBeDefined();\n    expect(await group.isActive()).toBe(true);\n    expect(group.name).toBe(\"\");\n    const permissions = await group.permissions();\n    expect(permissions.policyType).toBe(GroupPermissionsOptions.Default);\n    expect(permissions.policySet).toEqual({\n      addMemberPolicy: 0,\n      removeMemberPolicy: 2,\n      addAdminPolicy: 3,\n      removeAdminPolicy: 3,\n      updateGroupNamePolicy: 0,\n      updateGroupDescriptionPolicy: 0,\n      updateGroupImageUrlSquarePolicy: 0,\n      updateMessageDisappearingPolicy: 2,\n    });\n    expect(group.addedByInboxId).toBe(client1.inboxId);\n    expect((await group.messages()).length).toBe(0);\n\n    const group2 = await client1.conversations.newGroupOptimistic({\n      name: \"test\",\n      description: \"test\",\n      imageUrlSquare: \"test\",\n      permissions: GroupPermissionsOptions.CustomPolicy,\n      customPermissionPolicySet: {\n        addAdminPolicy: 1,\n        addMemberPolicy: 0,\n        removeAdminPolicy: 1,\n        removeMemberPolicy: 1,\n        updateGroupNamePolicy: 1,\n        updateGroupDescriptionPolicy: 1,\n        updateGroupImageUrlSquarePolicy: 1,\n        updateMessageDisappearingPolicy: 2,\n      },\n      messageDisappearingSettings: {\n        fromNs: 1000n,\n        inNs: 1000n,\n      },\n    });\n    expect(group2).toBeDefined();\n    expect(group2.id).toBeDefined();\n    expect(group2.createdAtNs).toBeDefined();\n    expect(group2.createdAt).toBeDefined();\n    expect(await group2.isActive()).toBe(true);\n    expect(group2.name).toBe(\"test\");\n    expect(group2.description).toBe(\"test\");\n    expect(group2.imageUrl).toBe(\"test\");\n    expect(group2.addedByInboxId).toBe(client1.inboxId);\n    const permissions2 = await group2.permissions();\n    expect(permissions2.policyType).toBe(GroupPermissionsOptions.CustomPolicy);\n    expect(permissions2.policySet).toEqual({\n      addAdminPolicy: 1,\n      addMemberPolicy: 0,\n      removeAdminPolicy: 1,\n      removeMemberPolicy: 1,\n      updateGroupNamePolicy: 1,\n      updateGroupDescriptionPolicy: 1,\n      updateGroupImageUrlSquarePolicy: 1,\n      updateMessageDisappearingPolicy: 2,\n    });\n    expect(await group2.isMessageDisappearingEnabled()).toBe(true);\n    expect(await group2.messageDisappearingSettings()).toEqual({\n      fromNs: 1000n,\n      inNs: 1000n,\n    });\n\n    expect((await group2.messages()).length).toBe(0);\n  });\n});\n",
      "size_bytes": 31217
    },
    "apps/xmtp.chat/src/components/App/AppHeader.tsx": {
      "content": "import { Badge, Box, Burger, Flex, Group, Stack, Text } from \"@mantine/core\";\nimport type { Client } from \"@xmtp/browser-sdk\";\nimport { useEffect, useState } from \"react\";\nimport { useNavigate } from \"react-router\";\nimport { AppMenu } from \"@/components/App/AppMenu\";\nimport type { ContentTypes } from \"@/contexts/XMTPContext\";\nimport { shortAddress } from \"@/helpers/strings\";\nimport { useSettings } from \"@/hooks/useSettings\";\nimport classes from \"./AppHeader.module.css\";\n\nconst GlowingCircle = () => {\n  return (\n    <Box\n      w={6}\n      h={6}\n      bg=\"#0afff1\"\n      style={{\n        borderRadius: \"5%\",\n        boxShadow: \"0px 0px 6px 2px rgba(10, 255, 241, 0.45)\",\n      }}\n    />\n  );\n};\n\nexport type AppHeaderProps = {\n  client: Client<ContentTypes>;\n  opened?: boolean;\n  toggle?: () => void;\n};\n\nexport const AppHeader: React.FC<AppHeaderProps> = ({\n  client,\n  opened,\n  toggle,\n}) => {\n  const navigate = useNavigate();\n  const { environment } = useSettings();\n  const [accountIdentifier, setAccountIdentifier] = useState<string | null>(\n    null,\n  );\n\n  useEffect(() => {\n    setAccountIdentifier(\n      client.accountIdentifier?.identifier.toLowerCase() ?? null,\n    );\n  }, [client.accountIdentifier]);\n\n  const handleClick = () => {\n    void navigate(\"identity\");\n  };\n\n  return (\n    <Flex align=\"center\" justify=\"space-between\" className={classes.shell}>\n      <Flex align=\"center\" gap=\"md\">\n        <div className={classes.burger}>\n          <Burger opened={opened} onClick={toggle} size=\"sm\" />\n        </div>\n        <Group gap=\"sm\" className={classes.brandGroup}>\n          <div className={classes.brandIcon}>MC</div>\n          <Stack\n            gap={2}\n            className=\"\"\n            style={{ }}>\n            <Text className={classes.brandName}>MumbleChat</Text>\n            <Text className={classes.brandTagline}>Ramestta messaging</Text>\n          </Stack>\n        </Group>\n      </Flex>\n      <Group align=\"center\" gap=\"sm\" className={classes.controls}>\n        <Badge className={classes.environment} radius=\"lg\" variant=\"light\">\n          <GlowingCircle />\n          <Text size=\"xs\" fw={600}>\n            {environment}\n          </Text>\n        </Badge>\n        <Box\n          className={classes.account}\n          aria-label={accountIdentifier || \"\"}\n          role=\"button\"\n          tabIndex={0}\n          onClick={handleClick}\n          onKeyDown={(event) => {\n            if (event.key === \"Enter\" || event.key === \" \") {\n              handleClick();\n            }\n          }}>\n          {accountIdentifier ? shortAddress(accountIdentifier) : \"...\"}\n        </Box>\n        <AppMenu />\n      </Group>\n    </Flex>\n  );\n};\n",
      "size_bytes": 2665
    },
    "apps/xmtp.chat/src/components/Messages/MessageModal.tsx": {
      "content": "import { Center, Code, ScrollArea, Stack, Tabs, Text } from \"@mantine/core\";\nimport { useNavigate, useOutletContext, useParams } from \"react-router\";\nimport { CodeWithCopy } from \"@/components/CodeWithCopy\";\nimport type { ConversationOutletContext } from \"@/components/Conversation/ConversationOutletContext\";\nimport { Modal } from \"@/components/Modal\";\nimport { useCollapsedMediaQuery } from \"@/hooks/useCollapsedMediaQuery\";\nimport { useMessage } from \"@/stores/inbox/hooks\";\nimport { MessageProperties } from \"./MessageProperties\";\n\nexport const MessageModal: React.FC = () => {\n  const { messageId } = useParams();\n  const { conversationId } = useOutletContext<ConversationOutletContext>();\n  const message = useMessage(conversationId, messageId ?? \"\");\n  const navigate = useNavigate();\n\n  const fullScreen = useCollapsedMediaQuery();\n  const contentHeight = fullScreen ? \"auto\" : 500;\n\n  return (\n    <Modal\n      opened\n      centered\n      fullScreen={fullScreen}\n      trapFocus\n      size=\"md\"\n      scrollAreaComponent={ScrollArea.Autosize}\n      onClose={() => void navigate(-1)}\n      title={\n        <Text size=\"lg\" fw={700} c=\"text.primary\">\n          Message details\n        </Text>\n      }>\n      {message ? (\n        <Stack\n          h={contentHeight}\n          flex={1}\n          gap=\"xs\"\n          style={{ overflow: \"hidden\" }}>\n          <Tabs\n            defaultValue=\"properties\"\n            flex={1}\n            style={{\n              overflow: \"hidden\",\n              display: \"flex\",\n              flexDirection: \"column\",\n            }}>\n            <Tabs.List>\n              <Tabs.Tab value=\"properties\">Properties</Tabs.Tab>\n              <Tabs.Tab value=\"encodedContent\">Encoded content</Tabs.Tab>\n              <Tabs.Tab value=\"decodedContent\">Decoded content</Tabs.Tab>\n            </Tabs.List>\n            <Tabs.Panel\n              value=\"properties\"\n              py=\"md\"\n              flex={1}\n              style={{\n                overflow: \"hidden\",\n                display: \"flex\",\n                flexDirection: \"column\",\n              }}>\n              <ScrollArea>\n                <MessageProperties message={message} />\n              </ScrollArea>\n            </Tabs.Panel>\n            <Tabs.Panel\n              value=\"encodedContent\"\n              py=\"md\"\n              flex={1}\n              style={{\n                overflow: \"hidden\",\n                display: \"flex\",\n                flexDirection: \"column\",\n              }}>\n              <ScrollArea>\n                <CodeWithCopy\n                  code={JSON.stringify(message.encodedContent, null, 2)}\n                />\n              </ScrollArea>\n            </Tabs.Panel>\n            <Tabs.Panel\n              value=\"decodedContent\"\n              py=\"md\"\n              flex={1}\n              style={{\n                overflow: \"hidden\",\n                display: \"flex\",\n                flexDirection: \"column\",\n              }}>\n              <ScrollArea>\n                {message.content !== undefined ? (\n                  <CodeWithCopy\n                    code={JSON.stringify(message.content, null, 2)}\n                  />\n                ) : (\n                  <Code\n                    p=\"md\"\n                    block\n                    style={{\n                      whiteSpace: \"pre-wrap\",\n                      wordBreak: \"break-word\",\n                    }}>\n                    The contents of this message could not be decoded.\n                  </Code>\n                )}\n              </ScrollArea>\n            </Tabs.Panel>\n          </Tabs>\n        </Stack>\n      ) : (\n        <Center>\n          <Text>Unable to load message</Text>\n        </Center>\n      )}\n    </Modal>\n  );\n};\n",
      "size_bytes": 3707
    },
    "apps/xmtp.chat/src/components/BadgeWithCopy.tsx": {
      "content": "import { ActionIcon, Badge, Text, Tooltip } from \"@mantine/core\";\nimport { useClipboard } from \"@mantine/hooks\";\nimport { IconCopy } from \"@/icons/IconCopy\";\nimport classes from \"./BadgeWithCopy.module.css\";\n\ntype CopyIconProps = {\n  value: string;\n};\n\nconst CopyIcon: React.FC<CopyIconProps> = ({ value }) => {\n  const clipboard = useClipboard({ timeout: 1000 });\n\n  const handleCopy = () => {\n    clipboard.copy(value);\n  };\n\n  const handleKeyboardCopy = (\n    event: React.KeyboardEvent<HTMLButtonElement>,\n  ) => {\n    if (event.key === \"Enter\" || event.key === \" \") {\n      handleCopy();\n    }\n  };\n\n  return (\n    <Tooltip\n      label={\n        clipboard.copied ? (\n          <Text size=\"xs\">Copied!</Text>\n        ) : (\n          <Text size=\"xs\">{value}</Text>\n        )\n      }\n      withArrow\n      events={{ hover: true, focus: true, touch: true }}>\n      <ActionIcon\n        variant=\"transparent\"\n        onClick={handleCopy}\n        onKeyDown={handleKeyboardCopy}\n        aria-label=\"Copy\"\n        className={classes.button}>\n        <IconCopy />\n      </ActionIcon>\n    </Tooltip>\n  );\n};\n\nexport type BadgeWithCopyProps = {\n  value: string;\n};\n\nexport const BadgeWithCopy: React.FC<BadgeWithCopyProps> = ({ value }) => {\n  return (\n    <Badge\n      variant=\"filled\"\n      className={classes.badge}\n      w=\"100%\"\n      size=\"xl\"\n      styles={{\n        label: {\n          textTransform: \"none\",\n          fontWeight: 400,\n          textAlign: \"left\",\n        },\n      }}\n      rightSection={<CopyIcon value={value} />}>\n      {value}\n    </Badge>\n  );\n};\n",
      "size_bytes": 1569
    },
    "apps/xmtp.chat/src/contexts/ConversationContext.tsx": {
      "content": "import { type DecodedMessage } from \"@xmtp/browser-sdk\";\nimport { createContext, useContext, useMemo, useState } from \"react\";\n\ntype ConversationContextType = {\n  conversationId: string;\n  replyTarget: DecodedMessage | undefined;\n  setReplyTarget: React.Dispatch<\n    React.SetStateAction<DecodedMessage | undefined>\n  >;\n};\n\nconst ConversationContext = createContext<ConversationContextType>({\n  conversationId: \"\",\n  replyTarget: undefined,\n  setReplyTarget: () => {},\n});\n\nexport type ConversationProviderProps = React.PropsWithChildren<{\n  conversationId: string;\n}>;\n\nexport const ConversationProvider: React.FC<ConversationProviderProps> = ({\n  children,\n  conversationId,\n}) => {\n  const [replyTarget, setReplyTarget] = useState<DecodedMessage | undefined>(\n    undefined,\n  );\n\n  const value = useMemo(\n    () => ({ conversationId, replyTarget, setReplyTarget }),\n    [conversationId, replyTarget, setReplyTarget],\n  );\n\n  return (\n    <ConversationContext.Provider value={value}>\n      {children}\n    </ConversationContext.Provider>\n  );\n};\n\nexport const useConversationContext = () => {\n  const context = useContext(ConversationContext);\n  if (!context.conversationId) {\n    throw new Error(\n      \"useConversationContext must be used within a ConversationProvider\",\n    );\n  }\n  return context;\n};\n",
      "size_bytes": 1309
    },
    "sdks/agent-sdk/README.md": {
      "content": "# XMTP Agent SDK\n\nBuild event‑driven, middleware‑powered messaging agents on the XMTP network. 🚀\n\n## Documentation\n\nFull agent building guide: **[Build an XMTP Agent](https://docs.xmtp.org/agents/get-started/build-an-agent)**\n\nThis SDK is based on familiar Node.js patterns: you register event listeners, compose middleware, and extend behavior just like you would in frameworks such as [Express](https://expressjs.com/). This makes it easy to bring existing JavaScript and TypeScript skills into building conversational agents.\n\n## Installation\n\nChoose your package manager:\n\n```bash\nnpm install @xmtp/agent-sdk\n# or\npnpm add @xmtp/agent-sdk\n# or\nyarn add @xmtp/agent-sdk\n```\n\n## Quick Start\n\n```ts\nimport { Agent } from \"@xmtp/agent-sdk\";\nimport { getTestUrl } from \"@xmtp/agent-sdk/debug\";\nimport { createUser, createSigner } from \"@xmtp/agent-sdk/user\";\n\n// 1. Create a local user + signer (you can plug in your own wallet signer)\nconst user = createUser();\nconst signer = createSigner(user);\n\n// 2. Spin up the agent\nconst agent = await Agent.create(signer, {\n  env: \"dev\", // or 'production'\n  dbPath: null, // in-memory store; provide a path to persist\n});\n\n// 3. Respond to text messages\nagent.on(\"text\", async (ctx) => {\n  await ctx.sendText(\"Hello from my XMTP Agent! 👋\");\n});\n\n// 4. Log when we're ready\nagent.on(\"start\", (ctx) => {\n  console.log(`We are online: ${getTestUrl(ctx.client)}`);\n});\n\nawait agent.start();\n```\n\n## Environment Variables\n\nThe XMTP Agent SDK supports configuration through environment variables (`process.env`), making it easy to configure your agent without code changes. Set the following variables and call `Agent.createFromEnv()` to automatically load them:\n\n**Available Variables:**\n\n| Variable                 | Purpose                                                                                                         | Example                                 |\n| ------------------------ | --------------------------------------------------------------------------------------------------------------- | --------------------------------------- |\n| `XMTP_DB_DIRECTORY`      | [Database directory](https://docs.xmtp.org/agents/build-agents/local-database#understand-local-database-files)  | `XMTP_DB_DIRECTORY=my/database/dir`     |\n| `XMTP_DB_ENCRYPTION_KEY` | [Database encryption key](https://docs.xmtp.org/agents/concepts/identity#keep-the-database-encryption-key-safe) | `XMTP_DB_ENCRYPTION_KEY=0xabcd...1234`  |\n| `XMTP_ENV`               | [Network environment](https://docs.xmtp.org/chat-apps/core-messaging/create-a-client#xmtp-network-environments) | `XMTP_ENV=dev` or `XMTP_ENV=production` |\n| `XMTP_WALLET_KEY`        | [Private key for Ethereum wallet](https://docs.xmtp.org/chat-apps/core-messaging/create-a-signer)               | `XMTP_WALLET_KEY=0x1234...abcd`         |\n\nUsing the environment variables, you can setup your agent in just a few lines of code:\n\n```ts\n// Load variables from .env file\nprocess.loadEnvFile(\".env\");\n\n// Create agent using environment variables\nconst agent = await Agent.createFromEnv();\n```\n\nAgents can also recognize the following environment variables:\n\n| Variable                 | Purpose                                                              | Example                        |\n| ------------------------ | -------------------------------------------------------------------- | ------------------------------ |\n| `XMTP_FORCE_DEBUG`       | [Activate debugging logs](https://docs.xmtp.org/agents/debug-agents) | `XMTP_FORCE_DEBUG=true`        |\n| `XMTP_FORCE_DEBUG_LEVEL` | Specify the logging level (defaults to `\"info\"`)                     | `XMTP_FORCE_DEBUG_LEVEL=debug` |\n\n## Core Concepts\n\n### 1. Event‑Driven Architecture\n\nSubscribe only to what you need using Node’s `EventEmitter` interface. Events you can listen for:\n\n**Message Events**\n\n- `attachment` – an incoming [remote attachment message](https://docs.xmtp.org/chat-apps/content-types/attachments)\n- `message` – all messages that are not having a [custom content type](https://docs.xmtp.org/agents/content-types/content-types#custom-content-types)\n- `group-update` – an incoming [group update](https://docs.xmtp.org/agents/content-types/group-updates#listen-for-group-updates) (like name change, member update, etc.)\n- `reaction` – an incoming [reaction message](https://docs.xmtp.org/agents/content-types/reactions)\n- `reply` – an incoming [reply message](https://docs.xmtp.org/agents/content-types/replies)\n- `text` – an incoming [text message](https://docs.xmtp.org/agents/content-types/content-types#text-content-type)\n- `unknownMessage` – a message event that does not correspond to any of the pre-implemented event types\n\n**Conversation Events**\n\n- `conversation` – a new group or DM conversation\n- `dm` – a new DM conversation\n- `group` – a new group conversation\n\n**Lifecycle Events**\n\n- `start` / `stop` – agent lifecycle events\n- `unhandledError` – unhandled errors\n\n**Example**\n\n```ts\n// Listen to specific message types\nagent.on(\"text\", async (ctx) => {\n  console.log(`Text message: ${ctx.message.content}`);\n});\n\nagent.on(\"reaction\", async (ctx) => {\n  console.log(`Reaction: ${ctx.message.content}`);\n});\n\nagent.on(\"reply\", async (ctx) => {\n  console.log(`Reply to: ${ctx.message.content.reference}`);\n});\n\n// Listen to new conversations\nagent.on(\"dm\", async (ctx) => {\n  await ctx.conversation.send(\"Welcome to our DM!\");\n});\n\nagent.on(\"group\", async (ctx) => {\n  await ctx.conversation.send(\"Hello group!\");\n});\n\n// Listen to unhandled events\nagent.on(\"unhandledError\", (error) => {\n  console.error(\"Agent error\", error);\n});\n\nagent.on(\"unknownMessage\", (ctx) => {\n  console.error(\"Message type is unknown\", ctx);\n});\n```\n\n> **⚠️ Important:** The `\"message\"` event fires for **every** incoming message, regardless of type. When using the `\"message\"` event, always filter message types to prevent infinite loops. Without proper filtering, your agent might respond to its own messages or react to system messages like read receipts.\n\n**Best Practice Example**\n\n```ts\nimport { filter } from \"@xmtp/agent-sdk\";\n\nagent.on(\"message\", async (ctx) => {\n  // Filter for specific message types\n  if (filter.isText(ctx.message)) {\n    await ctx.conversation.send(`Echo: ${ctx.message.content}`);\n  }\n});\n```\n\n### 2. Middleware Support\n\nExtend your agent with custom business logic using middlewares. Compose cross-cutting behavior like routing, telemetry, rate limiting, analytics, and feature flags, or plug in your own.\n\n#### Standard Middleware\n\nMiddlewares can be registered with `agent.use` either one at a time or as an array. They are executed in the order they were added.\n\nMiddleware functions receive a `ctx` (context) object and a `next` function. Normally, a middleware calls `next()` to hand off control to the next one in the chain. However, a middleware can also alter the flow in the following ways:\n\n1. Use `next()` to continue the chain and pass control to the next middleware\n2. Use `return` to stop the chain and prevent events from firing\n3. Use `throw` to trigger the error-handling middleware chain\n\n**Example**\n\n```ts\nimport { Agent, AgentMiddleware, filter } from \"@xmtp/agent-sdk\";\n\nconst onlyText: AgentMiddleware = async (ctx, next) => {\n  if (filter.isText(ctx.message)) {\n    // Continue to next middleware\n    await next();\n  }\n  // Break middleware chain\n  return;\n};\n\nconst agent = await Agent.createFromEnv();\nagent.use(onlyText);\n```\n\n#### Error-Handling Middleware\n\nError middleware can be registered with `agent.errors.use` either one at a time or as an array. They are executed in the order they were added.\n\nError middleware receives the `error`, `ctx`, and a `next` function. Just like regular middleware, the flow in error middleware depends on how to use `next`:\n\n1. Use `next()` to mark the error as handled and continue with the main middleware chain\n2. Use `next(error)` to forward the original (or transformed) error to the next error handler\n3. Use `return` to end error handling and stop the middleware chain\n4. Use `throw` to raise a new error to be caught by the error chain\n\n**Example**\n\n```ts\nimport { Agent, AgentErrorMiddleware } from \"@xmtp/agent-sdk\";\n\nconst errorHandler: AgentErrorMiddleware = async (error, ctx, next) => {\n  if (error instanceof Error) {\n    // Transform the error and pass it along\n    await next(`Validation failed: ${error.message}`);\n  } else {\n    // Let other error handlers deal with it\n    await next(error);\n  }\n};\n\nconst agent = await Agent.createFromEnv();\nagent.errors.use(errorHandler);\n```\n\n#### Default Error Handler\n\nAny error not handled by custom error middleware is caught by the default error handler and published to the `unhandledError` topic, where it can be observed.\n\n**Example**\n\n```ts\nagent.on(\"unhandledError\", (error) => {\n  console.log(\"Caught error\", error);\n});\n```\n\n### 3. Built‑in Filters\n\nInstead of manually checking every incoming message, you can use the provided filters.\n\n**Example**\n\n```ts\nimport { filter } from \"@xmtp/agent-sdk\";\n\n// Using filter in message handler\nagent.on(\"text\", async (ctx) => {\n  if (filter.isText(ctx.message)) {\n    await ctx.conversation.send(\"You sent a text message!\");\n  }\n});\n\n// Combine multiple conditions\nagent.on(\"text\", async (ctx) => {\n  if (\n    filter.hasDefinedContent(ctx.message) &&\n    !filter.fromSelf(ctx.message, ctx.client) &&\n    filter.isText(ctx.message)\n  ) {\n    await ctx.conversation.send(\"Valid text message received ✅\");\n  }\n});\n```\n\nFor convenience, the `filter` object can also be imported as `f`:\n\n```ts\n// You can import either name:\nimport { filter, f } from \"@xmtp/agent-sdk\";\n\n// Both work the same way:\nif (f.isText(ctx.message)) {\n  // Handle message...\n}\n```\n\n**Available Filters:**\n\nYou can find all available prebuilt filters [here](https://github.com/xmtp/xmtp-js/blob/main/sdks/agent-sdk/src/utils/filter.ts).\n\n### 4. Rich Context\n\nEvery message event handler receives a `MessageContext` with:\n\n- `message` – the decoded message object\n- `conversation` – the active conversation object\n- `client` – underlying XMTP client\n- Helpers like `sendTextReply()`, `sendReaction()`, `getSenderAddress`, and more\n\n**Example**\n\n```ts\nagent.on(\"text\", async (ctx) => {\n  await ctx.sendTextReply(\"Reply using helper ✨\");\n});\n```\n\n### 5. Starting Conversations\n\nThese functionalities let you start a conversation:\n\n```ts\n// Direct Message\nconst dm = await agent.createDmWithAddress(\"0x123\");\nawait dm.send(\"Hello!\");\n\n// Group Conversation\nconst group = await agent.createGroupWithAddresses([\"0x123\", \"0x456\"]);\nawait group.addMembers([\"0x789\"]);\nawait group.send(\"Hello group!\");\n```\n\n### 6. Utilities\n\nThe Agent SDK comes with subpackages that include utilities. You can for example get a testing URL or details of your Agent from the debug utilities:\n\n```ts\nimport { getTestUrl, logDetails } from \"@xmtp/agent-sdk/debug\";\n\n// Get a test URL for your agent\nconst testUrl = getTestUrl(agent.client);\nconsole.log(`Test your agent at: ${testUrl}`);\n\n// Log comprehensive details about your agent\nawait logDetails(agent.client);\n```\n\nThere are also utilities to simplify user management, such as signer creation or name resolutions:\n\n```ts\nimport {\n  createUser,\n  createSigner,\n  createNameResolver,\n} from \"@xmtp/agent-sdk/user\";\n\n// Create a new user with a random private key\nconst user = createUser();\n\n// Create a signer from the user\nconst signer = createSigner(user);\n\n// Resolve ENS names or other web3 identities using web3.bio\nconst resolver = createNameResolver(\"your-web3bio-api-key\");\nconst address = await resolver(\"vitalik.eth\");\nconsole.log(`Resolved address: ${address}`);\n```\n\n## Adding Custom Content Types\n\nPass `codecs` when creating your agent to extend supported content:\n\n```ts\nconst agent = await Agent.create(signer, {\n  env: \"dev\",\n  dbPath: null,\n  codecs: [new MyContentType()],\n});\n```\n\n## LibXMTP Version\n\n[LibXMTP](https://github.com/xmtp/libxmtp/) is a shared library encapsulating the core functionality of the XMTP messaging protocol, such as cryptography, networking, and language bindings. This version of the Agent SDK uses:\n\n| XMTP Node SDK Version | LibXMTP Version |\n| --------------------- | --------------- |\n| 4.2.3                 | 1.5.4           |\n\nTo verify which LibXMTP version is installed, run `npm why @xmtp/node-bindings` after installing the Agent SDK.\n\n## Debugging\n\n- [Debug an agent](https://docs.xmtp.org/agents/debug-agents)\n- [Further debugging info](https://docs.xmtp.org/inboxes/debug-your-app#debug-your-inbox-app)\n\n## Contributing / Feedback\n\nWe’d love your feedback: [open an issue](https://github.com/xmtp/xmtp-js/issues) or discussion. PRs welcome for docs, examples, and core improvements.\n\n---\n\nBuild something delightful. Then tell us what you wish was easier.\n\nHappy hacking 💫\n",
      "size_bytes": 12858
    }
  },
  "version": 2
}
